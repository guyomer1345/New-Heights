{
	"folder_history":
	[
	],
	"last_version": 3143,
	"last_window_id": 2,
	"log_indexing": false,
	"settings":
	{
		"new_window_height": 479.0,
		"new_window_settings":
		{
			"auto_complete":
			{
				"selected_items":
				[
				]
			},
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"console":
			{
				"height": 0.0,
				"history":
				[
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/AndroidManifest.xml",
				"/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterActivityEvents.java",
				"/C/Programming/python/bitly/emails and info",
				"/C/Programming/web/nightmare/bookmatrix.js"
			],
			"find":
			{
				"height": 48.0
			},
			"find_in_files":
			{
				"height": 0.0,
				"where_history":
				[
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"v2",
					"(\\w*),",
					"Lane,",
					"(\\w*),",
					"\\n",
					" ",
					"\\n",
					" ",
					"(\\w* )(\\w*)",
					"\\n",
					"push.*",
					".*90.*",
					".*350.*",
					".*700.*",
					"(.*Milliseconds)",
					"(.*duration)||(.*Milliseconds)",
					"\\n",
					" ",
					"90",
					"350",
					"push    ",
					"\\s*; dwduration",
					".*duration",
					"700",
					"50",
					"20",
					"\\n",
					"90",
					"100",
					"350",
					"\\s*;.*[o]",
					"[]\\s*.*[o]",
					"push    ",
					".* dw.*[o]",
					"350",
					"700",
					"             ; d.*[o]",
					"push    ",
					".* dw.*[o]",
					"\"\"",
					"([a-zA-Z0-9.@]*),",
					"naor1651996@gmail.com,",
					"([a-zA-Z0-9.@]*,)",
					"\\n",
					"gender"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"\"$1\",",
					"\"$1\", ",
					", ",
					"",
					", ",
					"",
					"$2",
					"$1",
					"",
					".",
					"-",
					" ",
					"",
					".",
					"-",
					"",
					" ",
					"",
					".",
					"-",
					"",
					"-",
					" ",
					"",
					"\"$1\",",
					"\"$1\"",
					"$1",
					", "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"incremental_find":
			{
				"height": 35.0
			},
			"input":
			{
				"height": 0.0
			},
			"menu_visible": true,
			"output.find_results":
			{
				"height": 0.0
			},
			"pinned_build_system": "",
			"replace":
			{
				"height": 66.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_symbol":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 150.0,
			"status_bar_visible": true,
			"template_settings":
			{
			}
		},
		"new_window_width": 640.0
	},
	"windows":
	[
		{
			"auto_complete":
			{
				"selected_items":
				[
				]
			},
			"buffers":
			[
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/BuildConfig.java",
					"settings":
					{
						"buffer_size": 408,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/MainActivity.java",
					"settings":
					{
						"buffer_size": 419,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/R.java",
					"settings":
					{
						"buffer_size": 376,
						"line_ending": "Windows"
					}
				},
				{
					"contents": "import 'package:flutter/material.dart';\nimport 'package:locksmither/routes.dart';\nvoid main() => runApp(LockSmitherApp());\nclass LockSmitherApp extends StatelessWidget {\n  @override\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'iWalk-LockSmither App',\n      theme: new ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      routes: routes,\n    );\nMfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/models/AuthURL.dart\nclass AuthURL {\n  String _url;\n  AuthURL(this._url);\n  AuthURL.map(dynamic obj) {\n    this._url = obj[\"AuthURL\"];\n  String get url => _url;\n  Map<String, dynamic> toMap() {\n    var map = new Map<String, dynamic>();\n    map[\"Url\"] = _url;\n    return map;\nKfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/models/token.dart\n>class Token {\n  String _lockURL;\n  bool _isValid;\n  int  _time;\n  Token(this._lockURL, this._isValid, this._time);\n  Token.map(dynamic obj) {\n    this._lockURL = obj[\"LockURL\"];\n    this._isValid = obj[\"IsValid\"];\n    this._time = obj[\"Time\"];\n  String get lockURL => _lockURL;\n  bool get isValid => _isValid;\n  int get time => _time != null ? _time : 0;\n  Map<String, dynamic> toMap() {\n    var map = new Map<String, dynamic>();\n    map[\"LockURL\"] = _lockURL;\n    map[\"IsValid\"] = _isValid;\n    map[\"Time\"] = _time;\n    return map;\n    \nQfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/network/cookie_jar.dart\nIimport 'package:locksmither/models/token.dart';\nclass CookieJar {\n  static CookieJar _instance = new CookieJar.internal();\n  CookieJar.internal();\n  factory CookieJar() => _instance;\n  Token _token;\n  void setToken(Token token) {\n    this._token = token;\n  Token getToken() {\n    return this._token;\nVfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/network/network_actions.dart\nimport 'dart:async';\nimport 'dart:convert';\nimport 'package:locksmither/network/network_wrapper.dart';\nimport 'package:locksmither/models/token.dart';\nimport 'package:locksmither/models/AuthURL.dart';\nclass NetworkActions {\n  NetworkWrapper _netUtil = new NetworkWrapper();\n  static const BASE_URL = \"http://35.246.158.51:8070\";\n  static const LOGIN_URL = BASE_URL + \"/auth/getUrl\";\n  Future<Token> login(String seed, String password) {\n    var headers = new Map<String,String>();\n      return _netUtil.get(LOGIN_URL, headers:headers).then((dynamic authUrl) {\n      try {\n        if (authUrl == null) {\n          return Future<Token>.sync(() => new Token(\"\", false, 0));\n        }\n        var loginUrl = BASE_URL + AuthURL.map(json.decode(authUrl.body)).url;\n        Map<String,String> body = { \"Seed\": seed, \"Password\": password };\n        Map<String,String> headers = {\"content-type\": \"application/json\"};\n        return _netUtil.post(loginUrl,body: json.encode(body), headers:headers).then((dynamic token) {                \n                return Token.map(token);\n              });\n      } catch (e) {\n        return Future<Token>.sync(() => new Token(\"\", false, 0));\n      }\n      }).catchError((e) { \n        return null; \n      });\nOKLx*\nVfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/network/network_wrapper.dart\nimport 'dart:async';\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\nclass NetworkWrapper {\n  // next three lines makes this class a Singleton\n  static const USER_AGENT = \"iWalk-v2\";\n  static NetworkWrapper _instance = new NetworkWrapper.internal();\n  NetworkWrapper.internal();\n  factory NetworkWrapper() => _instance;\n  final JsonDecoder _decoder = new JsonDecoder();\n  void addUserAgent(Map headers) {\n    if (!headers.containsKey(\"User-Agent\")) {\n      headers[\"User-Agent\"] = USER_AGENT;\n    }\n  Future<dynamic> getObject(String url, {Map headers}) {\n    addUserAgent(headers);\n    try {\n      return http.get(url, headers: headers).then((http.Response response) {\n        final String res = response.body;\n        final int statusCode = response.statusCode;\n        if (statusCode < 200 || statusCode > 400 || json == null) {\n          return null;\n        }\n        return _decoder.convert(res);\n      }).catchError((e) { return null; });\n    } catch (e) {\n      return null;\n    }\n  Future<http.Response> get(String url, {Map<String,String> headers}) {\n    addUserAgent(headers);\n    try {\n      return http.get(url, headers: headers).then((http.Response response) {\n        return response;\n      }).catchError((e) { return null; });\n    } catch (e) {\n      return null;\n    }\n  Future<dynamic> post(String url, {Map<String,String> headers, body, encoding}) {\n    addUserAgent(headers);\n    try {\n      return http\n          .post(url, body: body, headers: headers, encoding: encoding)\n          .then((http.Response response) {\n            final String res = response.body;\n            final int statusCode = response.statusCode;\n            if (statusCode < 200 || statusCode > 400 || json == null) {\n              return null;\n            }\n            return _decoder.convert(res);\n          }).catchError((e) { return null; });\n    } catch (e) {\n      return null;\n    }\nH,/9\nNfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/pages/home_page.dart\nGimport 'package:flutter/material.dart';\nimport 'package:locksmither/network/cookie_jar.dart';\nimport 'package:locksmither/models/token.dart';\nclass HomePage extends StatefulWidget {\n   @override\n  State<StatefulWidget> createState() {\n    return new HomePageState();\nclass HomePageState  extends State<HomePage> {\n  Token _token;\n  HomePageState() {\n    CookieJar jar = new CookieJar();\n    _token = jar.getToken();\n  String get lockURL => _token.lockURL;\n  int get time => _token.time;\n  @override\n  Widget build(BuildContext context) {\n    return new Scaffold(\n      appBar: new AppBar(title: new Text(\"Home\"),),\n      body: new Center(\n        \n        child: new Text(\"Success!\\nLock Url: $lockURL\\nObtained in: $time nanoseconds\"\n                ),\n              ),\n        );\nOfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/pages/login_page.dart\nimport 'dart:ui';\nimport 'package:flutter/material.dart';\nimport 'package:locksmither/network/network_actions.dart';\nimport 'package:locksmither/network/cookie_jar.dart';\nimport 'package:locksmither/models/token.dart';\nclass LoginPage extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return new LoginPageState();\nclass LoginPageState extends State<LoginPage> {\n  BuildContext _ctx;\n  bool _isLoading = false;\n  final formKey = new GlobalKey<FormState>();\n  final scaffoldKey = new GlobalKey<ScaffoldState>();\n  String _password;\n  String _seed;\n  NetworkActions _networkActions = new NetworkActions();\n  LoginPageState();\n  void _submit() async {\n    final form = formKey.currentState;\n    if (form.validate()) {\n      setState(() => _isLoading = true);\n      form.save();\n      _networkActions.login(_seed, _password)\n                      .then((result) => _loginCompleted(result))\n                      .catchError((e) { \n                        _loginCompleted(new Token(\"\", false, 0));\n                      });\n    }\n  void _loginCompleted(Token result) async {\n    Duration dur = new Duration(microseconds: (result.time/1000).round());\n    _showSnackBar(\"Completed in: \" +  dur.inMilliseconds.toString() + \" milliseconds result is: \" + result.isValid.toString());\n    setState(() => _isLoading = false);\n    if (result != null && result.isValid) {\n      CookieJar jar = new CookieJar();\n      jar.setToken(result);\n      Navigator.of(_ctx).pushReplacementNamed(\"/home\");\n    } \n  void _showSnackBar(String text) {\n    scaffoldKey.currentState\n        .showSnackBar(new SnackBar(content: new Text(text)));\n  @override\n  Widget build(BuildContext context) {\n    _ctx = context;\n    var loginBtn = new RaisedButton(\n      onPressed: _submit,\n      child: new Text(\"LOGIN\"),\n      color: Colors.blue,\n    );\n    var loginForm = new Column(\n      children: <Widget>[\n        new Text(\n          \"iWalk-LockSmither App\",\n          textScaleFactor: 2.0,\n        ),\n        new Form(\n          key: formKey,\n          child: new Column(\n            children: <Widget>[\n              new Padding(\n                padding: const EdgeInsets.all(8.0),\n                child: new TextFormField(\n                  onSaved: (val) => _seed = val,\n                  decoration: new InputDecoration(labelText: \"Seed\"),\n                ),\n              ),\n              new Padding(\n                padding: const EdgeInsets.all(8.0),\n                child: new TextFormField(\n                  onSaved: (val) => _password = val,\n                  decoration: new InputDecoration(labelText: \"Password\"),\n                ),\n              ),\n            ],\n          ),\n        ),\n        _isLoading ? new CircularProgressIndicator() : loginBtn\n      ],\n      crossAxisAlignment: CrossAxisAlignment.center,\n    );\n    return new Scaffold(\n      appBar: null,\n      key: scaffoldKey,\n      body: new Container(\n        child: new Center(\n          child: new ClipRect(\n            child: new BackdropFilter(\n              filter: new ImageFilter.blur(sigmaX: 10.0, sigmaY: 10.0),\n              child: new Container(\n                child: loginForm,\n                height: 300.0,\n                width: 300.0,\n                decoration: new BoxDecoration(\n                    color: Colors.grey.shade200.withOpacity(0.5)),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n)<71\n/B*C\n5+2G\n5+6K\n (I%# \nEfile:///C:/Users/USER/Desktop/2019/client/locksmither/lib/routes.dart\ncimport 'package:flutter/material.dart';\nimport 'package:locksmither/pages/login_page.dart';\nimport 'package:locksmither/pages/home_page.dart';\nfinal routes = {\n  '/login':         (BuildContext context) => new LoginPage(),\n  '/home':         (BuildContext context) => new HomePage(),\n  '/' :          (BuildContext context) => new LoginPage(),\nTfile:///C:/dev/flutter/.pub-cache/hosted/pub.dartlang.org/async-2.0.8/lib/async.dart\n2// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\nexport \"src/async_cache.dart\";\nexport \"src/async_memoizer.dart\";\nexport \"src/byte_collector.dart\";\nexport \"src/cancelable_operation.dart\";\nexport \"src/delegate/event_sink.dart\";\nexport \"src/delegate/future.dart\";\nexport \"src/delegate/sink.dart\";\nexport \"src/delegate/stream.dart\";\nexport \"src/delegate/stream_consumer.dart\";\nexport \"src/delegate/stream_sink.dart\";\nexport \"src/delegate/stream_subscription.dart\";\nexport \"src/future_group.dart\";\nexport \"src/lazy_stream.dart\";\nexport \"src/null_stream_sink.dart\";\nexport \"src/restartable_timer.dart\";\nexport \"src/result/result.dart\";\nexport \"src/result/error.dart\";\nexport \"src/result/future.dart\";\nexport \"src/result/value.dart\";\nexport \"src/single_subscription_transformer.dart\";\nexport \"src/stream_completer.dart\";\nexport \"src/stream_group.dart\";\nexport \"src/stream_queue.dart\";\nexport \"src/stream_sink_completer.dart\";\nexport \"src/stream_sink_transformer.dart\";\nexport \"src/stream_splitter.dart\";\nexport \"src/stream_subscription_transformer.dart\";\nexport \"src/stream_zip.dart\";\nexport \"src/subscription_stream.dart\";\nexport \"src/typed_stream_transformer.dart\";\n\"\"('#!#,(0 \n$%! ! 3$  )+#3\n^file:///C:/dev/flutter/.pub-cache/hosted/pub.dartlang.org/async-2.0.8/lib/src/async_cache.dart\n// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\nimport 'dart:async';\nimport 'package:async/async.dart';\n/// Runs asynchronous functions and caches the result for a period of time.\n/// This class exists to cover the pattern of having potentially expensive code\n/// such as file I/O, network access, or isolate computation that's unlikely to\n/// change quickly run fewer times. For example:\n/// ```dart\n/// final _usersCache = new AsyncCache<List<String>>(const Duration(hours: 1));\n/// /// Uses the cache if it exists, otherwise calls the closure:\n/// Future<List<String>> get onlineUsers => _usersCache.fetch(() {\n///   // Actually fetch online users here.\n/// });\n/// ```\n/// This class's timing can be mocked using [`fake_async`][fake_async].\n/// [fake_async]: https://pub.dartlang.org/packages/fake_async\nclass AsyncCache<T> {\n  /// How long cached values stay fresh.\n  final Duration _duration;\n  /// Cached results of a previous [fetchStream] call.\n  StreamSplitter<T> _cachedStreamSplitter;\n  /// Cached results of a previous [fetch] call.\n  Future<T> _cachedValueFuture;\n  /// Fires when the cache should be considered stale.\n  Timer _stale;\n  /// Creates a cache that invalidates its contents after [duration] has passed.\n  ///\n  /// The [duration] starts counting after the Future returned by [fetch]\n  /// completes, or after the Stream returned by [fetchStream] emits a done\n  /// event.\n  AsyncCache(this._duration);\n  /// Creates a cache that invalidates after an in-flight request is complete.\n  ///\n  /// An ephemeral cache guarantees that a callback function will only be\n  /// executed at most once concurrently. This is useful for requests for which\n  /// data is updated frequently but stale data is acceptable.\n  factory AsyncCache.ephemeral() => new AsyncCache(Duration.zero);\n  /// Returns a cached value from a previous call to [fetch], or runs [callback]\n  /// to compute a new one.\n  ///\n  /// If [fetch] has been called recently enough, returns its previous return\n  /// value. Otherwise, runs [callback] and returns its new return value.\n  Future<T> fetch(Future<T> callback()) async {\n    if (_cachedStreamSplitter != null) {\n      throw new StateError('Previously used to cache via `fetchStream`');\n    }\n    if (_cachedValueFuture == null) {\n      _cachedValueFuture = callback();\n      await _cachedValueFuture;\n      _startStaleTimer();\n    }\n    return _cachedValueFuture;\n  /// Returns a cached stream from a previous call to [fetchStream], or runs\n  /// [callback] to compute a new stream.\n  ///\n  /// If [fetchStream] has been called recently enough, returns a copy of its\n  /// previous return value. Otherwise, runs [callback] and returns its new\n  /// return value.\n  Stream<T> fetchStream(Stream<T> callback()) {\n    if (_cachedValueFuture != null) {\n      throw new StateError('Previously used to cache via `fetch`');\n    }\n    if (_cachedStreamSplitter == null) {\n      _cachedStreamSplitter = new StreamSplitter(callback()\n          .transform(new StreamTransformer.fromHandlers(handleDone: (sink) {\n        _startStaleTimer();\n        sink.close();\n      })));\n    }\n    return _cachedStreamSplitter.split();\n  /// Removes any cached value.\n  void invalidate() {\n    // TODO: This does not return a future, but probably should.\n    _cachedValueFuture = null;\n    // TODO: This does not await, but probably should.\n    _cachedStreamSplitter?.close();\n    _cachedStreamSplitter = null;\n    _stale?.cancel();\n    _stale = null;\n  void _startStaleTimer() {\n    _stale = new Timer(_duration, invalidate);",
					"settings":
					{
						"buffer_size": 15162,
						"line_ending": "Windows",
						"name": "import 'package:flutter/material.dart';"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/resources/AndroidManifest.xml",
					"settings":
					{
						"buffer_size": 1285,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/resources/assets/flutter_assets/LICENSE",
					"settings":
					{
						"buffer_size": 633755,
						"encoding": "UTF-8",
						"line_ending": "Unix"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test.txt",
					"settings":
					{
						"buffer_size": 4822091,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test2.txt",
					"settings":
					{
						"buffer_size": 355564,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test1.txt",
					"settings":
					{
						"buffer_size": 10257563,
						"line_ending": "Windows"
					}
				},
				{
					"contents": "\"use strict\";\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n(function () {\n\t'use strict';\n\n\t//**************************************************************************************\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleReturnPointsJS\n\t/**\n  * Get value for input parameters, or set a default value\n  * @param {Object} parameters\n  * @param {string} name\n  * @param defaultValue\n  */\n\tfunction arrayBufferToBase64String(arrayBuffer) {\n      var byteArray = new Uint8Array(arrayBuffer)\n      var byteString = ''\n      for (var i=0; i<byteArray.byteLength; i++) {\n        byteString += String.fromCharCode(byteArray[i])\n      }\n      return btoa(byteString)\n    }\n\t\n\tfunction convertBinaryToPem(binaryData, label) {\n      var base64Cert = arrayBufferToBase64String(binaryData)\n      var pemCert = \"-----BEGIN \" + label + \"-----\\r\\n\"\n      var nextIndex = 0\n      var lineLength\n      while (nextIndex < base64Cert.length) {\n        if (nextIndex + 64 <= base64Cert.length) {\n          pemCert += base64Cert.substr(nextIndex, 64) + \"\\r\\n\"\n        } else {\n          pemCert += base64Cert.substr(nextIndex) + \"\\r\\n\"\n        }\n        nextIndex += 64\n      }\n      pemCert += \"-----END \" + label + \"-----\\r\\n\"\n      return pemCert\n    }\n\t\n\tfunction exportPrivateKey(keys) {\n      return new Promise(function(resolve) {\n        var expK = window.crypto.subtle.exportKey('pkcs8', keys.privateKey)\n        expK.then(function(pkcs8) {\n          resolve(convertBinaryToPem(pkcs8, \"RSA PRIVATE KEY\"))\n        })\n      })\n    }\n\t\n\t//**************************************************************************************\n\n\tfunction getParametersValue(parameters, name, defaultValue) {\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\n\t\tif (parameters instanceof Object === false) return defaultValue;\n\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tif (name in parameters) return parameters[name];\n\n\t\treturn defaultValue;\n\t}\n\t//**************************************************************************************\n\t/**\n  * Converts \"ArrayBuffer\" into a hexdecimal string\n  * @param {ArrayBuffer} inputBuffer\n  * @param {number} [inputOffset=0]\n  * @param {number} [inputLength=inputBuffer.byteLength]\n  * @param {boolean} [insertSpace=false]\n  * @returns {string}\n  */\n\tfunction bufferToHexCodes(inputBuffer) {\n\t\tvar inputOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\tvar inputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputBuffer.byteLength - inputOffset;\n\t\tvar insertSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\tvar result = \"\";\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = new Uint8Array(inputBuffer, inputOffset, inputLength)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar item = _step.value;\n\n\t\t\t\t// noinspection ChainedFunctionCallJS\n\t\t\t\tvar str = item.toString(16).toUpperCase();\n\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\t\tif (str.length === 1) result += \"0\";\n\n\t\t\t\tresult += str;\n\n\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\tif (insertSpace) result += \" \";\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result.trim();\n\t}\n\t//**************************************************************************************\n\t// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS\n\t/**\n  * Check input \"ArrayBuffer\" for common functions\n  * @param {LocalBaseBlock} baseBlock\n  * @param {ArrayBuffer} inputBuffer\n  * @param {number} inputOffset\n  * @param {number} inputLength\n  * @returns {boolean}\n  */\n\tfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (inputBuffer instanceof ArrayBuffer === false) {\n\t\t\t// noinspection JSUndefinedPropertyAssignment\n\t\t\tbaseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\n\t\t\treturn false;\n\t\t}\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (inputBuffer.byteLength === 0) {\n\t\t\t// noinspection JSUndefinedPropertyAssignment\n\t\t\tbaseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n\t\t\treturn false;\n\t\t}\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (inputOffset < 0) {\n\t\t\t// noinspection JSUndefinedPropertyAssignment\n\t\t\tbaseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n\t\t\treturn false;\n\t\t}\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (inputLength < 0) {\n\t\t\t// noinspection JSUndefinedPropertyAssignment\n\t\t\tbaseBlock.error = \"Wrong parameter: inputLength less than zero\";\n\t\t\treturn false;\n\t\t}\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n\t\t\t// noinspection JSUndefinedPropertyAssignment\n\t\t\tbaseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleReturnPointsJS\n\t/**\n  * Convert number from 2^base to 2^10\n  * @param {Uint8Array} inputBuffer\n  * @param {number} inputBase\n  * @returns {number}\n  */\n\tfunction utilFromBase(inputBuffer, inputBase) {\n\t\tvar result = 0;\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\n\t\tif (inputBuffer.length === 1) return inputBuffer[0];\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\n\t\tfor (var i = inputBuffer.length - 1; i >= 0; i--) {\n\t\t\tresult += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);\n\t\t}return result;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\n\t/**\n  * Convert number from 2^10 to 2^base\n  * @param {!number} value The number to convert\n  * @param {!number} base The base for 2^base\n  * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)\n  * @returns {ArrayBuffer}\n  */\n\tfunction utilToBase(value, base) {\n\t\tvar reserved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n\t\tvar internalReserved = reserved;\n\t\tvar internalValue = value;\n\n\t\tvar result = 0;\n\t\tvar biggest = Math.pow(2, base);\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tfor (var i = 1; i < 8; i++) {\n\t\t\tif (value < biggest) {\n\t\t\t\tvar retBuf = void 0;\n\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tif (internalReserved < 0) {\n\t\t\t\t\tretBuf = new ArrayBuffer(i);\n\t\t\t\t\tresult = i;\n\t\t\t\t} else {\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tif (internalReserved < i) return new ArrayBuffer(0);\n\n\t\t\t\t\tretBuf = new ArrayBuffer(internalReserved);\n\n\t\t\t\t\tresult = internalReserved;\n\t\t\t\t}\n\n\t\t\t\tvar retView = new Uint8Array(retBuf);\n\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar basis = Math.pow(2, j * base);\n\n\t\t\t\t\tretView[result - j - 1] = Math.floor(internalValue / basis);\n\t\t\t\t\tinternalValue -= retView[result - j - 1] * basis;\n\t\t\t\t}\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tbiggest *= Math.pow(2, base);\n\t\t}\n\n\t\treturn new ArrayBuffer(0);\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS\n\t/**\n  * Concatenate two ArrayBuffers\n  * @param {...ArrayBuffer} buffers Set of ArrayBuffer\n  */\n\tfunction utilConcatBuf() {\n\t\t//region Initial variables\n\t\tvar outputLength = 0;\n\t\tvar prevLength = 0;\n\t\t//endregion\n\n\t\t//region Calculate output length\n\n\t\t// noinspection NonBlockStatementBodyJS\n\n\t\tfor (var _len = arguments.length, buffers = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\tbuffers[_key] = arguments[_key];\n\t\t}\n\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = buffers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar buffer = _step2.value;\n\n\t\t\t\toutputLength += buffer.byteLength;\n\t\t\t} //endregion\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar retBuf = new ArrayBuffer(outputLength);\n\t\tvar retView = new Uint8Array(retBuf);\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = buffers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _buffer = _step3.value;\n\n\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\tretView.set(new Uint8Array(_buffer), prevLength);\n\t\t\t\tprevLength += _buffer.byteLength;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS\n\t/**\n  * Concatenate two Uint8Array\n  * @param {...Uint8Array} views Set of Uint8Array\n  */\n\tfunction utilConcatView() {\n\t\t//region Initial variables\n\t\tvar outputLength = 0;\n\t\tvar prevLength = 0;\n\t\t//endregion\n\n\t\t//region Calculate output length\n\t\t// noinspection NonBlockStatementBodyJS\n\n\t\tfor (var _len2 = arguments.length, views = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\tviews[_key2] = arguments[_key2];\n\t\t}\n\n\t\tvar _iteratorNormalCompletion4 = true;\n\t\tvar _didIteratorError4 = false;\n\t\tvar _iteratorError4 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator4 = views[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\t\tvar view = _step4.value;\n\n\t\t\t\toutputLength += view.length;\n\t\t\t} //endregion\n\t\t} catch (err) {\n\t\t\t_didIteratorError4 = true;\n\t\t\t_iteratorError4 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t\t_iterator4.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError4) {\n\t\t\t\t\tthrow _iteratorError4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar retBuf = new ArrayBuffer(outputLength);\n\t\tvar retView = new Uint8Array(retBuf);\n\n\t\tvar _iteratorNormalCompletion5 = true;\n\t\tvar _didIteratorError5 = false;\n\t\tvar _iteratorError5 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator5 = views[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t\t\t\tvar _view2 = _step5.value;\n\n\t\t\t\tretView.set(_view2, prevLength);\n\t\t\t\tprevLength += _view2.length;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError5 = true;\n\t\t\t_iteratorError5 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t\t\t\t\t_iterator5.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError5) {\n\t\t\t\t\tthrow _iteratorError5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn retView;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS\n\t/**\n  * Decoding of \"two complement\" values\n  * The function must be called in scope of instance of \"hexBlock\" class (\"valueHex\" and \"warnings\" properties must be present)\n  * @returns {number}\n  */\n\tfunction utilDecodeTC() {\n\t\tvar buf = new Uint8Array(this.valueHex);\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tif (this.valueHex.byteLength >= 2) {\n\t\t\t//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar condition1 = buf[0] === 0xFF && buf[1] & 0x80;\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (condition1 || condition2) this.warnings.push(\"Needlessly long format\");\n\t\t}\n\n\t\t//region Create big part of the integer\n\t\tvar bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n\t\tvar bigIntView = new Uint8Array(bigIntBuffer);\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tfor (var i = 0; i < this.valueHex.byteLength; i++) {\n\t\t\tbigIntView[i] = 0;\n\t\t} // noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\tbigIntView[0] = buf[0] & 0x80; // mask only the biggest bit\n\n\t\tvar bigInt = utilFromBase(bigIntView, 8);\n\t\t//endregion\n\n\t\t//region Create small part of the integer\n\t\tvar smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n\t\tvar smallIntView = new Uint8Array(smallIntBuffer);\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tfor (var j = 0; j < this.valueHex.byteLength; j++) {\n\t\t\tsmallIntView[j] = buf[j];\n\t\t} // noinspection MagicNumberJS\n\t\tsmallIntView[0] &= 0x7F; // mask biggest bit\n\n\t\tvar smallInt = utilFromBase(smallIntView, 8);\n\t\t//endregion\n\n\t\treturn smallInt - bigInt;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\n\t/**\n  * Encode integer value to \"two complement\" format\n  * @param {number} value Value to encode\n  * @returns {ArrayBuffer}\n  */\n\tfunction utilEncodeTC(value) {\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS\n\t\tvar modValue = value < 0 ? value * -1 : value;\n\t\tvar bigInt = 128;\n\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\tfor (var i = 1; i < 8; i++) {\n\t\t\tif (modValue <= bigInt) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tif (value < 0) {\n\t\t\t\t\tvar smallInt = bigInt - modValue;\n\n\t\t\t\t\tvar _retBuf = utilToBase(smallInt, 8, i);\n\t\t\t\t\tvar _retView = new Uint8Array(_retBuf);\n\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\t_retView[0] |= 0x80;\n\n\t\t\t\t\treturn _retBuf;\n\t\t\t\t}\n\n\t\t\t\tvar retBuf = utilToBase(modValue, 8, i);\n\t\t\t\tvar retView = new Uint8Array(retBuf);\n\n\t\t\t\t//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\t\tif (retView[0] & 0x80) {\n\t\t\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\t\t\tvar tempBuf = retBuf.slice(0);\n\t\t\t\t\tvar tempView = new Uint8Array(tempBuf);\n\n\t\t\t\t\tretBuf = new ArrayBuffer(retBuf.byteLength + 1);\n\t\t\t\t\t// noinspection ReuseOfLocalVariableJS\n\t\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tfor (var k = 0; k < tempBuf.byteLength; k++) {\n\t\t\t\t\t\tretView[k + 1] = tempView[k];\n\t\t\t\t\t} // noinspection MagicNumberJS\n\t\t\t\t\tretView[0] = 0x00;\n\t\t\t\t}\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tbigInt *= Math.pow(2, 8);\n\t\t}\n\n\t\treturn new ArrayBuffer(0);\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS\n\t/**\n  * Compare two array buffers\n  * @param {!ArrayBuffer} inputBuffer1\n  * @param {!ArrayBuffer} inputBuffer2\n  * @returns {boolean}\n  */\n\tfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tif (inputBuffer1.byteLength !== inputBuffer2.byteLength) return false;\n\n\t\t// noinspection LocalVariableNamingConventionJS\n\t\tvar view1 = new Uint8Array(inputBuffer1);\n\t\t// noinspection LocalVariableNamingConventionJS\n\t\tvar view2 = new Uint8Array(inputBuffer2);\n\n\t\tfor (var i = 0; i < view1.length; i++) {\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (view1[i] !== view2[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleReturnPointsJS\n\t/**\n  * Pad input number with leade \"0\" if needed\n  * @returns {string}\n  * @param {number} inputNumber\n  * @param {number} fullLength\n  */\n\tfunction padNumber(inputNumber, fullLength) {\n\t\tvar str = inputNumber.toString(10);\n\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tif (fullLength < str.length) return \"\";\n\n\t\tvar dif = fullLength - str.length;\n\n\t\tvar padding = new Array(dif);\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tfor (var i = 0; i < dif; i++) {\n\t\t\tpadding[i] = \"0\";\n\t\t}var paddingString = padding.join(\"\");\n\n\t\treturn paddingString.concat(str);\n\t}\n\t//**************************************************************************************\n\tvar base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\tvar base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\n\t//**************************************************************************************\n\t// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS, FunctionNamingConventionJS\n\t/**\n  * Encode string into BASE64 (or \"base64url\")\n  * @param {string} input\n  * @param {boolean} useUrlTemplate If \"true\" then output would be encoded using \"base64url\"\n  * @param {boolean} skipPadding Skip BASE-64 padding or not\n  * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not\n  * @returns {string}\n  */\n\tfunction toBase64(input) {\n\t\tvar useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\tvar skipPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\tvar skipLeadingZeros = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\tvar i = 0;\n\n\t\t// noinspection LocalVariableNamingConventionJS\n\t\tvar flag1 = 0;\n\t\t// noinspection LocalVariableNamingConventionJS\n\t\tvar flag2 = 0;\n\n\t\tvar output = \"\";\n\n\t\t// noinspection ConditionalExpressionJS\n\t\tvar template = useUrlTemplate ? base64UrlTemplate : base64Template;\n\n\t\tif (skipLeadingZeros) {\n\t\t\tvar nonZeroPosition = 0;\n\n\t\t\tfor (var _i = 0; _i < input.length; _i++) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tif (input.charCodeAt(_i) !== 0) {\n\t\t\t\t\tnonZeroPosition = _i;\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\tinput = input.slice(nonZeroPosition);\n\t\t}\n\n\t\twhile (i < input.length) {\n\t\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\n\t\t\tvar chr1 = input.charCodeAt(i++);\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (i >= input.length) flag1 = 1;\n\t\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\n\t\t\tvar chr2 = input.charCodeAt(i++);\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (i >= input.length) flag2 = 1;\n\t\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\n\t\t\tvar chr3 = input.charCodeAt(i++);\n\n\t\t\t// noinspection LocalVariableNamingConventionJS\n\t\t\tvar enc1 = chr1 >> 2;\n\t\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;\n\t\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;\n\t\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar enc4 = chr3 & 0x3F;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\tif (flag1 === 1) {\n\t\t\t\t// noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS\n\t\t\t\tenc3 = enc4 = 64;\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tif (flag2 === 1) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (skipPadding) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\n\t\t\t\tif (enc3 === 64) output += `${template.charAt(enc1)}${template.charAt(enc2)}`;else {\n\t\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\n\t\t\t\t\tif (enc4 === 64) output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;else output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n\t\t\t\t}\n\t\t\t} else output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n\t\t}\n\n\t\treturn output;\n\t}\n\t//**************************************************************************************\n\t// noinspection FunctionWithMoreThanThreeNegationsJS, FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionNamingConventionJS\n\t/**\n  * Decode string from BASE64 (or \"base64url\")\n  * @param {string} input\n  * @param {boolean} [useUrlTemplate=false] If \"true\" then output would be encoded using \"base64url\"\n  * @param {boolean} [cutTailZeros=false] If \"true\" then cut tailing zeroz from function result\n  * @returns {string}\n  */\n\tfunction fromBase64(input) {\n\t\tvar useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\tvar cutTailZeros = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\t\t// noinspection ConditionalExpressionJS\n\t\tvar template = useUrlTemplate ? base64UrlTemplate : base64Template;\n\n\t\t//region Aux functions\n\t\t// noinspection FunctionWithMultipleReturnPointsJS, NestedFunctionJS\n\t\tfunction indexof(toSearch) {\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS\n\t\t\tfor (var _i2 = 0; _i2 < 64; _i2++) {\n\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\tif (template.charAt(_i2) === toSearch) return _i2;\n\t\t\t}\n\n\t\t\t// noinspection MagicNumberJS\n\t\t\treturn 64;\n\t\t}\n\n\t\t// noinspection NestedFunctionJS\n\t\tfunction test(incoming) {\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS\n\t\t\treturn incoming === 64 ? 0x00 : incoming;\n\t\t}\n\t\t//endregion\n\n\t\tvar i = 0;\n\n\t\tvar output = \"\";\n\n\t\twhile (i < input.length) {\n\t\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\n\t\t\tvar enc1 = indexof(input.charAt(i++));\n\t\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\n\t\t\tvar enc2 = i >= input.length ? 0x00 : indexof(input.charAt(i++));\n\t\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\n\t\t\tvar enc3 = i >= input.length ? 0x00 : indexof(input.charAt(i++));\n\t\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\n\t\t\tvar enc4 = i >= input.length ? 0x00 : indexof(input.charAt(i++));\n\n\t\t\t// noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar chr1 = test(enc1) << 2 | test(enc2) >> 4;\n\t\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;\n\t\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\n\t\t\tvar chr3 = (test(enc3) & 0x03) << 6 | test(enc4);\n\n\t\t\toutput += String.fromCharCode(chr1);\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\n\t\t\tif (enc3 !== 64) output += String.fromCharCode(chr2);\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\n\t\t\tif (enc4 !== 64) output += String.fromCharCode(chr3);\n\t\t}\n\n\t\tif (cutTailZeros) {\n\t\t\tvar outputLength = output.length;\n\t\t\tvar nonZeroStart = -1;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\tfor (var _i3 = outputLength - 1; _i3 >= 0; _i3--) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\n\t\t\t\tif (output.charCodeAt(_i3) !== 0) {\n\t\t\t\t\tnonZeroStart = _i3;\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS, NegatedIfStatementJS\n\t\t\tif (nonZeroStart !== -1) output = output.slice(0, nonZeroStart + 1);else output = \"\";\n\t\t}\n\n\t\treturn output;\n\t}\n\t//**************************************************************************************\n\tfunction arrayBufferToString(buffer) {\n\t\tvar resultString = \"\";\n\t\tvar view = new Uint8Array(buffer);\n\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tvar _iteratorNormalCompletion6 = true;\n\t\tvar _didIteratorError6 = false;\n\t\tvar _iteratorError6 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator6 = view[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t\t\t\tvar element = _step6.value;\n\n\t\t\t\tresultString += String.fromCharCode(element);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError6 = true;\n\t\t\t_iteratorError6 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t\t\t\t\t_iterator6.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError6) {\n\t\t\t\t\tthrow _iteratorError6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resultString;\n\t}\n\t//**************************************************************************************\n\tfunction stringToArrayBuffer(str) {\n\t\tvar stringLength = str.length;\n\n\t\tvar resultBuffer = new ArrayBuffer(stringLength);\n\t\tvar resultView = new Uint8Array(resultBuffer);\n\n\t\t// noinspection NonBlockStatementBodyJS\n\t\tfor (var i = 0; i < stringLength; i++) {\n\t\t\tresultView[i] = str.charCodeAt(i);\n\t\t}return resultBuffer;\n\t}\n\t//**************************************************************************************\n\tvar log2 = Math.log(2);\n\t//**************************************************************************************\n\t// noinspection FunctionNamingConventionJS\n\t/**\n  * Get nearest to input length power of 2\n  * @param {number} length Current length of existing array\n  * @returns {number}\n  */\n\tfunction nearestPowerOf2(length) {\n\t\tvar base = Math.log(length) / log2;\n\n\t\tvar floor = Math.floor(base);\n\t\tvar round = Math.round(base);\n\n\t\t// noinspection ConditionalExpressionJS\n\t\treturn floor === round ? floor : round;\n\t}\n\t//**************************************************************************************\n\t/**\n  * Delete properties by name from specified object\n  * @param {Object} object Object to delete properties from\n  * @param {Array.<string>} propsArray Array of properties names\n  */\n\tfunction clearProps(object, propsArray) {\n\t\tvar _iteratorNormalCompletion7 = true;\n\t\tvar _didIteratorError7 = false;\n\t\tvar _iteratorError7 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator7 = propsArray[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t\t\t\tvar prop = _step7.value;\n\n\t\t\t\tdelete object[prop];\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError7 = true;\n\t\t\t_iteratorError7 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t\t\t\t\t_iterator7.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError7) {\n\t\t\t\t\tthrow _iteratorError7;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//**************************************************************************************\n\n\t/* eslint-disable indent */\n\t//**************************************************************************************\n\t//region Declaration of global variables\n\t//**************************************************************************************\n\tvar powers2 = [new Uint8Array([1])];\n\tvar digitsString = \"0123456789\";\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration for \"LocalBaseBlock\" class\n\t//**************************************************************************************\n\t/**\n  * Class used as a base block for all remaining ASN.1 classes\n  * @typedef LocalBaseBlock\n  * @interface\n  * @property {number} blockLength\n  * @property {string} error\n  * @property {Array.<string>} warnings\n  * @property {ArrayBuffer} valueBeforeDecode\n  */\n\tclass LocalBaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t/**\n    * @type {number} blockLength\n    */\n\t\t\tthis.blockLength = getParametersValue(parameters, \"blockLength\", 0);\n\t\t\t/**\n    * @type {string} error\n    */\n\t\t\tthis.error = getParametersValue(parameters, \"error\", \"\");\n\t\t\t/**\n    * @type {Array.<string>} warnings\n    */\n\t\t\tthis.warnings = getParametersValue(parameters, \"warnings\", []);\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\t/**\n    * @type {ArrayBuffer} valueBeforeDecode\n    */\n\t\t\tif (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"baseBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tblockName: this.constructor.blockName(),\n\t\t\t\tblockLength: this.blockLength,\n\t\t\t\terror: this.error,\n\t\t\t\twarnings: this.warnings,\n\t\t\t\tvalueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Description for \"LocalHexBlock\" class\n\t//**************************************************************************************\n\t/**\n  * Class used as a base block for all remaining ASN.1 classes\n  * @extends LocalBaseBlock\n  * @typedef LocalHexBlock\n  * @property {number} blockLength\n  * @property {string} error\n  * @property {Array.<string>} warnings\n  * @property {ArrayBuffer} valueBeforeDecode\n  * @property {boolean} isHexOnly\n  * @property {ArrayBuffer} valueHex\n  */\n\t//noinspection JSUnusedLocalSymbols\n\tvar LocalHexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Constructor for \"LocalHexBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\t/**\n    * @type {boolean}\n    */\n\t\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\t\t\t/**\n    * @type {ArrayBuffer}\n    */\n\t\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"hexBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\t//region Initial checks\n\t\t\tif (intBuffer.length === 0) {\n\t\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\t\treturn inputOffset;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Copy input buffer to internal buffer\n\t\t\tthis.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t\t//endregion\n\n\t\t\tthis.blockLength = inputLength;\n\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tif (this.isHexOnly !== true) {\n\t\t\t\tthis.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t}\n\n\t\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\treturn this.valueHex.slice(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.blockName = this.constructor.blockName();\n\t\t\tobject.isHexOnly = this.isHexOnly;\n\t\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t};\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of identification block class\n\t//**************************************************************************************\n\tclass LocalIdentificationBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [idBlock]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper();\n\n\t\t\tif (\"idBlock\" in parameters) {\n\t\t\t\t//region Properties from hexBlock class\n\t\t\t\tthis.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\n\t\t\t\tthis.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0));\n\t\t\t\t//endregion\n\n\t\t\t\tthis.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", -1);\n\t\t\t\tthis.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", -1);\n\t\t\t\tthis.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\n\t\t\t} else {\n\t\t\t\tthis.tagClass = -1;\n\t\t\t\tthis.tagNumber = -1;\n\t\t\t\tthis.isConstructed = false;\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"identificationBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//region Initial variables\n\t\t\tvar firstOctet = 0;\n\t\t\tvar retBuf = void 0;\n\t\t\tvar retView = void 0;\n\t\t\t//endregion\n\n\t\t\tswitch (this.tagClass) {\n\t\t\t\tcase 1:\n\t\t\t\t\tfirstOctet |= 0x00; // UNIVERSAL\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfirstOctet |= 0x40; // APPLICATION\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tfirstOctet |= 0x80; // CONTEXT-SPECIFIC\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tfirstOctet |= 0xC0; // PRIVATE\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t}\n\n\t\t\tif (this.isConstructed) firstOctet |= 0x20;\n\n\t\t\tif (this.tagNumber < 31 && !this.isHexOnly) {\n\t\t\t\tretBuf = new ArrayBuffer(1);\n\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\tif (!sizeOnly) {\n\t\t\t\t\tvar number = this.tagNumber;\n\t\t\t\t\tnumber &= 0x1F;\n\t\t\t\t\tfirstOctet |= number;\n\n\t\t\t\t\tretView[0] = firstOctet;\n\t\t\t\t}\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tif (this.isHexOnly === false) {\n\t\t\t\tvar encodedBuf = utilToBase(this.tagNumber, 7);\n\t\t\t\tvar encodedView = new Uint8Array(encodedBuf);\n\t\t\t\tvar size = encodedBuf.byteLength;\n\n\t\t\t\tretBuf = new ArrayBuffer(size + 1);\n\t\t\t\tretView = new Uint8Array(retBuf);\n\t\t\t\tretView[0] = firstOctet | 0x1F;\n\n\t\t\t\tif (!sizeOnly) {\n\t\t\t\t\tfor (var i = 0; i < size - 1; i++) {\n\t\t\t\t\t\tretView[i + 1] = encodedView[i] | 0x80;\n\t\t\t\t\t}retView[size] = encodedView[size - 1];\n\t\t\t\t}\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = firstOctet | 0x1F;\n\n\t\t\tif (sizeOnly === false) {\n\t\t\t\tvar curView = new Uint8Array(this.valueHex);\n\n\t\t\t\tfor (var _i4 = 0; _i4 < curView.length - 1; _i4++) {\n\t\t\t\t\tretView[_i4 + 1] = curView[_i4] | 0x80;\n\t\t\t\t}retView[this.valueHex.byteLength] = curView[curView.length - 1];\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\t//region Initial checks\n\t\t\tif (intBuffer.length === 0) {\n\t\t\t\tthis.error = \"Zero buffer length\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find tag class\n\t\t\tvar tagClassMask = intBuffer[0] & 0xC0;\n\n\t\t\tswitch (tagClassMask) {\n\t\t\t\tcase 0x00:\n\t\t\t\t\tthis.tagClass = 1; // UNIVERSAL\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x40:\n\t\t\t\t\tthis.tagClass = 2; // APPLICATION\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\n\t\t\t\t\tthis.tagClass = 3; // CONTEXT-SPECIFIC\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xC0:\n\t\t\t\t\tthis.tagClass = 4; // PRIVATE\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find it's constructed or not\n\t\t\tthis.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n\t\t\t//endregion\n\n\t\t\t//region Find tag number\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tvar tagNumberMask = intBuffer[0] & 0x1F;\n\n\t\t\t//region Simple case (tag number < 31)\n\t\t\tif (tagNumberMask !== 0x1F) {\n\t\t\t\tthis.tagNumber = tagNumberMask;\n\t\t\t\tthis.blockLength = 1;\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Tag number bigger or equal to 31\n\t\t\telse {\n\t\t\t\t\tvar count = 1;\n\n\t\t\t\t\tthis.valueHex = new ArrayBuffer(255);\n\t\t\t\t\tvar tagNumberBufferMaxLength = 255;\n\t\t\t\t\tvar intTagNumberBuffer = new Uint8Array(this.valueHex);\n\n\t\t\t\t\t//noinspection JSBitwiseOperatorUsage\n\t\t\t\t\twhile (intBuffer[count] & 0x80) {\n\t\t\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\tif (count >= intBuffer.length) {\n\t\t\t\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//region In case if tag number length is greater than 255 bytes (rare but possible case)\n\t\t\t\t\t\tif (count === tagNumberBufferMaxLength) {\n\t\t\t\t\t\t\ttagNumberBufferMaxLength += 255;\n\n\t\t\t\t\t\t\tvar _tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\t\t\tvar _tempBufferView = new Uint8Array(_tempBuffer);\n\n\t\t\t\t\t\t\tfor (var i = 0; i < intTagNumberBuffer.length; i++) {\n\t\t\t\t\t\t\t\t_tempBufferView[i] = intTagNumberBuffer[i];\n\t\t\t\t\t\t\t}this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//endregion\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.blockLength = count + 1;\n\t\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n\n\t\t\t\t\t//region Cut buffer\n\t\t\t\t\tvar tempBuffer = new ArrayBuffer(count);\n\t\t\t\t\tvar tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\t\t\tfor (var _i5 = 0; _i5 < count; _i5++) {\n\t\t\t\t\t\ttempBufferView[_i5] = intTagNumberBuffer[_i5];\n\t\t\t\t\t}this.valueHex = new ArrayBuffer(count);\n\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\t\tintTagNumberBuffer.set(tempBufferView);\n\t\t\t\t\t//endregion\n\n\t\t\t\t\t//region Try to convert long tag number to short form\n\t\t\t\t\tif (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);else {\n\t\t\t\t\t\tthis.isHexOnly = true;\n\t\t\t\t\t\tthis.warnings.push(\"Tag too long, represented as hex-coded\");\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t}\n\t\t\t//endregion\n\t\t\t//endregion\n\n\t\t\t//region Check if constructed encoding was using for primitive type\n\t\t\tif (this.tagClass === 1 && this.isConstructed) {\n\t\t\t\tswitch (this.tagNumber) {\n\t\t\t\t\tcase 1: // Boolean\n\t\t\t\t\tcase 2: // REAL\n\t\t\t\t\tcase 5: // Null\n\t\t\t\t\tcase 6: // OBJECT IDENTIFIER\n\t\t\t\t\tcase 9: // REAL\n\t\t\t\t\tcase 14: // Time\n\t\t\t\t\tcase 23:\n\t\t\t\t\tcase 24:\n\t\t\t\t\tcase 31:\n\t\t\t\t\tcase 32:\n\t\t\t\t\tcase 33:\n\t\t\t\t\tcase 34:\n\t\t\t\t\t\tthis.error = \"Constructed encoding used for primitive type\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn inputOffset + this.blockLength; // Return current offset in input buffer\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName: string,\n   *  tagClass: number,\n   *  tagNumber: number,\n   *  isConstructed: boolean,\n   *  isHexOnly: boolean,\n   *  valueHex: ArrayBuffer,\n   *  blockLength: number,\n   *  error: string, warnings: Array.<string>,\n   *  valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.blockName = this.constructor.blockName();\n\t\t\tobject.tagClass = this.tagClass;\n\t\t\tobject.tagNumber = this.tagNumber;\n\t\t\tobject.isConstructed = this.isConstructed;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of length block class\n\t//**************************************************************************************\n\tclass LocalLengthBlock extends LocalBaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalLengthBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [lenBlock]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper();\n\n\t\t\tif (\"lenBlock\" in parameters) {\n\t\t\t\tthis.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\n\t\t\t\tthis.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\n\t\t\t\tthis.length = getParametersValue(parameters.lenBlock, \"length\", 0);\n\t\t\t} else {\n\t\t\t\tthis.isIndefiniteForm = false;\n\t\t\t\tthis.longFormUsed = false;\n\t\t\t\tthis.length = 0;\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"lengthBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\t//region Initial checks\n\t\t\tif (intBuffer.length === 0) {\n\t\t\t\tthis.error = \"Zero buffer length\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (intBuffer[0] === 0xFF) {\n\t\t\t\tthis.error = \"Length block 0xFF is reserved by standard\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Check for length form type\n\t\t\tthis.isIndefiniteForm = intBuffer[0] === 0x80;\n\t\t\t//endregion\n\n\t\t\t//region Stop working in case of indefinite length form\n\t\t\tif (this.isIndefiniteForm === true) {\n\t\t\t\tthis.blockLength = 1;\n\t\t\t\treturn inputOffset + this.blockLength;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Check is long form of length encoding using\n\t\t\tthis.longFormUsed = !!(intBuffer[0] & 0x80);\n\t\t\t//endregion\n\n\t\t\t//region Stop working in case of short form of length value\n\t\t\tif (this.longFormUsed === false) {\n\t\t\t\tthis.length = intBuffer[0];\n\t\t\t\tthis.blockLength = 1;\n\t\t\t\treturn inputOffset + this.blockLength;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Calculate length value in case of long form\n\t\t\tvar count = intBuffer[0] & 0x7F;\n\n\t\t\tif (count > 8) // Too big length value\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"Too big integer\";\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\tif (count + 1 > intBuffer.length) {\n\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tvar lengthBufferView = new Uint8Array(count);\n\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tlengthBufferView[i] = intBuffer[i + 1];\n\t\t\t}if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n\n\t\t\tthis.length = utilFromBase(lengthBufferView, 8);\n\n\t\t\tif (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unneccesary usage of long length form\");\n\n\t\t\tthis.blockLength = count + 1;\n\t\t\t//endregion\n\n\t\t\treturn inputOffset + this.blockLength; // Return current offset in input buffer\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//region Initial variables\n\t\t\tvar retBuf = void 0;\n\t\t\tvar retView = void 0;\n\t\t\t//endregion\n\n\t\t\tif (this.length > 127) this.longFormUsed = true;\n\n\t\t\tif (this.isIndefiniteForm) {\n\t\t\t\tretBuf = new ArrayBuffer(1);\n\n\t\t\t\tif (sizeOnly === false) {\n\t\t\t\t\tretView = new Uint8Array(retBuf);\n\t\t\t\t\tretView[0] = 0x80;\n\t\t\t\t}\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tif (this.longFormUsed === true) {\n\t\t\t\tvar encodedBuf = utilToBase(this.length, 8);\n\n\t\t\t\tif (encodedBuf.byteLength > 127) {\n\t\t\t\t\tthis.error = \"Too big length\";\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\t}\n\n\t\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n\n\t\t\t\tif (sizeOnly === true) return retBuf;\n\n\t\t\t\tvar encodedView = new Uint8Array(encodedBuf);\n\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\tretView[0] = encodedBuf.byteLength | 0x80;\n\n\t\t\t\tfor (var i = 0; i < encodedBuf.byteLength; i++) {\n\t\t\t\t\tretView[i + 1] = encodedView[i];\n\t\t\t\t}return retBuf;\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(1);\n\n\t\t\tif (sizeOnly === false) {\n\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\tretView[0] = this.length;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.blockName = this.constructor.blockName();\n\t\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\t\tobject.longFormUsed = this.longFormUsed;\n\t\t\tobject.length = this.length;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of value block class\n\t//**************************************************************************************\n\tclass LocalValueBlock extends LocalBaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"valueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"LocalValueBlock\\\"\");\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"LocalValueBlock\\\"\");\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of basic ASN.1 block class\n\t//**************************************************************************************\n\tclass BaseBlock extends LocalBaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"BaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [primitiveSchema]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   * @param valueBlockType Type of value block\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\tvar valueBlockType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LocalValueBlock;\n\n\t\t\tsuper(parameters);\n\n\t\t\tif (\"name\" in parameters) this.name = parameters.name;\n\t\t\tif (\"optional\" in parameters) this.optional = parameters.optional;\n\t\t\tif (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n\n\t\t\tthis.idBlock = new LocalIdentificationBlock(parameters);\n\t\t\tthis.lenBlock = new LocalLengthBlock(parameters);\n\t\t\tthis.valueBlock = new valueBlockType(parameters);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BaseBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tvar retBuf = void 0;\n\n\t\t\tvar idBlockBuf = this.idBlock.toBER(sizeOnly);\n\t\t\tvar valueBlockSizeBuf = this.valueBlock.toBER(true);\n\n\t\t\tthis.lenBlock.length = valueBlockSizeBuf.byteLength;\n\t\t\tvar lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n\n\t\t\tretBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\n\n\t\t\tvar valueBlockBuf = void 0;\n\n\t\t\tif (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBlockBuf);\n\n\t\t\tif (this.lenBlock.isIndefiniteForm === true) {\n\t\t\t\tvar indefBuf = new ArrayBuffer(2);\n\n\t\t\t\tif (sizeOnly === false) {\n\t\t\t\t\tvar indefView = new Uint8Array(indefBuf);\n\n\t\t\t\t\tindefView[0] = 0x00;\n\t\t\t\t\tindefView[1] = 0x00;\n\t\t\t\t}\n\n\t\t\t\tretBuf = utilConcatBuf(retBuf, indefBuf);\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.idBlock = this.idBlock.toJSON();\n\t\t\tobject.lenBlock = this.lenBlock.toJSON();\n\t\t\tobject.valueBlock = this.valueBlock.toJSON();\n\n\t\t\tif (\"name\" in this) object.name = this.name;\n\t\t\tif (\"optional\" in this) object.optional = this.optional;\n\t\t\tif (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of basic block for all PRIMITIVE types\n\t//**************************************************************************************\n\tclass LocalPrimitiveValueBlock extends LocalValueBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalPrimitiveValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\t//region Variables from \"hexBlock\" class\n\t\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n\n\t\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\t//region Initial checks\n\t\t\tif (intBuffer.length === 0) {\n\t\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\t\treturn inputOffset;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Copy input buffer into internal buffer\n\t\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\t\tvar valueHexView = new Uint8Array(this.valueHex);\n\n\t\t\tfor (var i = 0; i < intBuffer.length; i++) {\n\t\t\t\tvalueHexView[i] = intBuffer[i];\n\t\t\t} //endregion\n\n\t\t\tthis.blockLength = inputLength;\n\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\treturn this.valueHex.slice(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"PrimitiveValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\t\tobject.isHexOnly = this.isHexOnly;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass Primitive extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Primitive\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalPrimitiveValueBlock);\n\n\t\t\tthis.idBlock.isConstructed = false;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"PRIMITIVE\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of basic block for all CONSTRUCTED types\n\t//**************************************************************************************\n\tclass LocalConstructedValueBlock extends LocalValueBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalConstructedValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\t\tthis.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Store initial offset and length\n\t\t\tvar initialOffset = inputOffset;\n\t\t\tvar initialLength = inputLength;\n\t\t\t//endregion\n\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\t//region Initial checks\n\t\t\tif (intBuffer.length === 0) {\n\t\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\t\treturn inputOffset;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Aux function\n\t\t\tfunction checkLen(indefiniteLength, length) {\n\t\t\t\tif (indefiniteLength === true) return 1;\n\n\t\t\t\treturn length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tvar currentOffset = inputOffset;\n\n\t\t\twhile (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n\t\t\t\tvar returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\t\t\t\tif (returnObject.offset === -1) {\n\t\t\t\t\tthis.error = returnObject.result.error;\n\t\t\t\t\tthis.warnings.concat(returnObject.result.warnings);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tcurrentOffset = returnObject.offset;\n\n\t\t\t\tthis.blockLength += returnObject.result.blockLength;\n\t\t\t\tinputLength -= returnObject.result.blockLength;\n\n\t\t\t\tthis.value.push(returnObject.result);\n\n\t\t\t\tif (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n\t\t\t}\n\n\t\t\tif (this.isIndefiniteForm === true) {\n\t\t\t\tif (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n\t\t\t}\n\n\t\t\t//region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\t\t\tthis.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);\n\t\t\t//endregion\n\n\t\t\treturn currentOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tvar retBuf = new ArrayBuffer(0);\n\n\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\tvar valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"ConstructedValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\t\tobject.value = [];\n\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\tobject.value.push(this.value[i].toJSON());\n\t\t\t}return object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass Constructed extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Constructed\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalConstructedValueBlock);\n\n\t\t\tthis.idBlock.isConstructed = true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"CONSTRUCTED\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 EndOfContent type class\n\t//**************************************************************************************\n\tclass LocalEndOfContentValueBlock extends LocalValueBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalEndOfContentValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region There is no \"value block\" for EndOfContent type and we need to return the same offset\n\t\t\treturn inputOffset;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"EndOfContentValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass EndOfContent extends BaseBlock {\n\t\t//**********************************************************************************\n\t\tconstructor() {\n\t\t\tvar paramaters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(paramaters, LocalEndOfContentValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 0; // EndOfContent\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"EndOfContent\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 Boolean type class\n\t//**************************************************************************************\n\tclass LocalBooleanValueBlock extends LocalValueBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalBooleanValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.value = getParametersValue(parameters, \"value\", false);\n\t\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\n\t\t\tif (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n\t\t\t\tthis.valueHex = new ArrayBuffer(1);\n\t\t\t\tif (this.value === true) {\n\t\t\t\t\tvar view = new Uint8Array(this.valueHex);\n\t\t\t\t\tview[0] = 0xFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Getting Uint8Array from ArrayBuffer\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t\t//endregion\n\n\t\t\tif (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n\n\t\t\tthis.isHexOnly = true;\n\n\t\t\t//region Copy input buffer to internal array\n\t\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\t\tvar view = new Uint8Array(this.valueHex);\n\n\t\t\tfor (var i = 0; i < intBuffer.length; i++) {\n\t\t\t\tview[i] = intBuffer[i];\n\t\t\t} //endregion\n\n\t\t\tif (utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n\n\t\t\tthis.blockLength = inputLength;\n\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\treturn this.valueHex;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BooleanValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.value;\n\t\t\tobject.isHexOnly = this.isHexOnly;\n\t\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass Boolean extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Boolean\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalBooleanValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 1; // Boolean\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Boolean\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 Sequence and Set type classes\n\t//**************************************************************************************\n\tclass Sequence extends Constructed {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Sequence\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 16; // Sequence\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Sequence\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass Set extends Constructed {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Set\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 17; // Set\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Set\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 Null type class\n\t//**************************************************************************************\n\tclass Null extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Null\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 5; // Null\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Null\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedLocalSymbols\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tif (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tthis.blockLength += inputLength;\n\n\t\t\tif (inputOffset + inputLength > inputBuffer.byteLength) {\n\t\t\t\tthis.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tvar retBuf = new ArrayBuffer(2);\n\n\t\t\tif (sizeOnly === true) return retBuf;\n\n\t\t\tvar retView = new Uint8Array(retBuf);\n\t\t\tretView[0] = 0x05;\n\t\t\tretView[1] = 0x00;\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 OctetString type class\n\t//**************************************************************************************\n\tclass LocalOctetStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalOctetStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = 0;\n\n\t\t\tif (this.isConstructed === true) {\n\t\t\t\tthis.isHexOnly = false;\n\n\t\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\t\tif (resultOffset === -1) return resultOffset;\n\n\t\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\t\tvar currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\t\tif (currentBlockName === EndOfContent.blockName()) {\n\t\t\t\t\t\tif (this.isIndefiniteForm === true) break;else {\n\t\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentBlockName !== OctetString.blockName()) {\n\t\t\t\t\t\tthis.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.isHexOnly = true;\n\n\t\t\t\tresultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\t\tthis.blockLength = inputLength;\n\t\t\t}\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tif (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\t\tvar retBuf = new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t\tif (sizeOnly === true) return retBuf;\n\n\t\t\tif (this.valueHex.byteLength === 0) return retBuf;\n\n\t\t\tretBuf = this.valueHex.slice(0);\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"OctetStringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.isConstructed = this.isConstructed;\n\t\t\tobject.isHexOnly = this.isHexOnly;\n\t\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass OctetString extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"OctetString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalOctetStringValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 4; // OctetString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t\t//region Ability to encode empty OCTET STRING\n\t\t\tif (inputLength === 0) {\n\t\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\t\treturn inputOffset;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"OctetString\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Checking that two OCTETSTRINGs are equal\n   * @param {OctetString} octetString\n   */\n\t\tisEqual(octetString) {\n\t\t\t//region Check input type\n\t\t\tif (octetString instanceof OctetString === false) return false;\n\t\t\t//endregion\n\n\t\t\t//region Compare two JSON strings\n\t\t\tif (JSON.stringify(this) !== JSON.stringify(octetString)) return false;\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 BitString type class\n\t//**************************************************************************************\n\tclass LocalBitStringValueBlock extends LocalHexBlock(LocalConstructedValueBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalBitStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\n\t\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t\t\tthis.blockLength = this.valueHex.byteLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Ability to decode zero-length BitString value\n\t\t\tif (inputLength === 0) return inputOffset;\n\t\t\t//endregion\n\n\t\t\tvar resultOffset = -1;\n\n\t\t\t//region If the BISTRING supposed to be a constructed value\n\t\t\tif (this.isConstructed === true) {\n\t\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\t\tif (resultOffset === -1) return resultOffset;\n\n\t\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\t\tvar currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\t\tif (currentBlockName === EndOfContent.blockName()) {\n\t\t\t\t\t\tif (this.isIndefiniteForm === true) break;else {\n\t\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentBlockName !== BitString.blockName()) {\n\t\t\t\t\t\tthis.error = \"BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n\t\t\t\t\t\tthis.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.unusedBits = this.value[i].valueBlock.unusedBits;\n\t\t\t\t\tif (this.unusedBits > 7) {\n\t\t\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region If the BitString supposed to be a primitive value\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\t\tthis.unusedBits = intBuffer[0];\n\n\t\t\tif (this.unusedBits > 7) {\n\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t//region Copy input buffer to internal buffer\n\t\t\tthis.valueHex = new ArrayBuffer(intBuffer.length - 1);\n\t\t\tvar view = new Uint8Array(this.valueHex);\n\t\t\tfor (var _i6 = 0; _i6 < inputLength - 1; _i6++) {\n\t\t\t\tview[_i6] = intBuffer[_i6 + 1];\n\t\t\t} //endregion\n\n\t\t\tthis.blockLength = intBuffer.length;\n\n\t\t\treturn inputOffset + inputLength;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tif (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n\n\t\t\tif (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n\n\t\t\tvar curView = new Uint8Array(this.valueHex);\n\n\t\t\tvar retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\t\tvar retView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = this.unusedBits;\n\n\t\t\tfor (var i = 0; i < this.valueHex.byteLength; i++) {\n\t\t\t\tretView[i + 1] = curView[i];\n\t\t\t}return retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BitStringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.unusedBits = this.unusedBits;\n\t\t\tobject.isConstructed = this.isConstructed;\n\t\t\tobject.isHexOnly = this.isHexOnly;\n\t\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass BitString extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"BitString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalBitStringValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 3; // BitString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BitString\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\t//region Ability to encode empty BitString\n\t\t\tif (inputLength === 0) return inputOffset;\n\t\t\t//endregion\n\n\t\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Checking that two BITSTRINGs are equal\n   * @param {BitString} bitString\n   */\n\t\tisEqual(bitString) {\n\t\t\t//region Check input type\n\t\t\tif (bitString instanceof BitString === false) return false;\n\t\t\t//endregion\n\n\t\t\t//region Compare two JSON strings\n\t\t\tif (JSON.stringify(this) !== JSON.stringify(bitString)) return false;\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 Integer type class\n\t//**************************************************************************************\n\t/**\n  * @extends LocalValueBlock\n  */\n\tclass LocalIntegerValueBlock extends LocalHexBlock(LocalValueBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalIntegerValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tif (\"value\" in parameters) this.valueDec = parameters.value;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"valueHex\"\n   * @param {ArrayBuffer} _value\n   */\n\t\tset valueHex(_value) {\n\t\t\tthis._valueHex = _value.slice(0);\n\n\t\t\tif (_value.byteLength >= 4) {\n\t\t\t\tthis.warnings.push(\"Too big Integer for decoding, hex only\");\n\t\t\t\tthis.isHexOnly = true;\n\t\t\t\tthis._valueDec = 0;\n\t\t\t} else {\n\t\t\t\tthis.isHexOnly = false;\n\n\t\t\t\tif (_value.byteLength > 0) this._valueDec = utilDecodeTC.call(this);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"valueHex\"\n   * @returns {ArrayBuffer}\n   */\n\t\tget valueHex() {\n\t\t\treturn this._valueHex;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"valueDec\"\n   * @param {number} _value\n   */\n\t\tset valueDec(_value) {\n\t\t\tthis._valueDec = _value;\n\n\t\t\tthis.isHexOnly = false;\n\t\t\tthis._valueHex = utilEncodeTC(_value);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"valueDec\"\n   * @returns {number}\n   */\n\t\tget valueDec() {\n\t\t\treturn this._valueDec;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from DER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromDER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar expectedLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n\t\t\tvar offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\tif (offset === -1) return offset;\n\n\t\t\tvar view = new Uint8Array(this._valueHex);\n\n\t\t\tif (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n\t\t\t\tvar updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\t\tvar updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t} else {\n\t\t\t\tif (expectedLength !== 0) {\n\t\t\t\t\tif (this._valueHex.byteLength < expectedLength) {\n\t\t\t\t\t\tif (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n\n\t\t\t\t\t\tvar _updatedValueHex = new ArrayBuffer(expectedLength);\n\t\t\t\t\t\tvar _updatedView = new Uint8Array(_updatedValueHex);\n\n\t\t\t\t\t\t_updatedView.set(view, expectedLength - this._valueHex.byteLength);\n\n\t\t\t\t\t\tthis._valueHex = _updatedValueHex.slice(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn offset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoDER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tvar view = new Uint8Array(this._valueHex);\n\n\t\t\tswitch (true) {\n\t\t\t\tcase (view[0] & 0x80) !== 0:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n\t\t\t\t\t\tvar updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\t\tupdatedView[0] = 0x00;\n\t\t\t\t\t\tupdatedView.set(view, 1);\n\n\t\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase view[0] === 0x00 && (view[1] & 0x80) === 0:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _updatedValueHex2 = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\t\t\t\tvar _updatedView2 = new Uint8Array(_updatedValueHex2);\n\n\t\t\t\t\t\t_updatedView2.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\t\t\t\tthis._valueHex = _updatedValueHex2.slice(0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn this.toBER(sizeOnly);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\tif (resultOffset === -1) return resultOffset;\n\n\t\t\tthis.blockLength = inputLength;\n\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\treturn this.valueHex.slice(0);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"IntegerValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.valueDec = this.valueDec;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current value to decimal string representation\n   */\n\t\ttoString() {\n\t\t\t//region Aux functions\n\t\t\tfunction viewAdd(first, second) {\n\t\t\t\t//region Initial variables\n\t\t\t\tvar c = new Uint8Array([0]);\n\n\t\t\t\tvar firstView = new Uint8Array(first);\n\t\t\t\tvar secondView = new Uint8Array(second);\n\n\t\t\t\tvar firstViewCopy = firstView.slice(0);\n\t\t\t\tvar firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\t\tvar secondViewCopy = secondView.slice(0);\n\t\t\t\tvar secondViewCopyLength = secondViewCopy.length - 1;\n\n\t\t\t\tvar value = 0;\n\n\t\t\t\tvar max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n\n\t\t\t\tvar counter = 0;\n\t\t\t\t//endregion\n\n\t\t\t\tfor (var i = max; i >= 0; i--, counter++) {\n\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\tcase counter < secondViewCopy.length:\n\t\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + c[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tc[0] = value / 10;\n\n\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\tcase counter >= firstViewCopy.length:\n\t\t\t\t\t\t\tfirstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value % 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);\n\n\t\t\t\treturn firstViewCopy.slice(0);\n\t\t\t}\n\n\t\t\tfunction power2(n) {\n\t\t\t\tif (n >= powers2.length) {\n\t\t\t\t\tfor (var p = powers2.length; p <= n; p++) {\n\t\t\t\t\t\tvar c = new Uint8Array([0]);\n\t\t\t\t\t\tvar _digits = powers2[p - 1].slice(0);\n\n\t\t\t\t\t\tfor (var i = _digits.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tvar newValue = new Uint8Array([(_digits[i] << 1) + c[0]]);\n\t\t\t\t\t\t\tc[0] = newValue[0] / 10;\n\t\t\t\t\t\t\t_digits[i] = newValue[0] % 10;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (c[0] > 0) _digits = utilConcatView(c, _digits);\n\n\t\t\t\t\t\tpowers2.push(_digits);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn powers2[n];\n\t\t\t}\n\n\t\t\tfunction viewSub(first, second) {\n\t\t\t\t//region Initial variables\n\t\t\t\tvar b = 0;\n\n\t\t\t\tvar firstView = new Uint8Array(first);\n\t\t\t\tvar secondView = new Uint8Array(second);\n\n\t\t\t\tvar firstViewCopy = firstView.slice(0);\n\t\t\t\tvar firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\t\tvar secondViewCopy = secondView.slice(0);\n\t\t\t\tvar secondViewCopyLength = secondViewCopy.length - 1;\n\n\t\t\t\tvar value = void 0;\n\n\t\t\t\tvar counter = 0;\n\t\t\t\t//endregion\n\n\t\t\t\tfor (var i = secondViewCopyLength; i >= 0; i--, counter++) {\n\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\tcase value < 0:\n\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (b > 0) {\n\t\t\t\t\tfor (var _i7 = firstViewCopyLength - secondViewCopyLength + 1; _i7 >= 0; _i7--, counter++) {\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - b;\n\n\t\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn firstViewCopy.slice();\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar firstBit = this._valueHex.byteLength * 8 - 1;\n\n\t\t\tvar digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n\t\t\tvar bitNumber = 0;\n\t\t\tvar currentByte = void 0;\n\n\t\t\tvar asn1View = new Uint8Array(this._valueHex);\n\n\t\t\tvar result = \"\";\n\n\t\t\tvar flag = false;\n\t\t\t//endregion\n\n\t\t\t//region Calculate number\n\t\t\tfor (var byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n\t\t\t\tcurrentByte = asn1View[byteNumber];\n\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tif ((currentByte & 1) === 1) {\n\t\t\t\t\t\tswitch (bitNumber) {\n\t\t\t\t\t\t\tcase firstBit:\n\t\t\t\t\t\t\t\tdigits = viewSub(power2(bitNumber), digits);\n\t\t\t\t\t\t\t\tresult = \"-\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdigits = viewAdd(digits, power2(bitNumber));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbitNumber++;\n\t\t\t\t\tcurrentByte >>= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Print number\n\t\t\tfor (var _i8 = 0; _i8 < digits.length; _i8++) {\n\t\t\t\tif (digits[_i8]) flag = true;\n\n\t\t\t\tif (flag) result += digitsString.charAt(digits[_i8]);\n\t\t\t}\n\n\t\t\tif (flag === false) result += digitsString.charAt(0);\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass Integer extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Integer\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalIntegerValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 2; // Integer\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Integer\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Compare two Integer object, or Integer and ArrayBuffer objects\n   * @param {!Integer|ArrayBuffer} otherValue\n   * @returns {boolean}\n   */\n\t\tisEqual(otherValue) {\n\t\t\tif (otherValue instanceof Integer) {\n\t\t\t\tif (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n\t\t\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n\n\t\t\t\tif (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (otherValue instanceof ArrayBuffer) return isEqualBuffer(this.valueBlock.valueHex, otherValue);\n\n\t\t\treturn false;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current Integer value from BER into DER format\n   * @returns {Integer}\n   */\n\t\tconvertToDER() {\n\t\t\tvar integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\t\tinteger.valueBlock.toDER();\n\n\t\t\treturn integer;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current Integer value from DER to BER format\n   * @returns {Integer}\n   */\n\t\tconvertFromDER() {\n\t\t\tvar expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n\t\t\tvar integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\t\tinteger.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n\n\t\t\treturn integer;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 Enumerated type class\n\t//**************************************************************************************\n\tclass Enumerated extends Integer {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Enumerated\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 10; // Enumerated\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Enumerated\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of ASN.1 ObjectIdentifier type class\n\t//**************************************************************************************\n\tclass LocalSidValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalSidValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {number} [valueDec]\n   * @property {boolean} [isFirstSid]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n\t\t\tthis.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"sidBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tif (inputLength === 0) return inputOffset;\n\n\t\t\t//region Basic check for parameters\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1;\n\t\t\t//endregion\n\n\t\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\t\tvar view = new Uint8Array(this.valueHex);\n\n\t\t\tfor (var i = 0; i < inputLength; i++) {\n\t\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\t\tthis.blockLength++;\n\n\t\t\t\tif ((intBuffer[i] & 0x80) === 0x00) break;\n\t\t\t}\n\n\t\t\t//region Ajust size of valueHex buffer\n\t\t\tvar tempValueHex = new ArrayBuffer(this.blockLength);\n\t\t\tvar tempView = new Uint8Array(tempValueHex);\n\n\t\t\tfor (var _i9 = 0; _i9 < this.blockLength; _i9++) {\n\t\t\t\ttempView[_i9] = view[_i9];\n\t\t\t} //noinspection JSCheckFunctionSignatures\n\t\t\tthis.valueHex = tempValueHex.slice(0);\n\t\t\tview = new Uint8Array(this.valueHex);\n\t\t\t//endregion\n\n\t\t\tif ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\t\tif (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {\n\t\t\t\tthis.isHexOnly = true;\n\t\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t\t}\n\n\t\t\treturn inputOffset + this.blockLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//region Initial variables\n\t\t\tvar retBuf = void 0;\n\t\t\tvar retView = void 0;\n\t\t\t//endregion\n\n\t\t\tif (this.isHexOnly) {\n\t\t\t\tif (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t\t\tvar curView = new Uint8Array(this.valueHex);\n\n\t\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\tfor (var i = 0; i < this.blockLength - 1; i++) {\n\t\t\t\t\tretView[i] = curView[i] | 0x80;\n\t\t\t\t}retView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\t\treturn retBuf;\n\t\t\t}\n\n\t\t\tvar encodedBuf = utilToBase(this.valueDec, 7);\n\t\t\tif (encodedBuf.byteLength === 0) {\n\t\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\t\tif (sizeOnly === false) {\n\t\t\t\tvar encodedView = new Uint8Array(encodedBuf);\n\t\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\t\tfor (var _i10 = 0; _i10 < encodedBuf.byteLength - 1; _i10++) {\n\t\t\t\t\tretView[_i10] = encodedView[_i10] | 0x80;\n\t\t\t\t}retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Create string representation of current SID block\n   * @returns {string}\n   */\n\t\ttoString() {\n\t\t\tvar result = \"\";\n\n\t\t\tif (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {\n\t\t\t\tif (this.isFirstSid) {\n\t\t\t\t\tvar sidValue = this.valueDec;\n\n\t\t\t\t\tif (this.valueDec <= 39) result = \"0.\";else {\n\t\t\t\t\t\tif (this.valueDec <= 79) {\n\t\t\t\t\t\t\tresult = \"1.\";\n\t\t\t\t\t\t\tsidValue -= 40;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = \"2.\";\n\t\t\t\t\t\t\tsidValue -= 80;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += sidValue.toString();\n\t\t\t\t} else result = this.valueDec.toString();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.valueDec = this.valueDec;\n\t\t\tobject.isFirstSid = this.isFirstSid;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass LocalObjectIdentifierValueBlock extends LocalValueBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = inputOffset;\n\n\t\t\twhile (inputLength > 0) {\n\t\t\t\tvar sidBlock = new LocalSidValueBlock();\n\t\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\t\tif (resultOffset === -1) {\n\t\t\t\t\tthis.blockLength = 0;\n\t\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\t\treturn resultOffset;\n\t\t\t\t}\n\n\t\t\t\tif (this.value.length === 0) sidBlock.isFirstSid = true;\n\n\t\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\t\tthis.value.push(sidBlock);\n\t\t\t}\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\tvar retBuf = new ArrayBuffer(0);\n\n\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\tvar valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\t\tif (valueBuf.byteLength === 0) {\n\t\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\t}\n\n\t\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Create \"LocalObjectIdentifierValueBlock\" class from string\n   * @param {string} string Input string to convert from\n   * @returns {boolean}\n   */\n\t\tfromString(string) {\n\t\t\tthis.value = []; // Clear existing SID values\n\n\t\t\tvar pos1 = 0;\n\t\t\tvar pos2 = 0;\n\n\t\t\tvar sid = \"\";\n\n\t\t\tvar flag = false;\n\n\t\t\tdo {\n\t\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\t\tif (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n\n\t\t\t\tpos1 = pos2 + 1;\n\n\t\t\t\tif (flag) {\n\t\t\t\t\tvar sidBlock = this.value[0];\n\n\t\t\t\t\tvar plus = 0;\n\n\t\t\t\t\tswitch (sidBlock.valueDec) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tplus = 40;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tplus = 80;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.value = []; // clear SID array\n\t\t\t\t\t\t\treturn false; // ???\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parsedSID = parseInt(sid, 10);\n\t\t\t\t\tif (isNaN(parsedSID)) return true;\n\n\t\t\t\t\tsidBlock.valueDec = parsedSID + plus;\n\n\t\t\t\t\tflag = false;\n\t\t\t\t} else {\n\t\t\t\t\tvar _sidBlock = new LocalSidValueBlock();\n\t\t\t\t\t_sidBlock.valueDec = parseInt(sid, 10);\n\t\t\t\t\tif (isNaN(_sidBlock.valueDec)) return true;\n\n\t\t\t\t\tif (this.value.length === 0) {\n\t\t\t\t\t\t_sidBlock.isFirstSid = true;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.value.push(_sidBlock);\n\t\t\t\t}\n\t\t\t} while (pos2 !== -1);\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Converts \"LocalObjectIdentifierValueBlock\" class to string\n   * @returns {string}\n   */\n\t\ttoString() {\n\t\t\tvar result = \"\";\n\t\t\tvar isHexOnly = false;\n\n\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\t\tvar sidStr = this.value[i].toString();\n\n\t\t\t\tif (i !== 0) result = `${result}.`;\n\n\t\t\t\tif (isHexOnly) {\n\t\t\t\t\tsidStr = `{${sidStr}}`;\n\n\t\t\t\t\tif (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n\t\t\t\t} else result += sidStr;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"ObjectIdentifierValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.toString();\n\t\t\tobject.sidArray = [];\n\t\t\tfor (var i = 0; i < this.value.length; i++) {\n\t\t\t\tobject.sidArray.push(this.value[i].toJSON());\n\t\t\t}return object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends BaseBlock\n  */\n\tclass ObjectIdentifier extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"ObjectIdentifier\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalObjectIdentifierValueBlock);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"ObjectIdentifier\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of all string's classes\n\t//**************************************************************************************\n\tclass LocalUtf8StringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Constructor for \"LocalUtf8StringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.value = \"\"; // String representation of decoded ArrayBuffer\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Utf8StringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.value;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends BaseBlock\n  */\n\tclass Utf8String extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Utf8String\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalUtf8StringValueBlock);\n\n\t\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 12; // Utf8String\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Utf8String\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n\t\t\ttry {\n\t\t\t\t//noinspection JSDeprecatedSymbols\n\t\t\t\tthis.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n\t\t\t} catch (ex) {\n\t\t\t\tthis.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\t//noinspection JSDeprecatedSymbols\n\t\t\tvar str = unescape(encodeURIComponent(inputString));\n\t\t\tvar strLen = str.length;\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\t\tvar view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (var i = 0; i < strLen; i++) {\n\t\t\t\tview[i] = str.charCodeAt(i);\n\t\t\t}this.valueBlock.value = inputString;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalBaseBlock\n  * @extends LocalHexBlock\n  */\n\tclass LocalBmpStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalBmpStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.value = \"\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BmpStringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.value;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends BaseBlock\n  */\n\tclass BmpString extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"BmpString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalBmpStringValueBlock);\n\n\t\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 30; // BmpString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"BmpString\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tvar copyBuffer = inputBuffer.slice(0);\n\t\t\tvar valueView = new Uint8Array(copyBuffer);\n\n\t\t\tfor (var i = 0; i < valueView.length; i += 2) {\n\t\t\t\tvar temp = valueView[i];\n\n\t\t\t\tvalueView[i] = valueView[i + 1];\n\t\t\t\tvalueView[i + 1] = temp;\n\t\t\t}\n\n\t\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\tvar strLength = inputString.length;\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n\t\t\tvar valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (var i = 0; i < strLength; i++) {\n\t\t\t\tvar codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\t\tvar codeView = new Uint8Array(codeBuf);\n\t\t\t\tif (codeView.length > 2) continue;\n\n\t\t\t\tvar dif = 2 - codeView.length;\n\n\t\t\t\tfor (var j = codeView.length - 1; j >= 0; j--) {\n\t\t\t\t\tvalueHexView[i * 2 + j + dif] = codeView[j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.valueBlock.value = inputString;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass LocalUniversalStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalUniversalStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.value = \"\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"UniversalStringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.value;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends BaseBlock\n  */\n\tclass UniversalString extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"UniversalString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalUniversalStringValueBlock);\n\n\t\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 28; // UniversalString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"UniversalString\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tvar copyBuffer = inputBuffer.slice(0);\n\t\t\tvar valueView = new Uint8Array(copyBuffer);\n\n\t\t\tfor (var i = 0; i < valueView.length; i += 4) {\n\t\t\t\tvalueView[i] = valueView[i + 3];\n\t\t\t\tvalueView[i + 1] = valueView[i + 2];\n\t\t\t\tvalueView[i + 2] = 0x00;\n\t\t\t\tvalueView[i + 3] = 0x00;\n\t\t\t}\n\n\t\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\tvar strLength = inputString.length;\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n\t\t\tvar valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (var i = 0; i < strLength; i++) {\n\t\t\t\tvar codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\t\tvar codeView = new Uint8Array(codeBuf);\n\t\t\t\tif (codeView.length > 4) continue;\n\n\t\t\t\tvar dif = 4 - codeView.length;\n\n\t\t\t\tfor (var j = codeView.length - 1; j >= 0; j--) {\n\t\t\t\t\tvalueHexView[i * 4 + j + dif] = codeView[j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.valueBlock.value = inputString;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass LocalSimpleStringValueBlock extends LocalHexBlock(LocalBaseBlock) {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalSimpleStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.value = \"\";\n\t\t\tthis.isHexOnly = true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"SimpleStringValueBlock\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.value = this.value;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends BaseBlock\n  */\n\tclass LocalSimpleStringBlock extends BaseBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"LocalSimpleStringBlock\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters, LocalSimpleStringValueBlock);\n\n\t\t\tif (\"value\" in parameters) this.fromString(parameters.value);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"SIMPLESTRING\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\tvar strLen = inputString.length;\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\t\tvar view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor (var i = 0; i < strLen; i++) {\n\t\t\t\tview[i] = inputString.charCodeAt(i);\n\t\t\t}this.valueBlock.value = inputString;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass NumericString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"NumericString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 18; // NumericString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"NumericString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass PrintableString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"PrintableString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 19; // PrintableString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"PrintableString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass TeletexString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"TeletexString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 20; // TeletexString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"TeletexString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass VideotexString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"VideotexString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 21; // VideotexString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"VideotexString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass IA5String extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"IA5String\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 22; // IA5String\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"IA5String\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass GraphicString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"GraphicString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 25; // GraphicString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"GraphicString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass VisibleString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"VisibleString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 26; // VisibleString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"VisibleString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass GeneralString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"GeneralString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 27; // GeneralString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"GeneralString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends LocalSimpleStringBlock\n  */\n\tclass CharacterString extends LocalSimpleStringBlock {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"CharacterString\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 29; // CharacterString\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"CharacterString\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of all date and time classes\n\t//**************************************************************************************\n\t/**\n  * @extends VisibleString\n  */\n\tclass UTCTime extends VisibleString {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"UTCTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.year = 0;\n\t\t\tthis.month = 0;\n\t\t\tthis.day = 0;\n\t\t\tthis.hour = 0;\n\t\t\tthis.minute = 0;\n\t\t\tthis.second = 0;\n\n\t\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\t\tif (\"value\" in parameters) {\n\t\t\t\tthis.fromString(parameters.value);\n\n\t\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\t\tvar view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\t\tfor (var i = 0; i < parameters.value.length; i++) {\n\t\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\t\tif (\"valueDate\" in parameters) {\n\t\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 23; // UTCTime\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ASN.1 internal string into ArrayBuffer\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBuffer() {\n\t\t\tvar str = this.toString();\n\n\t\t\tvar buffer = new ArrayBuffer(str.length);\n\t\t\tvar view = new Uint8Array(buffer);\n\n\t\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\t\tview[i] = str.charCodeAt(i);\n\t\t\t}return buffer;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting \"Date\" object into ASN.1 internal string\n   * @param {!Date} inputDate JavaScript \"Date\" object\n   */\n\t\tfromDate(inputDate) {\n\t\t\tthis.year = inputDate.getUTCFullYear();\n\t\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\t\tthis.day = inputDate.getUTCDate();\n\t\t\tthis.hour = inputDate.getUTCHours();\n\t\t\tthis.minute = inputDate.getUTCMinutes();\n\t\t\tthis.second = inputDate.getUTCSeconds();\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Function converting ASN.1 internal string into \"Date\" object\n   * @returns {Date}\n   */\n\t\ttoDate() {\n\t\t\treturn new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\t//region Parse input string\n\t\t\tvar parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n\t\t\tvar parserArray = parser.exec(inputString);\n\t\t\tif (parserArray === null) {\n\t\t\t\tthis.error = \"Wrong input string for convertion\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Store parsed values\n\t\t\tvar year = parseInt(parserArray[1], 10);\n\t\t\tif (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n\n\t\t\tthis.month = parseInt(parserArray[2], 10);\n\t\t\tthis.day = parseInt(parserArray[3], 10);\n\t\t\tthis.hour = parseInt(parserArray[4], 10);\n\t\t\tthis.minute = parseInt(parserArray[5], 10);\n\t\t\tthis.second = parseInt(parserArray[6], 10);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ASN.1 internal class into JavaScript string\n   * @returns {string}\n   */\n\t\ttoString() {\n\t\t\tvar outputArray = new Array(7);\n\n\t\t\toutputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n\t\t\toutputArray[1] = padNumber(this.month, 2);\n\t\t\toutputArray[2] = padNumber(this.day, 2);\n\t\t\toutputArray[3] = padNumber(this.hour, 2);\n\t\t\toutputArray[4] = padNumber(this.minute, 2);\n\t\t\toutputArray[5] = padNumber(this.second, 2);\n\t\t\toutputArray[6] = \"Z\";\n\n\t\t\treturn outputArray.join(\"\");\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"UTCTime\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.year = this.year;\n\t\t\tobject.month = this.month;\n\t\t\tobject.day = this.day;\n\t\t\tobject.hour = this.hour;\n\t\t\tobject.minute = this.minute;\n\t\t\tobject.second = this.second;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends VisibleString\n  */\n\tclass GeneralizedTime extends VisibleString {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"GeneralizedTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.year = 0;\n\t\t\tthis.month = 0;\n\t\t\tthis.day = 0;\n\t\t\tthis.hour = 0;\n\t\t\tthis.minute = 0;\n\t\t\tthis.second = 0;\n\t\t\tthis.millisecond = 0;\n\n\t\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\t\tif (\"value\" in parameters) {\n\t\t\t\tthis.fromString(parameters.value);\n\n\t\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\t\tvar view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\t\tfor (var i = 0; i < parameters.value.length; i++) {\n\t\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\t\tif (\"valueDate\" in parameters) {\n\t\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 24; // GeneralizedTime\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tvar resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\t\t\tif (resultOffset === -1) {\n\t\t\t\tthis.error = this.valueBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\t\tif (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n\n\t\t\tif (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n\n\t\t\tif (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\t\tfromBuffer(inputBuffer) {\n\t\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ASN.1 internal string into ArrayBuffer\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBuffer() {\n\t\t\tvar str = this.toString();\n\n\t\t\tvar buffer = new ArrayBuffer(str.length);\n\t\t\tvar view = new Uint8Array(buffer);\n\n\t\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\t\tview[i] = str.charCodeAt(i);\n\t\t\t}return buffer;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting \"Date\" object into ASN.1 internal string\n   * @param {!Date} inputDate JavaScript \"Date\" object\n   */\n\t\tfromDate(inputDate) {\n\t\t\tthis.year = inputDate.getUTCFullYear();\n\t\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\t\tthis.day = inputDate.getUTCDate();\n\t\t\tthis.hour = inputDate.getUTCHours();\n\t\t\tthis.minute = inputDate.getUTCMinutes();\n\t\t\tthis.second = inputDate.getUTCSeconds();\n\t\t\tthis.millisecond = inputDate.getUTCMilliseconds();\n\t\t}\n\t\t//**********************************************************************************\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Function converting ASN.1 internal string into \"Date\" object\n   * @returns {Date}\n   */\n\t\ttoDate() {\n\t\t\treturn new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\t\tfromString(inputString) {\n\t\t\t//region Initial variables\n\t\t\tvar isUTC = false;\n\n\t\t\tvar timeString = \"\";\n\t\t\tvar dateTimeString = \"\";\n\t\t\tvar fractionPart = 0;\n\n\t\t\tvar parser = void 0;\n\n\t\t\tvar hourDifference = 0;\n\t\t\tvar minuteDifference = 0;\n\t\t\t//endregion\n\n\t\t\t//region Convert as UTC time\n\t\t\tif (inputString[inputString.length - 1] === \"Z\") {\n\t\t\t\ttimeString = inputString.substr(0, inputString.length - 1);\n\n\t\t\t\tisUTC = true;\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Convert as local time\n\t\t\telse {\n\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\tvar number = new Number(inputString[inputString.length - 1]);\n\n\t\t\t\t\tif (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\ttimeString = inputString;\n\t\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\t\t\tif (isUTC) {\n\t\t\t\tif (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\tif (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Get \"UTC time difference\" in case of local time\n\t\t\telse {\n\t\t\t\t\tvar multiplier = 1;\n\t\t\t\t\tvar differencePosition = timeString.indexOf(\"+\");\n\t\t\t\t\tvar differenceString = \"\";\n\n\t\t\t\t\tif (differencePosition === -1) {\n\t\t\t\t\t\tdifferencePosition = timeString.indexOf(\"-\");\n\t\t\t\t\t\tmultiplier = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (differencePosition !== -1) {\n\t\t\t\t\t\tdifferenceString = timeString.substr(differencePosition + 1);\n\t\t\t\t\t\ttimeString = timeString.substr(0, differencePosition);\n\n\t\t\t\t\t\tif (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\t\tvar _number = new Number(differenceString.substr(0, 2));\n\n\t\t\t\t\t\tif (isNaN(_number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\t\thourDifference = multiplier * _number;\n\n\t\t\t\t\t\tif (differenceString.length === 4) {\n\t\t\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\t\t\t_number = new Number(differenceString.substr(2, 2));\n\n\t\t\t\t\t\t\tif (isNaN(_number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\t\t\tminuteDifference = multiplier * _number;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Get position of fraction point\n\t\t\tvar fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\t\t\tif (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n\t\t\t//endregion\n\n\t\t\t//region Get fraction part\n\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\tvar fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n\n\t\t\t\tif (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\t\tfractionPart = fractionPartCheck.valueOf();\n\n\t\t\t\tdateTimeString = timeString.substr(0, fractionPointPosition);\n\t\t\t} else dateTimeString = timeString;\n\t\t\t//endregion\n\n\t\t\t//region Parse internal date\n\t\t\tswitch (true) {\n\t\t\t\tcase dateTimeString.length === 8:\n\t\t\t\t\t// \"YYYYMMDD\"\n\t\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n\t\t\t\t\tif (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\t\t\t\t\tbreak;\n\t\t\t\tcase dateTimeString.length === 10:\n\t\t\t\t\t// \"YYYYMMDDHH\"\n\t\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\t\tvar fractionResult = 60 * fractionPart;\n\t\t\t\t\t\tthis.minute = Math.floor(fractionResult);\n\n\t\t\t\t\t\tfractionResult = 60 * (fractionResult - this.minute);\n\t\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase dateTimeString.length === 12:\n\t\t\t\t\t// \"YYYYMMDDHHMM\"\n\t\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\t\tvar _fractionResult = 60 * fractionPart;\n\t\t\t\t\t\tthis.second = Math.floor(_fractionResult);\n\n\t\t\t\t\t\t_fractionResult = 1000 * (_fractionResult - this.second);\n\t\t\t\t\t\tthis.millisecond = Math.floor(_fractionResult);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase dateTimeString.length === 14:\n\t\t\t\t\t// \"YYYYMMDDHHMMSS\"\n\t\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\t\tif (fractionPointPosition !== -1) {\n\t\t\t\t\t\tvar _fractionResult2 = 1000 * fractionPart;\n\t\t\t\t\t\tthis.millisecond = Math.floor(_fractionResult2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Put parsed values at right places\n\t\t\tvar parserArray = parser.exec(dateTimeString);\n\t\t\tif (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n\t\t\tfor (var j = 1; j < parserArray.length; j++) {\n\t\t\t\tswitch (j) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.year = parseInt(parserArray[j], 10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tthis.month = parseInt(parserArray[j], 10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tthis.day = parseInt(parserArray[j], 10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tthis.hour = parseInt(parserArray[j], 10) + hourDifference;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tthis.minute = parseInt(parserArray[j], 10) + minuteDifference;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tthis.second = parseInt(parserArray[j], 10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Get final date\n\t\t\tif (isUTC === false) {\n\t\t\t\tvar tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n\n\t\t\t\tthis.year = tempDate.getUTCFullYear();\n\t\t\t\tthis.month = tempDate.getUTCMonth();\n\t\t\t\tthis.day = tempDate.getUTCDay();\n\t\t\t\tthis.hour = tempDate.getUTCHours();\n\t\t\t\tthis.minute = tempDate.getUTCMinutes();\n\t\t\t\tthis.second = tempDate.getUTCSeconds();\n\t\t\t\tthis.millisecond = tempDate.getUTCMilliseconds();\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Function converting ASN.1 internal class into JavaScript string\n   * @returns {string}\n   */\n\t\ttoString() {\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(padNumber(this.year, 4));\n\t\t\toutputArray.push(padNumber(this.month, 2));\n\t\t\toutputArray.push(padNumber(this.day, 2));\n\t\t\toutputArray.push(padNumber(this.hour, 2));\n\t\t\toutputArray.push(padNumber(this.minute, 2));\n\t\t\toutputArray.push(padNumber(this.second, 2));\n\t\t\tif (this.millisecond !== 0) {\n\t\t\t\toutputArray.push(\".\");\n\t\t\t\toutputArray.push(padNumber(this.millisecond, 3));\n\t\t\t}\n\t\t\toutputArray.push(\"Z\");\n\n\t\t\treturn outputArray.join(\"\");\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"GeneralizedTime\";\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\t\ttry {\n\t\t\t\tobject = super.toJSON();\n\t\t\t} catch (ex) {}\n\t\t\t//endregion\n\n\t\t\tobject.year = this.year;\n\t\t\tobject.month = this.month;\n\t\t\tobject.day = this.day;\n\t\t\tobject.hour = this.hour;\n\t\t\tobject.minute = this.minute;\n\t\t\tobject.second = this.second;\n\t\t\tobject.millisecond = this.millisecond;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends Utf8String\n  */\n\tclass DATE extends Utf8String {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"DATE\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 31; // DATE\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"DATE\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends Utf8String\n  */\n\tclass TimeOfDay extends Utf8String {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"TimeOfDay\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 32; // TimeOfDay\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"TimeOfDay\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends Utf8String\n  */\n\tclass DateTime extends Utf8String {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"DateTime\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 33; // DateTime\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"DateTime\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends Utf8String\n  */\n\tclass Duration extends Utf8String {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Duration\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 34; // Duration\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"Duration\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * @extends Utf8String\n  */\n\tclass TIME extends Utf8String {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Time\" class\n   * @param {Object} [parameters={}]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tsuper(parameters);\n\n\t\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\tthis.idBlock.tagNumber = 14; // Time\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\t\tstatic blockName() {\n\t\t\treturn \"TIME\";\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of special ASN.1 schema type Choice\n\t//**************************************************************************************\n\tclass Choice {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Choice\" class\n   * @param {Object} [parameters={}]\n   * @property {Array} [value] Array of ASN.1 types for make a choice from\n   * @property {boolean} [optional]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of special ASN.1 schema type Any\n\t//**************************************************************************************\n\tclass Any {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Any\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of special ASN.1 schema type Repeated\n\t//**************************************************************************************\n\tclass Repeated {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Repeated\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t\t\tthis.value = getParametersValue(parameters, \"value\", new Any());\n\t\t\tthis.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of special ASN.1 schema type RawData\n\t//**************************************************************************************\n\t/**\n  * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\n  */\n\tclass RawData {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"Repeated\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tthis.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\t\tfromBER(inputBuffer, inputOffset, inputLength) {\n\t\t\tthis.data = inputBuffer.slice(inputOffset, inputLength);\n\t\t\treturn inputOffset + inputLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\t\ttoBER() {\n\t\t\tvar sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\treturn this.data;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Major ASN.1 BER decoding function\n\t//**************************************************************************************\n\t/**\n  * Internal library function for decoding ASN.1 BER\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n  * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n  * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n  * @returns {{offset: number, result: Object}}\n  */\n\tfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n\t\tvar incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n\n\t\t//region Local function changing a type for ASN.1 classes\n\t\tfunction localChangeType(inputObject, newType) {\n\t\t\tif (inputObject instanceof newType) return inputObject;\n\n\t\t\tvar newObject = new newType();\n\t\t\tnewObject.idBlock = inputObject.idBlock;\n\t\t\tnewObject.lenBlock = inputObject.lenBlock;\n\t\t\tnewObject.warnings = inputObject.warnings;\n\t\t\t//noinspection JSCheckFunctionSignatures\n\t\t\tnewObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n\n\t\t\treturn newObject;\n\t\t}\n\t\t//endregion\n\n\t\t//region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\t\tvar returnObject = new BaseBlock({}, Object);\n\t\t//endregion\n\n\t\t//region Basic check for parameters\n\t\tif (checkBufferParams(new LocalBaseBlock(), inputBuffer, inputOffset, inputLength) === false) {\n\t\t\treturnObject.error = \"Wrong input parameters\";\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult: returnObject\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tvar intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif (intBuffer.length === 0) {\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult: returnObject\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Decode indentifcation block of ASN.1 BER structure\n\t\tvar resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\t\treturnObject.warnings.concat(returnObject.idBlock.warnings);\n\t\tif (resultOffset === -1) {\n\t\t\treturnObject.error = returnObject.idBlock.error;\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult: returnObject\n\t\t\t};\n\t\t}\n\n\t\tinputOffset = resultOffset;\n\t\tinputLength -= returnObject.idBlock.blockLength;\n\t\t//endregion\n\n\t\t//region Decode length block of ASN.1 BER structure\n\t\tresultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\t\treturnObject.warnings.concat(returnObject.lenBlock.warnings);\n\t\tif (resultOffset === -1) {\n\t\t\treturnObject.error = returnObject.lenBlock.error;\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult: returnObject\n\t\t\t};\n\t\t}\n\n\t\tinputOffset = resultOffset;\n\t\tinputLength -= returnObject.lenBlock.blockLength;\n\t\t//endregion\n\n\t\t//region Check for usign indefinite length form in encoding for primitive types\n\t\tif (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n\t\t\treturnObject.error = \"Indefinite length form used for primitive encoding form\";\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult: returnObject\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Switch ASN.1 block type\n\t\tvar newASN1Type = BaseBlock;\n\n\t\tswitch (returnObject.idBlock.tagClass) {\n\t\t\t//region UNIVERSAL\n\t\t\tcase 1:\n\t\t\t\t//region Check for reserved tag numbers\n\t\t\t\tif (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n\t\t\t\t\treturnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n\t\t\t\t\treturn {\n\t\t\t\t\t\toffset: -1,\n\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\tswitch (returnObject.idBlock.tagNumber) {\n\t\t\t\t\t//region EndOfContent type\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t//region Check for EndOfContent type\n\t\t\t\t\t\tif (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n\t\t\t\t\t\t\treturnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\toffset: -1,\n\t\t\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\tnewASN1Type = EndOfContent;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Boolean type\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tnewASN1Type = Boolean;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Integer type\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tnewASN1Type = Integer;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region BitString type\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tnewASN1Type = BitString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region OctetString type\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tnewASN1Type = OctetString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Null type\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tnewASN1Type = Null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region OBJECT IDENTIFIER type\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tnewASN1Type = ObjectIdentifier;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Enumerated type\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tnewASN1Type = Enumerated;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Utf8String type\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tnewASN1Type = Utf8String;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Time type\n\t\t\t\t\tcase 14:\n\t\t\t\t\t\tnewASN1Type = TIME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region ASN.1 reserved type\n\t\t\t\t\tcase 15:\n\t\t\t\t\t\treturnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toffset: -1,\n\t\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t\t};\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Sequence type\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tnewASN1Type = Sequence;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Set type\n\t\t\t\t\tcase 17:\n\t\t\t\t\t\tnewASN1Type = Set;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region NumericString type\n\t\t\t\t\tcase 18:\n\t\t\t\t\t\tnewASN1Type = NumericString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region PrintableString type\n\t\t\t\t\tcase 19:\n\t\t\t\t\t\tnewASN1Type = PrintableString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region TeletexString type\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\tnewASN1Type = TeletexString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region VideotexString type\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\tnewASN1Type = VideotexString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region IA5String type\n\t\t\t\t\tcase 22:\n\t\t\t\t\t\tnewASN1Type = IA5String;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region UTCTime type\n\t\t\t\t\tcase 23:\n\t\t\t\t\t\tnewASN1Type = UTCTime;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region GeneralizedTime type\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tnewASN1Type = GeneralizedTime;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region GraphicString type\n\t\t\t\t\tcase 25:\n\t\t\t\t\t\tnewASN1Type = GraphicString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region VisibleString type\n\t\t\t\t\tcase 26:\n\t\t\t\t\t\tnewASN1Type = VisibleString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region GeneralString type\n\t\t\t\t\tcase 27:\n\t\t\t\t\t\tnewASN1Type = GeneralString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region UniversalString type\n\t\t\t\t\tcase 28:\n\t\t\t\t\t\tnewASN1Type = UniversalString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region CharacterString type\n\t\t\t\t\tcase 29:\n\t\t\t\t\t\tnewASN1Type = CharacterString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region BmpString type\n\t\t\t\t\tcase 30:\n\t\t\t\t\t\tnewASN1Type = BmpString;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region DATE type\n\t\t\t\t\tcase 31:\n\t\t\t\t\t\tnewASN1Type = DATE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region TimeOfDay type\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tnewASN1Type = TimeOfDay;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Date-Time type\n\t\t\t\t\tcase 33:\n\t\t\t\t\t\tnewASN1Type = DateTime;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region Duration type\n\t\t\t\t\tcase 34:\n\t\t\t\t\t\tnewASN1Type = Duration;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//endregion\n\t\t\t\t\t//region default\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar newObject = void 0;\n\n\t\t\t\t\t\t\tif (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n\n\t\t\t\t\t\t\tnewObject.idBlock = returnObject.idBlock;\n\t\t\t\t\t\t\tnewObject.lenBlock = returnObject.lenBlock;\n\t\t\t\t\t\t\tnewObject.warnings = returnObject.warnings;\n\n\t\t\t\t\t\t\treturnObject = newObject;\n\n\t\t\t\t\t\t\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//endregion\n\t\t\t//region All other tag classes\n\t\t\tcase 2: // APPLICATION\n\t\t\tcase 3: // CONTEXT-SPECIFIC\n\t\t\tcase 4: // PRIVATE\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n\t\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//endregion\n\n\t\t//region Change type and perform BER decoding\n\t\treturnObject = localChangeType(returnObject, newASN1Type);\n\t\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length);\n\t\t//endregion\n\n\t\t//region Coping incoming buffer for entire ASN.1 block\n\t\treturnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);\n\t\t//endregion\n\n\t\treturn {\n\t\t\toffset: resultOffset,\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//**************************************************************************************\n\t/**\n  * Major function for decoding ASN.1 BER array into internal library structuries\n  * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\n  */\n\tfunction fromBER(inputBuffer) {\n\t\tif (inputBuffer.byteLength === 0) {\n\t\t\tvar result = new BaseBlock({}, Object);\n\t\t\tresult.error = \"Input buffer has zero length\";\n\n\t\t\treturn {\n\t\t\t\toffset: -1,\n\t\t\t\tresult\n\t\t\t};\n\t\t}\n\n\t\treturn LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Major scheme verification function\n\t//**************************************************************************************\n\t/**\n  * Compare of two ASN.1 object trees\n  * @param {!Object} root Root of input ASN.1 object tree\n  * @param {!Object} inputData Input ASN.1 object tree\n  * @param {!Object} inputSchema Input ASN.1 schema to compare with\n  * @return {{verified: boolean}|{verified:boolean, result: Object}}\n  */\n\tfunction compareSchema(root, inputData, inputSchema) {\n\t\t//region Special case for Choice schema element type\n\t\tif (inputSchema instanceof Choice) {\n\n\t\t\tfor (var j = 0; j < inputSchema.value.length; j++) {\n\t\t\t\tvar result = compareSchema(root, inputData, inputSchema.value[j]);\n\t\t\t\tif (result.verified === true) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverified: true,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tvar _result = {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: {\n\t\t\t\t\t\terror: \"Wrong values for Choice type\"\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n\n\t\t\t\treturn _result;\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Special case for Any schema element type\n\t\tif (inputSchema instanceof Any) {\n\t\t\t//region Add named component of ASN.1 schema\n\t\t\tif (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData;\n\t\t\t//endregion\n\n\t\t\treturn {\n\t\t\t\tverified: true,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Initial check\n\t\tif (root instanceof Object === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong root object\" }\n\t\t\t};\n\t\t}\n\n\t\tif (inputData instanceof Object === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 data\" }\n\t\t\t};\n\t\t}\n\n\t\tif (inputSchema instanceof Object === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tif (\"idBlock\" in inputSchema === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n\t\t//region Encode and decode ASN.1 schema idBlock\n\t\t/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\t\tif (\"fromBER\" in inputSchema.idBlock === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tif (\"toBER\" in inputSchema.idBlock === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tvar encodedId = inputSchema.idBlock.toBER(false);\n\t\tif (encodedId.byteLength === 0) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Error encoding idBlock for ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tvar decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\t\tif (decodedOffset === -1) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Error decoding idBlock for ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region tagClass\n\t\tif (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tif (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region tagNumber\n\t\tif (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tif (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region isConstructed\n\t\tif (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tif (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region isHexOnly\n\t\tif (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t\t};\n\t\t\t}\n\n\t\tif (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region valueHex\n\t\tif (inputSchema.idBlock.isHexOnly === true) {\n\t\t\tif (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n\t\t\t\t{\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\tvar schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n\t\t\tvar asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n\t\t\tif (schemaView.length !== asn1View.length) {\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < schemaView.length; i++) {\n\t\t\t\tif (schemaView[i] !== asn1View[1]) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//endregion\n\t\t//endregion\n\n\t\t//region Add named component of ASN.1 schema\n\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\tif (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n\t\t}\n\t\t//endregion\n\n\t\t//region Getting next ASN.1 block for comparition\n\t\tif (inputSchema.idBlock.isConstructed === true) {\n\t\t\tvar admission = 0;\n\t\t\tvar _result2 = { verified: false };\n\n\t\t\tvar maxLength = inputSchema.valueBlock.value.length;\n\n\t\t\tif (maxLength > 0) {\n\t\t\t\tif (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n\t\t\t}\n\n\t\t\t//region Special case when constructive value has no elements\n\t\t\tif (maxLength === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\t\t\tif (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n\t\t\t\tvar _optional = true;\n\n\t\t\t\tfor (var _i11 = 0; _i11 < inputSchema.valueBlock.value.length; _i11++) {\n\t\t\t\t\t_optional = _optional && (inputSchema.valueBlock.value[_i11].optional || false);\n\t\t\t\t}if (_optional === true) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tverified: true,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t//region Delete early added name of block\n\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\troot.error = \"Inconsistent object length\";\n\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tfor (var _i12 = 0; _i12 < maxLength; _i12++) {\n\t\t\t\t//region Special case when there is an \"optional\" element of ASN.1 schema at the end\n\t\t\t\tif (_i12 - admission >= inputData.valueBlock.value.length) {\n\t\t\t\t\tif (inputSchema.valueBlock.value[_i12].optional === false) {\n\t\t\t\t\t\tvar _result3 = {\n\t\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\t\tresult: root\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\troot.error = \"Inconsistent length between ASN.1 data and schema\";\n\n\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t\t_result3.name = inputSchema.name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\treturn _result3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t\telse {\n\t\t\t\t\t\t//region Special case for Repeated type of ASN.1 schema element\n\t\t\t\t\t\tif (inputSchema.valueBlock.value[0] instanceof Repeated) {\n\t\t\t\t\t\t\t_result2 = compareSchema(root, inputData.valueBlock.value[_i12], inputSchema.valueBlock.value[0].value);\n\t\t\t\t\t\t\tif (_result2.verified === false) {\n\t\t\t\t\t\t\t\tif (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n\t\t\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\treturn _result2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n\t\t\t\t\t\t\t\tvar arrayRoot = {};\n\n\t\t\t\t\t\t\t\tif (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n\n\t\t\t\t\t\t\t\tif (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n\n\t\t\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[_i12]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//endregion\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t_result2 = compareSchema(root, inputData.valueBlock.value[_i12 - admission], inputSchema.valueBlock.value[_i12]);\n\t\t\t\t\t\t\t\tif (_result2.verified === false) {\n\t\t\t\t\t\t\t\t\tif (inputSchema.valueBlock.value[_i12].optional === true) admission++;else {\n\t\t\t\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\t\t\t\tif (inputSchema.name !== \"\") delete root[inputSchema.name];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t\treturn _result2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_result2.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n\t\t\t\t{\n\t\t\t\t\tvar _result4 = {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\n\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t_result4.name = inputSchema.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\treturn _result4;\n\t\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tverified: true,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\t\tif (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n\t\t\t//region Decoding of raw ASN.1 data\n\t\t\tvar asn1 = fromBER(inputData.valueBlock.valueHex);\n\t\t\tif (asn1.offset === -1) {\n\t\t\t\tvar _result5 = {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: asn1.result\n\t\t\t\t};\n\n\t\t\t\t//region Delete early added name of block\n\t\t\t\tif (inputSchema.hasOwnProperty(\"name\")) {\n\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\tif (inputSchema.name !== \"\") {\n\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t_result5.name = inputSchema.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\treturn _result5;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n\t\t}\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t\t//endregion\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass AlgorithmIdentifier {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description ObjectIdentifier for algorithm (string representation)\n    */\n\t\t\tthis.algorithmId = getParametersValue(parameters, \"algorithmId\", AlgorithmIdentifier.defaultValues(\"algorithmId\"));\n\n\t\t\tif (\"algorithmParams\" in parameters)\n\t\t\t\t/**\n     * @type {Object}\n     * @description Any algorithm parameters\n     */\n\t\t\t\tthis.algorithmParams = getParametersValue(parameters, \"algorithmParams\", AlgorithmIdentifier.defaultValues(\"algorithmParams\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"algorithmId\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"algorithmParams\":\n\t\t\t\t\treturn new Any();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"algorithmId\":\n\t\t\t\t\treturn memberValue === \"\";\n\t\t\t\tcase \"algorithmParams\":\n\t\t\t\t\treturn memberValue instanceof Any;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//AlgorithmIdentifier  ::=  Sequence  {\n\t\t\t//    algorithm               OBJECT IDENTIFIER,\n\t\t\t//    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n    * @property {string} algorithmParams Any algorithm parameters\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\toptional: names.optional || false,\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.algorithmIdentifier || \"\" }), new Any({ name: names.algorithmParams || \"\", optional: true })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"algorithm\", \"params\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, AlgorithmIdentifier.schema({\n\t\t\t\tnames: {\n\t\t\t\t\talgorithmIdentifier: \"algorithm\",\n\t\t\t\t\talgorithmParams: \"params\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AlgorithmIdentifier\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.algorithmId = asn1.result.algorithm.valueBlock.toString();\n\t\t\tif (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n\t\t\tif (\"algorithmParams\" in this && this.algorithmParams instanceof Any === false) outputArray.push(this.algorithmParams);\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {\n\t\t\t\talgorithmId: this.algorithmId\n\t\t\t};\n\n\t\t\tif (\"algorithmParams\" in this && this.algorithmParams instanceof Any === false) object.algorithmParams = this.algorithmParams.toJSON();\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n\t\tisEqual(algorithmIdentifier) {\n\t\t\t//region Check input type\n\t\t\tif (algorithmIdentifier instanceof AlgorithmIdentifier === false) return false;\n\t\t\t//endregion\n\n\t\t\t//region Check \"algorithm_id\"\n\t\t\tif (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n\t\t\t//endregion\n\n\t\t\t//region Check \"algorithm_params\"\n\t\t\tif (\"algorithmParams\" in this) {\n\t\t\t\tif (\"algorithmParams\" in algorithmIdentifier) return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (\"algorithmParams\" in algorithmIdentifier) return false;\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5480\n  */\n\tclass ECPublicKey {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for ECCPublicKey class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description type\n    */\n\t\t\tthis.x = getParametersValue(parameters, \"x\", ECPublicKey.defaultValues(\"x\"));\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description values\n    */\n\t\t\tthis.y = getParametersValue(parameters, \"y\", ECPublicKey.defaultValues(\"y\"));\n\t\t\t/**\n    * @type {string}\n    * @description namedCurve\n    */\n\t\t\tthis.namedCurve = getParametersValue(parameters, \"namedCurve\", ECPublicKey.defaultValues(\"namedCurve\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"x\":\n\t\t\t\tcase \"y\":\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\tcase \"namedCurve\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"x\":\n\t\t\t\tcase \"y\":\n\t\t\t\t\treturn isEqualBuffer(memberValue, ECPublicKey.defaultValues(memberName));\n\t\t\t\tcase \"namedCurve\":\n\t\t\t\t\treturn memberValue === \"\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\treturn new RawData();\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert ArrayBuffer into current class\n   * @param {!ArrayBuffer} schema Special case: schema is an ArrayBuffer\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Check the schema is valid\n\t\t\tif (schema instanceof ArrayBuffer === false) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\");\n\n\t\t\tvar view = new Uint8Array(schema);\n\t\t\tif (view[0] !== 0x04) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tvar coordinateLength = void 0;\n\n\t\t\tswitch (this.namedCurve) {\n\t\t\t\tcase \"1.2.840.10045.3.1.7\":\n\t\t\t\t\t// P-256\n\t\t\t\t\tcoordinateLength = 32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.34\":\n\t\t\t\t\t// P-384\n\t\t\t\t\tcoordinateLength = 48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.35\":\n\t\t\t\t\t// P-521\n\t\t\t\t\tcoordinateLength = 66;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Incorrect curve OID: ${this.namedCurve}`);\n\t\t\t}\n\n\t\t\tif (schema.byteLength !== coordinateLength * 2 + 1) throw new Error(\"Object's schema was not verified against input data for ECPublicKey\");\n\n\t\t\tthis.x = schema.slice(1, coordinateLength + 1);\n\t\t\tthis.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\treturn new RawData({ data: utilConcatBuf(new Uint8Array([0x04]).buffer, this.x, this.y)\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar crvName = \"\";\n\n\t\t\tswitch (this.namedCurve) {\n\t\t\t\tcase \"1.2.840.10045.3.1.7\":\n\t\t\t\t\t// P-256\n\t\t\t\t\tcrvName = \"P-256\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.34\":\n\t\t\t\t\t// P-384\n\t\t\t\t\tcrvName = \"P-384\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.35\":\n\t\t\t\t\t// P-521\n\t\t\t\t\tcrvName = \"P-521\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcrv: crvName,\n\t\t\t\tx: toBase64(arrayBufferToString(this.x), true, true, false),\n\t\t\t\ty: toBase64(arrayBufferToString(this.y), true, true, false)\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tvar coodinateLength = 0;\n\n\t\t\tif (\"crv\" in json) {\n\t\t\t\tswitch (json.crv.toUpperCase()) {\n\t\t\t\t\tcase \"P-256\":\n\t\t\t\t\t\tthis.namedCurve = \"1.2.840.10045.3.1.7\";\n\t\t\t\t\t\tcoodinateLength = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"P-384\":\n\t\t\t\t\t\tthis.namedCurve = \"1.3.132.0.34\";\n\t\t\t\t\t\tcoodinateLength = 48;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"P-521\":\n\t\t\t\t\t\tthis.namedCurve = \"1.3.132.0.35\";\n\t\t\t\t\t\tcoodinateLength = 66;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"crv\\\"\");\n\n\t\t\tif (\"x\" in json) {\n\t\t\t\tvar convertBuffer = stringToArrayBuffer(fromBase64(json.x, true));\n\n\t\t\t\tif (convertBuffer.byteLength < coodinateLength) {\n\t\t\t\t\tthis.x = new ArrayBuffer(coodinateLength);\n\t\t\t\t\tvar view = new Uint8Array(this.x);\n\t\t\t\t\tvar convertBufferView = new Uint8Array(convertBuffer);\n\t\t\t\t\tview.set(convertBufferView, 1);\n\t\t\t\t} else this.x = convertBuffer.slice(0, coodinateLength);\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"x\\\"\");\n\n\t\t\tif (\"y\" in json) {\n\t\t\t\tvar _convertBuffer = stringToArrayBuffer(fromBase64(json.y, true));\n\n\t\t\t\tif (_convertBuffer.byteLength < coodinateLength) {\n\t\t\t\t\tthis.y = new ArrayBuffer(coodinateLength);\n\t\t\t\t\tvar _view3 = new Uint8Array(this.y);\n\t\t\t\t\tvar _convertBufferView = new Uint8Array(_convertBuffer);\n\t\t\t\t\t_view3.set(_convertBufferView, 1);\n\t\t\t\t} else this.y = _convertBuffer.slice(0, coodinateLength);\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"y\\\"\");\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC3447\n  */\n\tclass RSAPublicKey {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for RSAPublicKey class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {Integer} [modulus]\n   * @property {Integer} [publicExponent]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Integer}\n    * @description Modulus part of RSA public key\n    */\n\t\t\tthis.modulus = getParametersValue(parameters, \"modulus\", RSAPublicKey.defaultValues(\"modulus\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description Public exponent of RSA public key\n    */\n\t\t\tthis.publicExponent = getParametersValue(parameters, \"publicExponent\", RSAPublicKey.defaultValues(\"publicExponent\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"modulus\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"publicExponent\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for RSAPublicKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//RSAPublicKey ::= Sequence {\n\t\t\t//    modulus           Integer,  -- n\n\t\t\t//    publicExponent    Integer   -- e\n\t\t\t//}\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} utcTimeName Name for \"utcTimeName\" choice\n    * @property {string} generalTimeName Name for \"generalTimeName\" choice\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Integer({ name: names.modulus || \"\" }), new Integer({ name: names.publicExponent || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"modulus\", \"publicExponent\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, RSAPublicKey.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tmodulus: \"modulus\",\n\t\t\t\t\tpublicExponent: \"publicExponent\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSAPublicKey\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.modulus = asn1.result.modulus.convertFromDER(256);\n\t\t\tthis.publicExponent = asn1.result.publicExponent;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [this.modulus.convertToDER(), this.publicExponent]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tn: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),\n\t\t\t\te: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true)\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tif (\"n\" in json) {\n\t\t\t\tvar array = stringToArrayBuffer(fromBase64(json.n, true));\n\t\t\t\tthis.modulus = new Integer({ valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength))) });\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"n\\\"\");\n\n\t\t\tif (\"e\" in json) this.publicExponent = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3) });else throw new Error(\"Absent mandatory parameter \\\"e\\\"\");\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PublicKeyInfo {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description Algorithm identifier\n    */\n\t\t\tthis.algorithm = getParametersValue(parameters, \"algorithm\", PublicKeyInfo.defaultValues(\"algorithm\"));\n\t\t\t/**\n    * @type {BitString}\n    * @description Subject public key value\n    */\n\t\t\tthis.subjectPublicKey = getParametersValue(parameters, \"subjectPublicKey\", PublicKeyInfo.defaultValues(\"subjectPublicKey\"));\n\n\t\t\tif (\"parsedKey\" in parameters)\n\t\t\t\t/**\n     * @type {ECPublicKey|RSAPublicKey}\n     * @description Parsed public key value\n     */\n\t\t\t\tthis.parsedKey = getParametersValue(parameters, \"parsedKey\", PublicKeyInfo.defaultValues(\"parsedKey\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"algorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tcase \"subjectPublicKey\":\n\t\t\t\t\treturn new BitString();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//SubjectPublicKeyInfo  ::=  Sequence  {\n\t\t\t//    algorithm            AlgorithmIdentifier,\n\t\t\t//    subjectPublicKey     BIT STRING  }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [algorithm]\n    * @property {string} [subjectPublicKey]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [AlgorithmIdentifier.schema(names.algorithm || {}), new BitString({ name: names.subjectPublicKey || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"algorithm\", \"subjectPublicKey\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PublicKeyInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\talgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"algorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsubjectPublicKey: \"subjectPublicKey\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PublicKeyInfo\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });\n\t\t\tthis.subjectPublicKey = asn1.result.subjectPublicKey;\n\n\t\t\tswitch (this.algorithm.algorithmId) {\n\t\t\t\tcase \"1.2.840.10045.2.1\":\n\t\t\t\t\t// ECDSA\n\t\t\t\t\tif (\"algorithmParams\" in this.algorithm) {\n\t\t\t\t\t\tif (this.algorithm.algorithmParams instanceof ObjectIdentifier) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tthis.parsedKey = new ECPublicKey({\n\t\t\t\t\t\t\t\t\tnamedCurve: this.algorithm.algorithmParams.valueBlock.toString(),\n\t\t\t\t\t\t\t\t\tschema: this.subjectPublicKey.valueBlock.valueHex\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.113549.1.1.1\":\n\t\t\t\t\t// RSA\n\t\t\t\t\t{\n\t\t\t\t\t\tvar publicKeyASN1 = fromBER(this.subjectPublicKey.valueBlock.valueHex);\n\t\t\t\t\t\tif (publicKeyASN1.offset !== -1) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tthis.parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });\n\t\t\t\t\t\t\t} catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [this.algorithm.toSchema(), this.subjectPublicKey]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\t//region Return common value in case we do not have enough info fo making JWK\n\t\t\tif (\"parsedKey\" in this === false) {\n\t\t\t\treturn {\n\t\t\t\t\talgorithm: this.algorithm.toJSON(),\n\t\t\t\t\tsubjectPublicKey: this.subjectPublicKey.toJSON()\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Making JWK\n\t\t\tvar jwk = {};\n\n\t\t\tswitch (this.algorithm.algorithmId) {\n\t\t\t\tcase \"1.2.840.10045.2.1\":\n\t\t\t\t\t// ECDSA\n\t\t\t\t\tjwk.kty = \"EC\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.113549.1.1.1\":\n\t\t\t\t\t// RSA\n\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\tvar publicKeyJWK = this.parsedKey.toJSON();\n\n\t\t\tvar _iteratorNormalCompletion8 = true;\n\t\t\tvar _didIteratorError8 = false;\n\t\t\tvar _iteratorError8 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator8 = Object.keys(publicKeyJWK)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t\t\t\t\tvar key = _step8.value;\n\n\t\t\t\t\tjwk[key] = publicKeyJWK[key];\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError8 = true;\n\t\t\t\t_iteratorError8 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t\t\t\t\t\t_iterator8.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError8) {\n\t\t\t\t\t\tthrow _iteratorError8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jwk;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tif (\"kty\" in json) {\n\t\t\t\tswitch (json.kty.toUpperCase()) {\n\t\t\t\t\tcase \"EC\":\n\t\t\t\t\t\tthis.parsedKey = new ECPublicKey({ json });\n\n\t\t\t\t\t\tthis.algorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\talgorithmId: \"1.2.840.10045.2.1\",\n\t\t\t\t\t\t\talgorithmParams: new ObjectIdentifier({ value: this.parsedKey.namedCurve })\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"RSA\":\n\t\t\t\t\t\tthis.parsedKey = new RSAPublicKey({ json });\n\n\t\t\t\t\t\tthis.algorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.1\",\n\t\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n\t\t\t\t}\n\n\t\t\t\tthis.subjectPublicKey = new BitString({ valueHex: this.parsedKey.toSchema().toBER(false) });\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\timportKey(publicKey) {\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\t\t\tvar _this = this;\n\t\t\t//endregion\n\n\t\t\t//region Initial check\n\t\t\tif (typeof publicKey === \"undefined\") return Promise.reject(\"Need to provide publicKey input parameter\");\n\t\t\t//endregion\n\n\t\t\t//region Get a \"crypto\" extension\n\t\t\tvar crypto = getCrypto();\n\t\t\tif (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\");\n\t\t\t//endregion\n\n\t\t\t//region Export public key\n\t\t\tsequence = sequence.then(() => crypto.exportKey(\"spki\", publicKey));\n\t\t\t//endregion\n\n\t\t\t//region Initialize internal variables by parsing exported value\n\t\t\tsequence = sequence.then(\n\t\t\t/**\n    * @param {ArrayBuffer} exportedKey\n    */\n\t\t\texportedKey => {\n\t\t\t\tvar asn1 = fromBER(exportedKey);\n\t\t\t\ttry {\n\t\t\t\t\t_this.fromSchema(asn1.result);\n\t\t\t\t} catch (exception) {\n\t\t\t\t\treturn Promise.reject(\"Error during initializing object from schema\");\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}, error => Promise.reject(`Error during exporting public key: ${error}`));\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC2986\n  */\n\tclass Attribute {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for Attribute class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description type\n    */\n\t\t\tthis.type = getParametersValue(parameters, \"type\", Attribute.defaultValues(\"type\"));\n\t\t\t/**\n    * @type {Array}\n    * @description values\n    */\n\t\t\tthis.values = getParametersValue(parameters, \"values\", Attribute.defaultValues(\"values\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"type\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"values\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for Attribute class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"type\":\n\t\t\t\t\treturn memberValue === \"\";\n\t\t\t\tcase \"values\":\n\t\t\t\t\treturn memberValue.length === 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for Attribute class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\n\t\t\t//    type   ATTRIBUTE.&id({IOSet}),\n\t\t\t//    values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\n\t\t\t//}\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [type]\n    * @property {string} [setName]\n    * @property {string} [values]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.type || \"\" }), new Set({\n\t\t\t\t\tname: names.setName || \"\",\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.values || \"\",\n\t\t\t\t\t\tvalue: new Any()\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"type\", \"values\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, Attribute.schema({\n\t\t\t\tnames: {\n\t\t\t\t\ttype: \"type\",\n\t\t\t\t\tvalues: \"values\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Attribute\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.type = asn1.result.type.valueBlock.toString();\n\t\t\tthis.values = asn1.result.values;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [new ObjectIdentifier({ value: this.type }), new Set({\n\t\t\t\t\tvalue: this.values\n\t\t\t\t})]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\ttype: this.type,\n\t\t\t\tvalues: Array.from(this.values, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5915\n  */\n\tclass ECPrivateKey {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for ECCPrivateKey class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {number}\n    * @description version\n    */\n\t\t\tthis.version = getParametersValue(parameters, \"version\", ECPrivateKey.defaultValues(\"version\"));\n\t\t\t/**\n    * @type {OctetString}\n    * @description privateKey\n    */\n\t\t\tthis.privateKey = getParametersValue(parameters, \"privateKey\", ECPrivateKey.defaultValues(\"privateKey\"));\n\n\t\t\tif (\"namedCurve\" in parameters)\n\t\t\t\t/**\n     * @type {string}\n     * @description namedCurve\n     */\n\t\t\t\tthis.namedCurve = getParametersValue(parameters, \"namedCurve\", ECPrivateKey.defaultValues(\"namedCurve\"));\n\n\t\t\tif (\"publicKey\" in parameters)\n\t\t\t\t/**\n     * @type {ECPublicKey}\n     * @description publicKey\n     */\n\t\t\t\tthis.publicKey = getParametersValue(parameters, \"publicKey\", ECPrivateKey.defaultValues(\"publicKey\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn 1;\n\t\t\t\tcase \"privateKey\":\n\t\t\t\t\treturn new OctetString();\n\t\t\t\tcase \"namedCurve\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"publicKey\":\n\t\t\t\t\treturn new ECPublicKey();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn memberValue === ECPrivateKey.defaultValues(memberName);\n\t\t\t\tcase \"privateKey\":\n\t\t\t\t\treturn memberValue.isEqual(ECPrivateKey.defaultValues(memberName));\n\t\t\t\tcase \"namedCurve\":\n\t\t\t\t\treturn memberValue === \"\";\n\t\t\t\tcase \"publicKey\":\n\t\t\t\t\treturn ECPublicKey.compareWithDefault(\"namedCurve\", memberValue.namedCurve) && ECPublicKey.compareWithDefault(\"x\", memberValue.x) && ECPublicKey.compareWithDefault(\"y\", memberValue.y);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// ECPrivateKey ::= SEQUENCE {\n\t\t\t// version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),\n\t\t\t// privateKey     OCTET STRING,\n\t\t\t// parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,\n\t\t\t// publicKey  [1] BIT STRING OPTIONAL\n\t\t\t// }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [version]\n    * @property {string} [privateKey]\n    * @property {string} [namedCurve]\n    * @property {string} [publicKey]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Integer({ name: names.version || \"\" }), new OctetString({ name: names.privateKey || \"\" }), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new ObjectIdentifier({ name: names.namedCurve || \"\" })]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new BitString({ name: names.publicKey || \"\" })]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"version\", \"privateKey\", \"namedCurve\", \"publicKey\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, ECPrivateKey.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tversion: \"version\",\n\t\t\t\t\tprivateKey: \"privateKey\",\n\t\t\t\t\tnamedCurve: \"namedCurve\",\n\t\t\t\t\tpublicKey: \"publicKey\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ECPrivateKey\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.version = asn1.result.version.valueBlock.valueDec;\n\t\t\tthis.privateKey = asn1.result.privateKey;\n\n\t\t\tif (\"namedCurve\" in asn1.result) this.namedCurve = asn1.result.namedCurve.valueBlock.toString();\n\n\t\t\tif (\"publicKey\" in asn1.result) {\n\t\t\t\tvar publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };\n\t\t\t\tif (\"namedCurve\" in this) publicKeyData.namedCurve = this.namedCurve;\n\n\t\t\t\tthis.publicKey = new ECPublicKey(publicKeyData);\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\tvar outputArray = [new Integer({ value: this.version }), this.privateKey];\n\n\t\t\tif (\"namedCurve\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new ObjectIdentifier({ value: this.namedCurve })]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"publicKey\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new BitString({ valueHex: this.publicKey.toSchema().toBER(false) })]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tif (\"namedCurve\" in this === false || ECPrivateKey.compareWithDefault(\"namedCurve\", this.namedCurve)) throw new Error(\"Not enough information for making JSON: absent \\\"namedCurve\\\" value\");\n\n\t\t\tvar crvName = \"\";\n\n\t\t\tswitch (this.namedCurve) {\n\t\t\t\tcase \"1.2.840.10045.3.1.7\":\n\t\t\t\t\t// P-256\n\t\t\t\t\tcrvName = \"P-256\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.34\":\n\t\t\t\t\t// P-384\n\t\t\t\t\tcrvName = \"P-384\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.132.0.35\":\n\t\t\t\t\t// P-521\n\t\t\t\t\tcrvName = \"P-521\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\tvar privateKeyJSON = {\n\t\t\t\tcrv: crvName,\n\t\t\t\td: toBase64(arrayBufferToString(this.privateKey.valueBlock.valueHex), true, true, false)\n\t\t\t};\n\n\t\t\tif (\"publicKey\" in this) {\n\t\t\t\tvar publicKeyJSON = this.publicKey.toJSON();\n\n\t\t\t\tprivateKeyJSON.x = publicKeyJSON.x;\n\t\t\t\tprivateKeyJSON.y = publicKeyJSON.y;\n\t\t\t}\n\n\t\t\treturn privateKeyJSON;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tvar coodinateLength = 0;\n\n\t\t\tif (\"crv\" in json) {\n\t\t\t\tswitch (json.crv.toUpperCase()) {\n\t\t\t\t\tcase \"P-256\":\n\t\t\t\t\t\tthis.namedCurve = \"1.2.840.10045.3.1.7\";\n\t\t\t\t\t\tcoodinateLength = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"P-384\":\n\t\t\t\t\t\tthis.namedCurve = \"1.3.132.0.34\";\n\t\t\t\t\t\tcoodinateLength = 48;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"P-521\":\n\t\t\t\t\t\tthis.namedCurve = \"1.3.132.0.35\";\n\t\t\t\t\t\tcoodinateLength = 66;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"crv\\\"\");\n\n\t\t\tif (\"d\" in json) {\n\t\t\t\tvar convertBuffer = stringToArrayBuffer(fromBase64(json.d, true));\n\n\t\t\t\tif (convertBuffer.byteLength < coodinateLength) {\n\t\t\t\t\tvar buffer = new ArrayBuffer(coodinateLength);\n\t\t\t\t\tvar view = new Uint8Array(buffer);\n\t\t\t\t\tvar convertBufferView = new Uint8Array(convertBuffer);\n\t\t\t\t\tview.set(convertBufferView, 1);\n\n\t\t\t\t\tthis.privateKey = new OctetString({ valueHex: buffer });\n\t\t\t\t} else this.privateKey = new OctetString({ valueHex: convertBuffer.slice(0, coodinateLength) });\n\t\t\t} else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n\n\t\t\tif (\"x\" in json && \"y\" in json) this.publicKey = new ECPublicKey({ json });\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC3447\n  */\n\tclass OtherPrimeInfo {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for OtherPrimeInfo class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Integer}\n    * @description prime\n    */\n\t\t\tthis.prime = getParametersValue(parameters, \"prime\", OtherPrimeInfo.defaultValues(\"prime\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description exponent\n    */\n\t\t\tthis.exponent = getParametersValue(parameters, \"exponent\", OtherPrimeInfo.defaultValues(\"exponent\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description coefficient\n    */\n\t\t\tthis.coefficient = getParametersValue(parameters, \"coefficient\", OtherPrimeInfo.defaultValues(\"coefficient\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"prime\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"exponent\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"coefficient\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for OtherPrimeInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//OtherPrimeInfo ::= Sequence {\n\t\t\t//    prime             Integer,  -- ri\n\t\t\t//    exponent          Integer,  -- di\n\t\t\t//    coefficient       Integer   -- ti\n\t\t\t//}\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} prime\n    * @property {string} exponent\n    * @property {string} coefficient\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Integer({ name: names.prime || \"\" }), new Integer({ name: names.exponent || \"\" }), new Integer({ name: names.coefficient || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"prime\", \"exponent\", \"coefficient\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, OtherPrimeInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tprime: \"prime\",\n\t\t\t\t\texponent: \"exponent\",\n\t\t\t\t\tcoefficient: \"coefficient\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for OtherPrimeInfo\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.prime = asn1.result.prime.convertFromDER();\n\t\t\tthis.exponent = asn1.result.exponent.convertFromDER();\n\t\t\tthis.coefficient = asn1.result.coefficient.convertFromDER();\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [this.prime.convertToDER(), this.exponent.convertToDER(), this.coefficient.convertToDER()]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tr: toBase64(arrayBufferToString(this.prime.valueBlock.valueHex), true, true),\n\t\t\t\td: toBase64(arrayBufferToString(this.exponent.valueBlock.valueHex), true, true),\n\t\t\t\tt: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true)\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tif (\"r\" in json) this.prime = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.r, true)) });else throw new Error(\"Absent mandatory parameter \\\"r\\\"\");\n\n\t\t\tif (\"d\" in json) this.exponent = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.d, true)) });else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n\n\t\t\tif (\"t\" in json) this.coefficient = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.t, true)) });else throw new Error(\"Absent mandatory parameter \\\"t\\\"\");\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC3447\n  */\n\tclass RSAPrivateKey {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for RSAPrivateKey class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {number}\n    * @description version\n    */\n\t\t\tthis.version = getParametersValue(parameters, \"version\", RSAPrivateKey.defaultValues(\"version\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description modulus\n    */\n\t\t\tthis.modulus = getParametersValue(parameters, \"modulus\", RSAPrivateKey.defaultValues(\"modulus\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description publicExponent\n    */\n\t\t\tthis.publicExponent = getParametersValue(parameters, \"publicExponent\", RSAPrivateKey.defaultValues(\"publicExponent\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description privateExponent\n    */\n\t\t\tthis.privateExponent = getParametersValue(parameters, \"privateExponent\", RSAPrivateKey.defaultValues(\"privateExponent\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description prime1\n    */\n\t\t\tthis.prime1 = getParametersValue(parameters, \"prime1\", RSAPrivateKey.defaultValues(\"prime1\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description prime2\n    */\n\t\t\tthis.prime2 = getParametersValue(parameters, \"prime2\", RSAPrivateKey.defaultValues(\"prime2\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description exponent1\n    */\n\t\t\tthis.exponent1 = getParametersValue(parameters, \"exponent1\", RSAPrivateKey.defaultValues(\"exponent1\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description exponent2\n    */\n\t\t\tthis.exponent2 = getParametersValue(parameters, \"exponent2\", RSAPrivateKey.defaultValues(\"exponent2\"));\n\t\t\t/**\n    * @type {Integer}\n    * @description coefficient\n    */\n\t\t\tthis.coefficient = getParametersValue(parameters, \"coefficient\", RSAPrivateKey.defaultValues(\"coefficient\"));\n\n\t\t\tif (\"otherPrimeInfos\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<OtherPrimeInfo>}\n     * @description otherPrimeInfos\n     */\n\t\t\t\tthis.otherPrimeInfos = getParametersValue(parameters, \"otherPrimeInfos\", RSAPrivateKey.defaultValues(\"otherPrimeInfos\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"modulus\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"publicExponent\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"privateExponent\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"prime1\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"prime2\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"exponent1\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"exponent2\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"coefficient\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tcase \"otherPrimeInfos\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for RSAPrivateKey class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//RSAPrivateKey ::= Sequence {\n\t\t\t//    version           Version,\n\t\t\t//    modulus           Integer,  -- n\n\t\t\t//    publicExponent    Integer,  -- e\n\t\t\t//    privateExponent   Integer,  -- d\n\t\t\t//    prime1            Integer,  -- p\n\t\t\t//    prime2            Integer,  -- q\n\t\t\t//    exponent1         Integer,  -- d mod (p-1)\n\t\t\t//    exponent2         Integer,  -- d mod (q-1)\n\t\t\t//    coefficient       Integer,  -- (inverse of q) mod p\n\t\t\t//    otherPrimeInfos   OtherPrimeInfos OPTIONAL\n\t\t\t//}\n\t\t\t//\n\t\t\t//OtherPrimeInfos ::= Sequence SIZE(1..MAX) OF OtherPrimeInfo\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [version]\n    * @property {string} [modulus]\n    * @property {string} [publicExponent]\n    * @property {string} [privateExponent]\n    * @property {string} [prime1]\n    * @property {string} [prime2]\n    * @property {string} [exponent1]\n    * @property {string} [exponent2]\n    * @property {string} [coefficient]\n    * @property {string} [otherPrimeInfosName]\n    * @property {Object} [otherPrimeInfo]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Integer({ name: names.version || \"\" }), new Integer({ name: names.modulus || \"\" }), new Integer({ name: names.publicExponent || \"\" }), new Integer({ name: names.privateExponent || \"\" }), new Integer({ name: names.prime1 || \"\" }), new Integer({ name: names.prime2 || \"\" }), new Integer({ name: names.exponent1 || \"\" }), new Integer({ name: names.exponent2 || \"\" }), new Integer({ name: names.coefficient || \"\" }), new Sequence({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.otherPrimeInfosName || \"\",\n\t\t\t\t\t\tvalue: OtherPrimeInfo.schema(names.otherPrimeInfo || {})\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"version\", \"modulus\", \"publicExponent\", \"privateExponent\", \"prime1\", \"prime2\", \"exponent1\", \"exponent2\", \"coefficient\", \"otherPrimeInfos\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, RSAPrivateKey.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tversion: \"version\",\n\t\t\t\t\tmodulus: \"modulus\",\n\t\t\t\t\tpublicExponent: \"publicExponent\",\n\t\t\t\t\tprivateExponent: \"privateExponent\",\n\t\t\t\t\tprime1: \"prime1\",\n\t\t\t\t\tprime2: \"prime2\",\n\t\t\t\t\texponent1: \"exponent1\",\n\t\t\t\t\texponent2: \"exponent2\",\n\t\t\t\t\tcoefficient: \"coefficient\",\n\t\t\t\t\totherPrimeInfo: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"otherPrimeInfos\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSAPrivateKey\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.version = asn1.result.version.valueBlock.valueDec;\n\t\t\tthis.modulus = asn1.result.modulus.convertFromDER(256);\n\t\t\tthis.publicExponent = asn1.result.publicExponent;\n\t\t\tthis.privateExponent = asn1.result.privateExponent.convertFromDER(256);\n\t\t\tthis.prime1 = asn1.result.prime1.convertFromDER(128);\n\t\t\tthis.prime2 = asn1.result.prime2.convertFromDER(128);\n\t\t\tthis.exponent1 = asn1.result.exponent1.convertFromDER(128);\n\t\t\tthis.exponent2 = asn1.result.exponent2.convertFromDER(128);\n\t\t\tthis.coefficient = asn1.result.coefficient.convertFromDER(128);\n\n\t\t\tif (\"otherPrimeInfos\" in asn1.result) this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new OtherPrimeInfo({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(new Integer({ value: this.version }));\n\t\t\toutputArray.push(this.modulus.convertToDER());\n\t\t\toutputArray.push(this.publicExponent);\n\t\t\toutputArray.push(this.privateExponent.convertToDER());\n\t\t\toutputArray.push(this.prime1.convertToDER());\n\t\t\toutputArray.push(this.prime2.convertToDER());\n\t\t\toutputArray.push(this.exponent1.convertToDER());\n\t\t\toutputArray.push(this.exponent2.convertToDER());\n\t\t\toutputArray.push(this.coefficient.convertToDER());\n\n\t\t\tif (\"otherPrimeInfos\" in this) {\n\t\t\t\toutputArray.push(new Sequence({\n\t\t\t\t\tvalue: Array.from(this.otherPrimeInfos, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar jwk = {\n\t\t\t\tn: toBase64(arrayBufferToString(this.modulus.valueBlock.valueHex), true, true, true),\n\t\t\t\te: toBase64(arrayBufferToString(this.publicExponent.valueBlock.valueHex), true, true, true),\n\t\t\t\td: toBase64(arrayBufferToString(this.privateExponent.valueBlock.valueHex), true, true, true),\n\t\t\t\tp: toBase64(arrayBufferToString(this.prime1.valueBlock.valueHex), true, true, true),\n\t\t\t\tq: toBase64(arrayBufferToString(this.prime2.valueBlock.valueHex), true, true, true),\n\t\t\t\tdp: toBase64(arrayBufferToString(this.exponent1.valueBlock.valueHex), true, true, true),\n\t\t\t\tdq: toBase64(arrayBufferToString(this.exponent2.valueBlock.valueHex), true, true, true),\n\t\t\t\tqi: toBase64(arrayBufferToString(this.coefficient.valueBlock.valueHex), true, true, true)\n\t\t\t};\n\n\t\t\tif (\"otherPrimeInfos\" in this) jwk.oth = Array.from(this.otherPrimeInfos, element => element.toJSON());\n\n\t\t\treturn jwk;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tif (\"n\" in json) this.modulus = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.n, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"n\\\"\");\n\n\t\t\tif (\"e\" in json) this.publicExponent = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.e, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"e\\\"\");\n\n\t\t\tif (\"d\" in json) this.privateExponent = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.d, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"d\\\"\");\n\n\t\t\tif (\"p\" in json) this.prime1 = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.p, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"p\\\"\");\n\n\t\t\tif (\"q\" in json) this.prime2 = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.q, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"q\\\"\");\n\n\t\t\tif (\"dp\" in json) this.exponent1 = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.dp, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"dp\\\"\");\n\n\t\t\tif (\"dq\" in json) this.exponent2 = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.dq, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"dq\\\"\");\n\n\t\t\tif (\"qi\" in json) this.coefficient = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.qi, true, true)) });else throw new Error(\"Absent mandatory parameter \\\"qi\\\"\");\n\n\t\t\tif (\"oth\" in json) this.otherPrimeInfos = Array.from(json.oth, element => new OtherPrimeInfo({ json: element }));\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5208\n  */\n\tclass PrivateKeyInfo {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PrivateKeyInfo class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {number}\n    * @description version\n    */\n\t\t\tthis.version = getParametersValue(parameters, \"version\", PrivateKeyInfo.defaultValues(\"version\"));\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description privateKeyAlgorithm\n    */\n\t\t\tthis.privateKeyAlgorithm = getParametersValue(parameters, \"privateKeyAlgorithm\", PrivateKeyInfo.defaultValues(\"privateKeyAlgorithm\"));\n\t\t\t/**\n    * @type {OctetString}\n    * @description privateKey\n    */\n\t\t\tthis.privateKey = getParametersValue(parameters, \"privateKey\", PrivateKeyInfo.defaultValues(\"privateKey\"));\n\n\t\t\tif (\"attributes\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<Attribute>}\n     * @description attributes\n     */\n\t\t\t\tthis.attributes = getParametersValue(parameters, \"attributes\", PrivateKeyInfo.defaultValues(\"attributes\"));\n\n\t\t\tif (\"parsedKey\" in parameters)\n\t\t\t\t/**\n     * @type {ECPrivateKey|RSAPrivateKey}\n     * @description Parsed public key value\n     */\n\t\t\t\tthis.parsedKey = getParametersValue(parameters, \"parsedKey\", PrivateKeyInfo.defaultValues(\"parsedKey\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t\t//region If input argument array contains \"json\" for this object\n\t\t\tif (\"json\" in parameters) this.fromJSON(parameters.json);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"privateKeyAlgorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tcase \"privateKey\":\n\t\t\t\t\treturn new OctetString();\n\t\t\t\tcase \"attributes\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"parsedKey\":\n\t\t\t\t\treturn {};\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PrivateKeyInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PrivateKeyInfo ::= SEQUENCE {\n\t\t\t//    version Version,\n\t\t\t//    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},\n\t\t\t//    privateKey PrivateKey,\n\t\t\t//    attributes [0] Attributes OPTIONAL }\n\t\t\t//\n\t\t\t//Version ::= INTEGER {v1(0)} (v1,...)\n\t\t\t//\n\t\t\t//PrivateKey ::= OCTET STRING\n\t\t\t//\n\t\t\t//Attributes ::= SET OF Attribute\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [version]\n    * @property {string} [privateKeyAlgorithm]\n    * @property {string} [privateKey]\n    * @property {string} [attributes]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Integer({ name: names.version || \"\" }), AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}), new OctetString({ name: names.privateKey || \"\" }), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.attributes || \"\",\n\t\t\t\t\t\tvalue: Attribute.schema()\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"version\", \"privateKeyAlgorithm\", \"privateKey\", \"attributes\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PrivateKeyInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tversion: \"version\",\n\t\t\t\t\tprivateKeyAlgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"privateKeyAlgorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tprivateKey: \"privateKey\",\n\t\t\t\t\tattributes: \"attributes\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PrivateKeyInfo\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.version = asn1.result.version.valueBlock.valueDec;\n\t\t\tthis.privateKeyAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.privateKeyAlgorithm });\n\t\t\tthis.privateKey = asn1.result.privateKey;\n\n\t\t\tif (\"attributes\" in asn1.result) this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));\n\n\t\t\tswitch (this.privateKeyAlgorithm.algorithmId) {\n\t\t\t\tcase \"1.2.840.113549.1.1.1\":\n\t\t\t\t\t// RSA\n\t\t\t\t\t{\n\t\t\t\t\t\tvar privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHex);\n\t\t\t\t\t\tif (privateKeyASN1.offset !== -1) this.parsedKey = new RSAPrivateKey({ schema: privateKeyASN1.result });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.10045.2.1\":\n\t\t\t\t\t// ECDSA\n\t\t\t\t\tif (\"algorithmParams\" in this.privateKeyAlgorithm) {\n\t\t\t\t\t\tif (this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier) {\n\t\t\t\t\t\t\tvar _privateKeyASN = fromBER(this.privateKey.valueBlock.valueHex);\n\t\t\t\t\t\t\tif (_privateKeyASN.offset !== -1) {\n\t\t\t\t\t\t\t\tthis.parsedKey = new ECPrivateKey({\n\t\t\t\t\t\t\t\t\tnamedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),\n\t\t\t\t\t\t\t\t\tschema: _privateKeyASN.result\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [new Integer({ value: this.version }), this.privateKeyAlgorithm.toSchema(), this.privateKey];\n\n\t\t\tif (\"attributes\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: Array.from(this.attributes, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\t//region Return common value in case we do not have enough info fo making JWK\n\t\t\tif (\"parsedKey\" in this === false) {\n\t\t\t\tvar object = {\n\t\t\t\t\tversion: this.version,\n\t\t\t\t\tprivateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),\n\t\t\t\t\tprivateKey: this.privateKey.toJSON()\n\t\t\t\t};\n\n\t\t\t\tif (\"attributes\" in this) object.attributes = Array.from(this.attributes, element => element.toJSON());\n\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Making JWK\n\t\t\tvar jwk = {};\n\n\t\t\tswitch (this.privateKeyAlgorithm.algorithmId) {\n\t\t\t\tcase \"1.2.840.10045.2.1\":\n\t\t\t\t\t// ECDSA\n\t\t\t\t\tjwk.kty = \"EC\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.113549.1.1.1\":\n\t\t\t\t\t// RSA\n\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\tvar publicKeyJWK = this.parsedKey.toJSON();\n\n\t\t\tvar _iteratorNormalCompletion9 = true;\n\t\t\tvar _didIteratorError9 = false;\n\t\t\tvar _iteratorError9 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator9 = Object.keys(publicKeyJWK)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t\t\t\t\tvar key = _step9.value;\n\n\t\t\t\t\tjwk[key] = publicKeyJWK[key];\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError9 = true;\n\t\t\t\t_iteratorError9 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t\t\t\t\t\t_iterator9.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError9) {\n\t\t\t\t\t\tthrow _iteratorError9;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jwk;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\t\tfromJSON(json) {\n\t\t\tif (\"kty\" in json) {\n\t\t\t\tswitch (json.kty.toUpperCase()) {\n\t\t\t\t\tcase \"EC\":\n\t\t\t\t\t\tthis.parsedKey = new ECPrivateKey({ json });\n\n\t\t\t\t\t\tthis.privateKeyAlgorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\talgorithmId: \"1.2.840.10045.2.1\",\n\t\t\t\t\t\t\talgorithmParams: new ObjectIdentifier({ value: this.parsedKey.namedCurve })\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"RSA\":\n\t\t\t\t\t\tthis.parsedKey = new RSAPrivateKey({ json });\n\n\t\t\t\t\t\tthis.privateKeyAlgorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.1\",\n\t\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n\t\t\t\t}\n\n\t\t\t\tthis.privateKey = new OctetString({ valueHex: this.parsedKey.toSchema().toBER(false) });\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5652\n  */\n\tclass EncryptedContentInfo {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for EncryptedContentInfo class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description contentType\n    */\n\t\t\tthis.contentType = getParametersValue(parameters, \"contentType\", EncryptedContentInfo.defaultValues(\"contentType\"));\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description contentEncryptionAlgorithm\n    */\n\t\t\tthis.contentEncryptionAlgorithm = getParametersValue(parameters, \"contentEncryptionAlgorithm\", EncryptedContentInfo.defaultValues(\"contentEncryptionAlgorithm\"));\n\n\t\t\tif (\"encryptedContent\" in parameters) {\n\t\t\t\t/**\n     * @type {OctetString}\n     * @description encryptedContent (!!!) could be contructive or primitive value (!!!)\n     */\n\t\t\t\tthis.encryptedContent = parameters.encryptedContent;\n\n\t\t\t\tif (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {\n\t\t\t\t\t//region Divide OCTETSTRING value down to small pieces\n\t\t\t\t\tif (this.encryptedContent.idBlock.isConstructed === false) {\n\t\t\t\t\t\tvar constrString = new OctetString({\n\t\t\t\t\t\t\tidBlock: { isConstructed: true },\n\t\t\t\t\t\t\tisConstructed: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tvar offset = 0;\n\t\t\t\t\t\tvar length = this.encryptedContent.valueBlock.valueHex.byteLength;\n\n\t\t\t\t\t\twhile (length > 0) {\n\t\t\t\t\t\t\tvar pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, offset + 1024 > this.encryptedContent.valueBlock.valueHex.byteLength ? this.encryptedContent.valueBlock.valueHex.byteLength - offset : 1024);\n\t\t\t\t\t\t\tvar _array = new ArrayBuffer(pieceView.length);\n\t\t\t\t\t\t\tvar _view = new Uint8Array(_array);\n\n\t\t\t\t\t\t\tfor (var i = 0; i < _view.length; i++) {\n\t\t\t\t\t\t\t\t_view[i] = pieceView[i];\n\t\t\t\t\t\t\t}constrString.valueBlock.value.push(new OctetString({ valueHex: _array }));\n\n\t\t\t\t\t\t\tlength -= pieceView.length;\n\t\t\t\t\t\t\toffset += pieceView.length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.encryptedContent = constrString;\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"contentType\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"contentEncryptionAlgorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tcase \"encryptedContent\":\n\t\t\t\t\treturn new OctetString();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"contentType\":\n\t\t\t\t\treturn memberValue === \"\";\n\t\t\t\tcase \"contentEncryptionAlgorithm\":\n\t\t\t\t\treturn memberValue.algorithmId === \"\" && \"algorithmParams\" in memberValue === false;\n\t\t\t\tcase \"encryptedContent\":\n\t\t\t\t\treturn memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName));\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//EncryptedContentInfo ::= SEQUENCE {\n\t\t\t//    contentType ContentType,\n\t\t\t//    contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n\t\t\t//    encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }\n\t\t\t//\n\t\t\t// Comment: Strange, but modern crypto engines create \"encryptedContent\" as \"[0] EXPLICIT EncryptedContent\"\n\t\t\t//\n\t\t\t//EncryptedContent ::= OCTET STRING\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [contentType]\n    * @property {string} [contentEncryptionAlgorithm]\n    * @property {string} [encryptedContent]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.contentType || \"\" }), AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}),\n\t\t\t\t// The CHOICE we need because \"EncryptedContent\" could have either \"constructive\"\n\t\t\t\t// or \"primitive\" form of encoding and we need to handle both variants\n\t\t\t\tnew Choice({\n\t\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\t\tname: names.encryptedContent || \"\",\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\t\tvalue: new OctetString()\n\t\t\t\t\t\t})]\n\t\t\t\t\t}), new Primitive({\n\t\t\t\t\t\tname: names.encryptedContent || \"\",\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t}\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"contentType\", \"contentEncryptionAlgorithm\", \"encryptedContent\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, EncryptedContentInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tcontentType: \"contentType\",\n\t\t\t\t\tcontentEncryptionAlgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"contentEncryptionAlgorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tencryptedContent: \"encryptedContent\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EncryptedContentInfo\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.contentType = asn1.result.contentType.valueBlock.toString();\n\t\t\tthis.contentEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.contentEncryptionAlgorithm });\n\n\t\t\tif (\"encryptedContent\" in asn1.result) {\n\t\t\t\tthis.encryptedContent = asn1.result.encryptedContent;\n\n\t\t\t\tthis.encryptedContent.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\t\tthis.encryptedContent.idBlock.tagNumber = 4; // OCTETSTRING (!!!) The value still has instance of \"in_window.org.pkijs.asn1.ASN1_CONSTRUCTED / ASN1_PRIMITIVE\"\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar sequenceLengthBlock = {\n\t\t\t\tisIndefiniteForm: false\n\t\t\t};\n\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(new ObjectIdentifier({ value: this.contentType }));\n\t\t\toutputArray.push(this.contentEncryptionAlgorithm.toSchema());\n\n\t\t\tif (\"encryptedContent\" in this) {\n\t\t\t\tsequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;\n\n\t\t\t\tvar encryptedValue = this.encryptedContent;\n\n\t\t\t\tencryptedValue.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\t\t\t\tencryptedValue.idBlock.tagNumber = 0; // [0]\n\n\t\t\t\tencryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;\n\n\t\t\t\toutputArray.push(encryptedValue);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tlenBlock: sequenceLengthBlock,\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar _object = {\n\t\t\t\tcontentType: this.contentType,\n\t\t\t\tcontentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()\n\t\t\t};\n\n\t\t\tif (\"encryptedContent\" in this) _object.encryptedContent = this.encryptedContent.toJSON();\n\n\t\t\treturn _object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC4055\n  */\n\tclass RSASSAPSSParams {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for RSASSAPSSParams class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description Algorithms of hashing (DEFAULT sha1)\n    */\n\t\t\tthis.hashAlgorithm = getParametersValue(parameters, \"hashAlgorithm\", RSASSAPSSParams.defaultValues(\"hashAlgorithm\"));\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description Algorithm of \"mask generaion function (MGF)\" (DEFAULT mgf1SHA1)\n    */\n\t\t\tthis.maskGenAlgorithm = getParametersValue(parameters, \"maskGenAlgorithm\", RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"));\n\t\t\t/**\n    * @type {number}\n    * @description Salt length (DEFAULT 20)\n    */\n\t\t\tthis.saltLength = getParametersValue(parameters, \"saltLength\", RSASSAPSSParams.defaultValues(\"saltLength\"));\n\t\t\t/**\n    * @type {number}\n    * @description (DEFAULT 1)\n    */\n\t\t\tthis.trailerField = getParametersValue(parameters, \"trailerField\", RSASSAPSSParams.defaultValues(\"trailerField\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"hashAlgorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.3.14.3.2.26\", // SHA-1\n\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t});\n\t\t\t\tcase \"maskGenAlgorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.8\", // MGF1\n\t\t\t\t\t\talgorithmParams: new AlgorithmIdentifier({\n\t\t\t\t\t\t\talgorithmId: \"1.3.14.3.2.26\", // SHA-1\n\t\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t\t}).toSchema()\n\t\t\t\t\t});\n\t\t\t\tcase \"saltLength\":\n\t\t\t\t\treturn 20;\n\t\t\t\tcase \"trailerField\":\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for RSASSAPSSParams class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//RSASSA-PSS-params  ::=  Sequence  {\n\t\t\t//    hashAlgorithm      [0] HashAlgorithm DEFAULT sha1Identifier,\n\t\t\t//    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,\n\t\t\t//    saltLength         [2] Integer DEFAULT 20,\n\t\t\t//    trailerField       [3] Integer DEFAULT 1  }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [hashAlgorithm]\n    * @property {string} [maskGenAlgorithm]\n    * @property {string} [saltLength]\n    * @property {string} [trailerField]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [new Integer({ name: names.saltLength || \"\" })]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t},\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [new Integer({ name: names.trailerField || \"\" })]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"hashAlgorithm\", \"maskGenAlgorithm\", \"saltLength\", \"trailerField\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, RSASSAPSSParams.schema({\n\t\t\t\tnames: {\n\t\t\t\t\thashAlgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"hashAlgorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmaskGenAlgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"maskGenAlgorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsaltLength: \"saltLength\",\n\t\t\t\t\ttrailerField: \"trailerField\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RSASSAPSSParams\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"hashAlgorithm\" in asn1.result) this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });\n\n\t\t\tif (\"maskGenAlgorithm\" in asn1.result) this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });\n\n\t\t\tif (\"saltLength\" in asn1.result) this.saltLength = asn1.result.saltLength.valueBlock.valueDec;\n\n\t\t\tif (\"trailerField\" in asn1.result) this.trailerField = asn1.result.trailerField.valueBlock.valueDec;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"hashAlgorithm\"))) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [this.hashAlgorithm.toSchema()]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"))) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [this.maskGenAlgorithm.toSchema()]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (this.saltLength !== RSASSAPSSParams.defaultValues(\"saltLength\")) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Integer({ value: this.saltLength })]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (this.trailerField !== RSASSAPSSParams.defaultValues(\"trailerField\")) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Integer({ value: this.trailerField })]\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"hashAlgorithm\"))) object.hashAlgorithm = this.hashAlgorithm.toJSON();\n\n\t\t\tif (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(\"maskGenAlgorithm\"))) object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();\n\n\t\t\tif (this.saltLength !== RSASSAPSSParams.defaultValues(\"saltLength\")) object.saltLength = this.saltLength;\n\n\t\t\tif (this.trailerField !== RSASSAPSSParams.defaultValues(\"trailerField\")) object.trailerField = this.trailerField;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC2898\n  */\n\tclass PBKDF2Params {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PBKDF2Params class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Object}\n    * @description salt\n    */\n\t\t\tthis.salt = getParametersValue(parameters, \"salt\", PBKDF2Params.defaultValues(\"salt\"));\n\t\t\t/**\n    * @type {number}\n    * @description iterationCount\n    */\n\t\t\tthis.iterationCount = getParametersValue(parameters, \"iterationCount\", PBKDF2Params.defaultValues(\"iterationCount\"));\n\n\t\t\tif (\"keyLength\" in parameters)\n\t\t\t\t/**\n     * @type {number}\n     * @description keyLength\n     */\n\t\t\t\tthis.keyLength = getParametersValue(parameters, \"keyLength\", PBKDF2Params.defaultValues(\"keyLength\"));\n\n\t\t\tif (\"prf\" in parameters)\n\t\t\t\t/**\n     * @type {AlgorithmIdentifier}\n     * @description prf\n     */\n\t\t\t\tthis.prf = getParametersValue(parameters, \"prf\", PBKDF2Params.defaultValues(\"prf\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"salt\":\n\t\t\t\t\treturn {};\n\t\t\t\tcase \"iterationCount\":\n\t\t\t\t\treturn -1;\n\t\t\t\tcase \"keyLength\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"prf\":\n\t\t\t\t\treturn new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.3.14.3.2.26\", // SHA-1\n\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PBKDF2Params class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PBKDF2-params ::= SEQUENCE {\n\t\t\t//    salt CHOICE {\n\t\t\t//        specified OCTET STRING,\n\t\t\t//        otherSource AlgorithmIdentifier },\n\t\t\t//  iterationCount INTEGER (1..MAX),\n\t\t\t//  keyLength INTEGER (1..MAX) OPTIONAL,\n\t\t\t//  prf AlgorithmIdentifier\n\t\t\t//    DEFAULT { algorithm hMAC-SHA1, parameters NULL } }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [saltPrimitive]\n    * @property {string} [saltConstructed]\n    * @property {string} [iterationCount]\n    * @property {string} [keyLength]\n    * @property {string} [prf]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Choice({\n\t\t\t\t\tvalue: [new OctetString({ name: names.saltPrimitive || \"\" }), AlgorithmIdentifier.schema(names.saltConstructed || {})]\n\t\t\t\t}), new Integer({ name: names.iterationCount || \"\" }), new Integer({\n\t\t\t\t\tname: names.keyLength || \"\",\n\t\t\t\t\toptional: true\n\t\t\t\t}), AlgorithmIdentifier.schema(names.prf || {\n\t\t\t\t\tnames: {\n\t\t\t\t\t\toptional: true\n\t\t\t\t\t}\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"salt\", \"iterationCount\", \"keyLength\", \"prf\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PBKDF2Params.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tsaltPrimitive: \"salt\",\n\t\t\t\t\tsaltConstructed: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"salt\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\titerationCount: \"iterationCount\",\n\t\t\t\t\tkeyLength: \"keyLength\",\n\t\t\t\t\tprf: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"prf\",\n\t\t\t\t\t\t\toptional: true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PBKDF2Params\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.salt = asn1.result.salt;\n\t\t\tthis.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;\n\n\t\t\tif (\"keyLength\" in asn1.result) this.keyLength = asn1.result.keyLength.valueBlock.valueDec;\n\n\t\t\tif (\"prf\" in asn1.result) this.prf = new AlgorithmIdentifier({ schema: asn1.result.prf });\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence \n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(this.salt);\n\t\t\toutputArray.push(new Integer({ value: this.iterationCount }));\n\n\t\t\tif (\"keyLength\" in this) {\n\t\t\t\tif (PBKDF2Params.defaultValues(\"keyLength\") !== this.keyLength) outputArray.push(new Integer({ value: this.keyLength }));\n\t\t\t}\n\n\t\t\tif (\"prf\" in this) {\n\t\t\t\tif (PBKDF2Params.defaultValues(\"prf\").isEqual(this.prf) === false) outputArray.push(this.prf.toSchema());\n\t\t\t}\n\t\t\t//endregion \n\n\t\t\t//region Construct and return new ASN.1 schema for this object \n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion \n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar _object = {\n\t\t\t\tsalt: this.salt.toJSON(),\n\t\t\t\titerationCount: this.iterationCount\n\t\t\t};\n\n\t\t\tif (\"keyLength\" in this) {\n\t\t\t\tif (PBKDF2Params.defaultValues(\"keyLength\") !== this.keyLength) _object.keyLength = this.keyLength;\n\t\t\t}\n\n\t\t\tif (\"prf\" in this) {\n\t\t\t\tif (PBKDF2Params.defaultValues(\"prf\").isEqual(this.prf) === false) _object.prf = this.prf.toJSON();\n\t\t\t}\n\n\t\t\treturn _object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC2898\n  */\n\tclass PBES2Params {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PBES2Params class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description keyDerivationFunc\n    */\n\t\t\tthis.keyDerivationFunc = getParametersValue(parameters, \"keyDerivationFunc\", PBES2Params.defaultValues(\"keyDerivationFunc\"));\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description encryptionScheme\n    */\n\t\t\tthis.encryptionScheme = getParametersValue(parameters, \"encryptionScheme\", PBES2Params.defaultValues(\"encryptionScheme\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"keyDerivationFunc\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tcase \"encryptionScheme\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PBES2Params class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PBES2-params ::= SEQUENCE {\n\t\t\t//    keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\n\t\t\t//    encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [keyDerivationFunc]\n    * @property {string} [encryptionScheme]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [AlgorithmIdentifier.schema(names.keyDerivationFunc || {}), AlgorithmIdentifier.schema(names.encryptionScheme || {})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"keyDerivationFunc\", \"encryptionScheme\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PBES2Params.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tkeyDerivationFunc: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"keyDerivationFunc\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tencryptionScheme: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"encryptionScheme\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PBES2Params\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.keyDerivationFunc = new AlgorithmIdentifier({ schema: asn1.result.keyDerivationFunc });\n\t\t\tthis.encryptionScheme = new AlgorithmIdentifier({ schema: asn1.result.encryptionScheme });\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [this.keyDerivationFunc.toSchema(), this.encryptionScheme.toSchema()]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tkeyDerivationFunc: this.keyDerivationFunc.toJSON(),\n\t\t\t\tencryptionScheme: this.encryptionScheme.toJSON()\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Making MAC key using algorithm described in B.2 of PKCS#12 standard.\n  */\n\tfunction makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {\n\t\t//region Initial variables\n\t\tvar u = void 0;\n\t\tvar v = void 0;\n\n\t\tvar result = [];\n\t\t//endregion\n\n\t\t//region Get \"u\" and \"v\" values\n\t\tswitch (hashAlgorithm.toUpperCase()) {\n\t\t\tcase \"SHA-1\":\n\t\t\t\tu = 20; // 160\n\t\t\t\tv = 64; // 512\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-256\":\n\t\t\t\tu = 32; // 256\n\t\t\t\tv = 64; // 512\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-384\":\n\t\t\t\tu = 48; // 384\n\t\t\t\tv = 128; // 1024\n\t\t\t\tbreak;\n\t\t\tcase \"SHA-512\":\n\t\t\t\tu = 64; // 512\n\t\t\t\tv = 128; // 1024\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported hashing algorithm\");\n\t\t}\n\t\t//endregion\n\n\t\t//region Main algorithm making key\n\t\t//region Transform password to UTF-8 like string\n\t\tvar passwordViewInitial = new Uint8Array(password);\n\n\t\tvar passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);\n\t\tvar passwordTransformedView = new Uint8Array(passwordTransformed);\n\n\t\tfor (var i = 0; i < passwordViewInitial.length; i++) {\n\t\t\tpasswordTransformedView[i * 2] = 0x00;\n\t\t\tpasswordTransformedView[i * 2 + 1] = passwordViewInitial[i];\n\t\t}\n\n\t\tpasswordTransformedView[passwordTransformedView.length - 2] = 0x00;\n\t\tpasswordTransformedView[passwordTransformedView.length - 1] = 0x00;\n\n\t\tpassword = passwordTransformed.slice(0);\n\t\t//endregion\n\n\t\t//region Construct a string D (the \"diversifier\") by concatenating v/8 copies of ID\n\t\tvar D = new ArrayBuffer(v);\n\t\tvar dView = new Uint8Array(D);\n\n\t\tfor (var _i13 = 0; _i13 < D.byteLength; _i13++) {\n\t\t\tdView[_i13] = 3;\n\t\t} // The ID value equal to \"3\" for MACing (see B.3 of standard)\n\t\t//endregion\n\n\t\t//region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)\n\t\tvar saltLength = salt.byteLength;\n\n\t\tvar sLen = v * Math.ceil(saltLength / v);\n\t\tvar S = new ArrayBuffer(sLen);\n\t\tvar sView = new Uint8Array(S);\n\n\t\tvar saltView = new Uint8Array(salt);\n\n\t\tfor (var _i14 = 0; _i14 < sLen; _i14++) {\n\t\t\tsView[_i14] = saltView[_i14 % saltLength];\n\t\t} //endregion\n\n\t\t//region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)\n\t\tvar passwordLength = password.byteLength;\n\n\t\tvar pLen = v * Math.ceil(passwordLength / v);\n\t\tvar P = new ArrayBuffer(pLen);\n\t\tvar pView = new Uint8Array(P);\n\n\t\tvar passwordView = new Uint8Array(password);\n\n\t\tfor (var _i15 = 0; _i15 < pLen; _i15++) {\n\t\t\tpView[_i15] = passwordView[_i15 % passwordLength];\n\t\t} //endregion\n\n\t\t//region Set I=S||P to be the concatenation of S and P\n\t\tvar sPlusPLength = S.byteLength + P.byteLength;\n\n\t\tvar I = new ArrayBuffer(sPlusPLength);\n\t\tvar iView = new Uint8Array(I);\n\n\t\tiView.set(sView);\n\t\tiView.set(pView, sView.length);\n\t\t//endregion\n\n\t\t//region Set c=ceil(n / u)\n\t\tvar c = Math.ceil((keyLength >> 3) / u);\n\t\t//endregion\n\n\t\t//region Initial variables\n\t\tvar internalSequence = Promise.resolve(I);\n\t\t//endregion\n\n\t\t//region For i=1, 2, ..., c, do the following:\n\t\tfor (var _i16 = 0; _i16 <= c; _i16++) {\n\t\t\tinternalSequence = internalSequence.then(_I => {\n\t\t\t\t//region Create contecanetion of D and I\n\t\t\t\tvar dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);\n\t\t\t\tvar dAndIView = new Uint8Array(dAndI);\n\n\t\t\t\tdAndIView.set(dView);\n\t\t\t\tdAndIView.set(iView, dView.length);\n\t\t\t\t//endregion\n\n\t\t\t\treturn dAndI;\n\t\t\t});\n\n\t\t\t//region Make \"iterationCount\" rounds of hashing\n\t\t\tfor (var j = 0; j < iterationCount; j++) {\n\t\t\t\tinternalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));\n\t\t\t} //endregion\n\n\t\t\tinternalSequence = internalSequence.then(roundBuffer => {\n\t\t\t\t//region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)\n\t\t\t\tvar B = new ArrayBuffer(v);\n\t\t\t\tvar bView = new Uint8Array(B);\n\n\t\t\t\tfor (var _j = 0; _j < B.byteLength; _j++) {\n\t\t\t\t\tbView[_j] = roundBuffer[_j % roundBuffer.length];\n\t\t\t\t} //endregion\n\n\t\t\t\t//region Make new I value\n\t\t\t\tvar k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);\n\t\t\t\tvar iRound = [];\n\n\t\t\t\tvar sliceStart = 0;\n\t\t\t\tvar sliceLength = v;\n\n\t\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\t\tvar chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));\n\t\t\t\t\tsliceStart += v;\n\t\t\t\t\tif (sliceStart + v > I.byteLength) sliceLength = I.byteLength - sliceStart;\n\n\t\t\t\t\tvar x = 0x1ff;\n\n\t\t\t\t\tfor (var l = B.byteLength - 1; l >= 0; l--) {\n\t\t\t\t\t\tx >>= 8;\n\t\t\t\t\t\tx += bView[l] + chunk[l];\n\t\t\t\t\t\tchunk[l] = x & 0xff;\n\t\t\t\t\t}\n\n\t\t\t\t\tiRound.push(...chunk);\n\t\t\t\t}\n\n\t\t\t\tI = new ArrayBuffer(iRound.length);\n\t\t\t\tiView = new Uint8Array(I);\n\n\t\t\t\tiView.set(iRound);\n\t\t\t\t//endregion\n\n\t\t\t\tresult.push(...new Uint8Array(roundBuffer));\n\n\t\t\t\treturn I;\n\t\t\t});\n\t\t}\n\t\t//endregion\n\n\t\t//region Initialize final key\n\t\tinternalSequence = internalSequence.then(() => {\n\t\t\tvar resultBuffer = new ArrayBuffer(keyLength >> 3);\n\t\t\tvar resultView = new Uint8Array(resultBuffer);\n\n\t\t\tresultView.set(new Uint8Array(result).slice(0, keyLength >> 3));\n\n\t\t\treturn resultBuffer;\n\t\t});\n\t\t//endregion\n\t\t//endregion\n\n\t\treturn internalSequence;\n\t}\n\t//**************************************************************************************\n\t/**\n  * Default cryptographic engine for Web Cryptography API\n  */\n\tclass CryptoEngine {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for CryptoEngine class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Object}\n    * @description Usually here we are expecting \"window.crypto\" or an equivalent from custom \"crypto engine\"\n    */\n\t\t\tthis.crypto = getParametersValue(parameters, \"crypto\", {});\n\t\t\t/**\n    * @type {Object}\n    * @description Usually here we are expecting \"window.crypto.subtle\" or an equivalent from custom \"crypto engine\"\n    */\n\t\t\tthis.subtle = getParametersValue(parameters, \"subtle\", {});\n\t\t\t/**\n    * @type {string}\n    * @description Name of the \"crypto engine\"\n    */\n\t\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Import WebCrypto keys from different formats\n   * @param {string} format\n   * @param {ArrayBuffer|Uint8Array} keyData\n   * @param {Object} algorithm\n   * @param {boolean} extractable\n   * @param {Array} keyUsages\n   * @returns {Promise}\n   */\n\t\timportKey(format, keyData, algorithm, extractable, keyUsages) {\n\t\t\t//region Initial variables\n\t\t\tvar jwk = {};\n\t\t\t//endregion\n\n\t\t\t//region Change \"keyData\" type if needed\n\t\t\tif (keyData instanceof Uint8Array) keyData = keyData.buffer;\n\t\t\t//endregion\n\n\t\t\tswitch (format.toLowerCase()) {\n\t\t\t\tcase \"raw\":\n\t\t\t\t\treturn this.subtle.importKey(\"raw\", keyData, algorithm, extractable, keyUsages);\n\t\t\t\tcase \"spki\":\n\t\t\t\t\t{\n\t\t\t\t\t\tvar asn1 = fromBER(keyData);\n\t\t\t\t\t\tif (asn1.offset === -1) return Promise.reject(\"Incorrect keyData\");\n\n\t\t\t\t\t\tvar publicKeyInfo = new PublicKeyInfo();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpublicKeyInfo.fromSchema(asn1.result);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\treturn Promise.reject(\"Incorrect keyData\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// noinspection FallThroughInSwitchStatementJS\n\t\t\t\t\t\tswitch (algorithm.name.toUpperCase()) {\n\t\t\t\t\t\t\tcase \"RSA-PSS\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS1\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS256\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS384\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS512\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// break omitted\n\t\t\t\t\t\t\tcase \"RSASSA-PKCS1-V1_5\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tkeyUsages = [\"verify\"]; // Override existing keyUsages value since the key is a public key\n\n\t\t\t\t\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\t\t\t\t\tjwk.ext = extractable;\n\t\t\t\t\t\t\t\t\tjwk.key_ops = keyUsages;\n\n\t\t\t\t\t\t\t\t\tif (publicKeyInfo.algorithm.algorithmId !== \"1.2.840.113549.1.1.1\") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);\n\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tif (\"alg\" in jwk === false) {\n\t\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS1\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS256\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS384\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS512\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Create RSA Public Key elements\n\t\t\t\t\t\t\t\t\tvar publicKeyJSON = publicKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion10 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError10 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError10 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator10 = Object.keys(publicKeyJSON)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar key = _step10.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[key] = publicKeyJSON[key];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError10 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError10 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator10.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError10) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError10;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"ECDSA\":\n\t\t\t\t\t\t\t\tkeyUsages = [\"verify\"]; // Override existing keyUsages value since the key is a public key\n\t\t\t\t\t\t\t// break omitted\n\t\t\t\t\t\t\tcase \"ECDH\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//region Initial variables\n\t\t\t\t\t\t\t\t\tjwk = {\n\t\t\t\t\t\t\t\t\t\tkty: \"EC\",\n\t\t\t\t\t\t\t\t\t\text: extractable,\n\t\t\t\t\t\t\t\t\t\tkey_ops: keyUsages\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Get information about algorithm\n\t\t\t\t\t\t\t\t\tif (publicKeyInfo.algorithm.algorithmId !== \"1.2.840.10045.2.1\") return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Create ECDSA Public Key elements\n\t\t\t\t\t\t\t\t\tvar _publicKeyJSON = publicKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion11 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError11 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError11 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator11 = Object.keys(_publicKeyJSON)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar _key3 = _step11.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[_key3] = _publicKeyJSON[_key3];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError11 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError11 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion11 && _iterator11.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator11.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError11) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError11;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"RSA-OAEP\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\t\t\t\t\tjwk.ext = extractable;\n\t\t\t\t\t\t\t\t\tjwk.key_ops = keyUsages;\n\n\t\t\t\t\t\t\t\t\tif (this.name.toLowerCase() === \"safari\") jwk.alg = \"RSA-OAEP\";else {\n\t\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-256\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-384\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-512\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//region Create ECDSA Public Key elements\n\t\t\t\t\t\t\t\t\tvar _publicKeyJSON2 = publicKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion12 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError12 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError12 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator12 = Object.keys(_publicKeyJSON2)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar _key4 = _step12.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[_key4] = _publicKeyJSON2[_key4];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError12 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError12 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion12 && _iterator12.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator12.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError12) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError12;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\t{\n\t\t\t\t\t\tvar privateKeyInfo = new PrivateKeyInfo();\n\n\t\t\t\t\t\t//region Parse \"PrivateKeyInfo\" object\n\t\t\t\t\t\tvar _asn = fromBER(keyData);\n\t\t\t\t\t\tif (_asn.offset === -1) return Promise.reject(\"Incorrect keyData\");\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprivateKeyInfo.fromSchema(_asn.result);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\treturn Promise.reject(\"Incorrect keyData\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\"parsedKey\" in privateKeyInfo === false) return Promise.reject(\"Incorrect keyData\");\n\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t// noinspection FallThroughInSwitchStatementJS\n\t\t\t\t\t\t// noinspection FallThroughInSwitchStatementJS\n\t\t\t\t\t\tswitch (algorithm.name.toUpperCase()) {\n\t\t\t\t\t\t\tcase \"RSA-PSS\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS1\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS256\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS384\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"PS512\";\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// break omitted\n\t\t\t\t\t\t\tcase \"RSASSA-PKCS1-V1_5\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tkeyUsages = [\"sign\"]; // Override existing keyUsages value since the key is a private key\n\n\t\t\t\t\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\t\t\t\t\tjwk.ext = extractable;\n\t\t\t\t\t\t\t\t\tjwk.key_ops = keyUsages;\n\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tif (privateKeyInfo.privateKeyAlgorithm.algorithmId !== \"1.2.840.113549.1.1.1\") return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tif (\"alg\" in jwk === false) {\n\t\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS1\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS256\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS384\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RS512\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Create RSA Private Key elements\n\t\t\t\t\t\t\t\t\tvar privateKeyJSON = privateKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion13 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError13 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError13 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator13 = Object.keys(privateKeyJSON)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar _key5 = _step13.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[_key5] = privateKeyJSON[_key5];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError13 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError13 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion13 && _iterator13.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator13.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError13) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError13;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"ECDSA\":\n\t\t\t\t\t\t\t\tkeyUsages = [\"sign\"]; // Override existing keyUsages value since the key is a private key\n\t\t\t\t\t\t\t// break omitted\n\t\t\t\t\t\t\tcase \"ECDH\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//region Initial variables\n\t\t\t\t\t\t\t\t\tjwk = {\n\t\t\t\t\t\t\t\t\t\tkty: \"EC\",\n\t\t\t\t\t\t\t\t\t\text: extractable,\n\t\t\t\t\t\t\t\t\t\tkey_ops: keyUsages\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tif (privateKeyInfo.privateKeyAlgorithm.algorithmId !== \"1.2.840.10045.2.1\") return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Create ECDSA Private Key elements\n\t\t\t\t\t\t\t\t\tvar _privateKeyJSON = privateKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion14 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError14 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError14 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator14 = Object.keys(_privateKeyJSON)[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar _key6 = _step14.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[_key6] = _privateKeyJSON[_key6];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError14 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError14 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion14 && _iterator14.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator14.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError14) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError14;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"RSA-OAEP\":\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\t\t\t\t\t\tjwk.ext = extractable;\n\t\t\t\t\t\t\t\t\tjwk.key_ops = keyUsages;\n\n\t\t\t\t\t\t\t\t\t//region Get information about used hash function\n\t\t\t\t\t\t\t\t\tif (this.name.toLowerCase() === \"safari\") jwk.alg = \"RSA-OAEP\";else {\n\t\t\t\t\t\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-256\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-384\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\t\t\t\t\tjwk.alg = \"RSA-OAEP-512\";\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\t\t\t//region Create RSA Private Key elements\n\t\t\t\t\t\t\t\t\tvar _privateKeyJSON2 = privateKeyInfo.toJSON();\n\n\t\t\t\t\t\t\t\t\tvar _iteratorNormalCompletion15 = true;\n\t\t\t\t\t\t\t\t\tvar _didIteratorError15 = false;\n\t\t\t\t\t\t\t\t\tvar _iteratorError15 = undefined;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfor (var _iterator15 = Object.keys(_privateKeyJSON2)[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n\t\t\t\t\t\t\t\t\t\t\tvar _key7 = _step15.value;\n\n\t\t\t\t\t\t\t\t\t\t\tjwk[_key7] = _privateKeyJSON2[_key7];\n\t\t\t\t\t\t\t\t\t\t} //endregion\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\t_didIteratorError15 = true;\n\t\t\t\t\t\t\t\t\t\t_iteratorError15 = err;\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (!_iteratorNormalCompletion15 && _iterator15.return) {\n\t\t\t\t\t\t\t\t\t\t\t\t_iterator15.return();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\t\tif (_didIteratorError15) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow _iteratorError15;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"jwk\":\n\t\t\t\t\tjwk = keyData;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Incorrect format: ${format}`);\n\t\t\t}\n\n\t\t\t//region Special case for Safari browser (since its acting not as WebCrypto standard describes)\n\t\t\tif (this.name.toLowerCase() === \"safari\") {\n\t\t\t\t// Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)\n\t\t\t\treturn Promise.resolve().then(() => this.subtle.importKey(\"jwk\", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages)).then(result => result, () => this.subtle.importKey(\"jwk\", jwk, algorithm, extractable, keyUsages));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn this.subtle.importKey(\"jwk\", jwk, algorithm, extractable, keyUsages);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Export WebCrypto keys to different formats\n   * @param {string} format\n   * @param {Object} key\n   * @returns {Promise}\n   */\n\t\texportKey(format, key) {\n\t\t\tvar sequence = this.subtle.exportKey(\"jwk\", key);\n\n\t\t\t//region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation\n\t\t\tif (this.name.toLowerCase() === \"safari\") {\n\t\t\t\tsequence = sequence.then(result => {\n\t\t\t\t\t// Some additional checks for Safari Technology Preview\n\t\t\t\t\tif (result instanceof ArrayBuffer) return JSON.parse(arrayBufferToString(result));\n\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tswitch (format.toLowerCase()) {\n\t\t\t\tcase \"raw\":\n\t\t\t\t\treturn this.subtle.exportKey(\"raw\", key);\n\t\t\t\tcase \"spki\":\n\t\t\t\t\tsequence = sequence.then(result => {\n\t\t\t\t\t\tvar publicKeyInfo = new PublicKeyInfo();\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpublicKeyInfo.fromJSON(result);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\treturn Promise.reject(\"Incorrect key data\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn publicKeyInfo.toSchema().toBER(false);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\tsequence = sequence.then(result => {\n\t\t\t\t\t\tvar privateKeyInfo = new PrivateKeyInfo();\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprivateKeyInfo.fromJSON(result);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\treturn Promise.reject(\"Incorrect key data\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn privateKeyInfo.toSchema().toBER(false);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"jwk\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Incorrect format: ${format}`);\n\t\t\t}\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert WebCrypto keys between different export formats\n   * @param {string} inputFormat\n   * @param {string} outputFormat\n   * @param {ArrayBuffer|Object} keyData\n   * @param {Object} algorithm\n   * @param {boolean} extractable\n   * @param {Array} keyUsages\n   * @returns {Promise}\n   */\n\t\tconvert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {\n\t\t\tswitch (inputFormat.toLowerCase()) {\n\t\t\t\tcase \"raw\":\n\t\t\t\t\tswitch (outputFormat.toLowerCase()) {\n\t\t\t\t\t\tcase \"raw\":\n\t\t\t\t\t\t\treturn Promise.resolve(keyData);\n\t\t\t\t\t\tcase \"spki\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"spki\", result));\n\t\t\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"pkcs8\", result));\n\t\t\t\t\t\tcase \"jwk\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"raw\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n\t\t\t\t\t}\n\t\t\t\tcase \"spki\":\n\t\t\t\t\tswitch (outputFormat.toLowerCase()) {\n\t\t\t\t\t\tcase \"raw\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"spki\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\t\t\t\t\t\tcase \"spki\":\n\t\t\t\t\t\t\treturn Promise.resolve(keyData);\n\t\t\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\t\t\treturn Promise.reject(\"Impossible to convert between SPKI/PKCS8\");\n\t\t\t\t\t\tcase \"jwk\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"spki\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n\t\t\t\t\t}\n\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\tswitch (outputFormat.toLowerCase()) {\n\t\t\t\t\t\tcase \"raw\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"pkcs8\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\t\t\t\t\t\tcase \"spki\":\n\t\t\t\t\t\t\treturn Promise.reject(\"Impossible to convert between SPKI/PKCS8\");\n\t\t\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\t\t\treturn Promise.resolve(keyData);\n\t\t\t\t\t\tcase \"jwk\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"pkcs8\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"jwk\", result));\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n\t\t\t\t\t}\n\t\t\t\tcase \"jwk\":\n\t\t\t\t\tswitch (outputFormat.toLowerCase()) {\n\t\t\t\t\t\tcase \"raw\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"raw\", result));\n\t\t\t\t\t\tcase \"spki\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"spki\", result));\n\t\t\t\t\t\tcase \"pkcs8\":\n\t\t\t\t\t\t\treturn Promise.resolve().then(() => this.importKey(\"jwk\", keyData, algorithm, extractable, keyUsages)).then(result => this.exportKey(\"pkcs8\", result));\n\t\t\t\t\t\tcase \"jwk\":\n\t\t\t\t\t\t\treturn Promise.resolve(keyData);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect outputFormat: ${outputFormat}`);\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Incorrect inputFormat: ${inputFormat}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"encrypt\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tencrypt() {\n\t\t\treturn this.subtle.encrypt(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"decrypt\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tdecrypt() {\n\t\t\treturn this.subtle.decrypt(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"sign\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tsign() {\n\t\t\treturn this.subtle.sign(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"verify\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tverify() {\n\t\t\treturn this.subtle.verify(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"digest\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tdigest() {\n\t\t\treturn this.subtle.digest(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"generateKey\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tgenerateKey() {\n\t\t\treturn this.subtle.generateKey(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"deriveKey\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tderiveKey() {\n\t\t\treturn this.subtle.deriveKey(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"deriveBits\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tderiveBits() {\n\t\t\treturn this.subtle.deriveBits(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"wrapKey\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\twrapKey() {\n\t\t\treturn this.subtle.wrapKey(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Wrapper for standard function \"unwrapKey\"\n   * @param args\n   * @returns {Promise}\n   */\n\t\tunwrapKey() {\n\t\t\treturn this.subtle.unwrapKey(...arguments);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Initialize input Uint8Array by random values (with help from current \"crypto engine\")\n   * @param {!Uint8Array} view\n   * @returns {*}\n   */\n\t\tgetRandomValues(view) {\n\t\t\tif (\"getRandomValues\" in this.crypto === false) throw new Error(\"No support for getRandomValues\");\n\n\t\t\treturn this.crypto.getRandomValues(view);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Get WebCrypto algorithm by wel-known OID\n   * @param {string} oid well-known OID to search for\n   * @returns {Object}\n   */\n\t\tgetAlgorithmByOID(oid) {\n\t\t\tswitch (oid) {\n\t\t\t\tcase \"1.2.840.113549.1.1.1\":\n\t\t\t\tcase \"1.2.840.113549.1.1.5\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.1.11\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.1.12\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-384\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.1.13\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-512\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.1.10\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSA-PSS\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.1.7\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"RSA-OAEP\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.10045.2.1\":\n\t\t\t\tcase \"1.2.840.10045.4.1\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.10045.4.3.2\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.10045.4.3.3\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-384\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.10045.4.3.4\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-512\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.133.16.840.63.0.2\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\tkdf: \"SHA-1\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.132.1.11.1\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\tkdf: \"SHA-256\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.132.1.11.2\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\tkdf: \"SHA-384\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.132.1.11.3\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\tkdf: \"SHA-512\"\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.2\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CBC\",\n\t\t\t\t\t\tlength: 128\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.22\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CBC\",\n\t\t\t\t\t\tlength: 192\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.42\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CBC\",\n\t\t\t\t\t\tlength: 256\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.6\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\tlength: 128\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.26\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\tlength: 192\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.46\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\tlength: 256\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.4\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CFB\",\n\t\t\t\t\t\tlength: 128\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.24\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CFB\",\n\t\t\t\t\t\tlength: 192\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.44\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-CFB\",\n\t\t\t\t\t\tlength: 256\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.5\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-KW\",\n\t\t\t\t\t\tlength: 128\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.25\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-KW\",\n\t\t\t\t\t\tlength: 192\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.1.45\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"AES-KW\",\n\t\t\t\t\t\tlength: 256\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.2.7\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.2.9\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.2.10\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-384\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.2.11\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-512\"\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.9.16.3.5\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"DH\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.14.3.2.26\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.2.1\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.2.2\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"SHA-384\"\n\t\t\t\t\t};\n\t\t\t\tcase \"2.16.840.1.101.3.4.2.3\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"SHA-512\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.2.840.113549.1.5.12\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"PBKDF2\"\n\t\t\t\t\t};\n\t\t\t\t//region Special case - OIDs for ECC curves\n\t\t\t\tcase \"1.2.840.10045.3.1.7\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"P-256\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.132.0.34\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"P-384\"\n\t\t\t\t\t};\n\t\t\t\tcase \"1.3.132.0.35\":\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: \"P-521\"\n\t\t\t\t\t};\n\t\t\t\t//endregion\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn {};\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Get OID for each specific algorithm\n   * @param {Object} algorithm\n   * @returns {string}\n   */\n\t\tgetOIDByAlgorithm(algorithm) {\n\t\t\tvar result = \"\";\n\n\t\t\tswitch (algorithm.name.toUpperCase()) {\n\t\t\t\tcase \"RSASSA-PKCS1-V1_5\":\n\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.1.1.5\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.1.1.11\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.1.1.12\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.1.1.13\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA-PSS\":\n\t\t\t\t\tresult = \"1.2.840.113549.1.1.10\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA-OAEP\":\n\t\t\t\t\tresult = \"1.2.840.113549.1.1.7\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ECDSA\":\n\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\tresult = \"1.2.840.10045.4.1\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\tresult = \"1.2.840.10045.4.3.2\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\tresult = \"1.2.840.10045.4.3.3\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\tresult = \"1.2.840.10045.4.3.4\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ECDH\":\n\t\t\t\t\tswitch (algorithm.kdf.toUpperCase()) {// Non-standard addition - hash algorithm of KDF function\n\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\tresult = \"1.3.133.16.840.63.0.2\"; // dhSinglePass-stdDH-sha1kdf-scheme\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\tresult = \"1.3.132.1.11.1\"; // dhSinglePass-stdDH-sha256kdf-scheme\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\tresult = \"1.3.132.1.11.2\"; // dhSinglePass-stdDH-sha384kdf-scheme\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\tresult = \"1.3.132.1.11.3\"; // dhSinglePass-stdDH-sha512kdf-scheme\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CTR\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CBC\":\n\t\t\t\t\tswitch (algorithm.length) {\n\t\t\t\t\t\tcase 128:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.2\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 192:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.22\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 256:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.42\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CMAC\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-GCM\":\n\t\t\t\t\tswitch (algorithm.length) {\n\t\t\t\t\t\tcase 128:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.6\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 192:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.26\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 256:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.46\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CFB\":\n\t\t\t\t\tswitch (algorithm.length) {\n\t\t\t\t\t\tcase 128:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.4\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 192:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.24\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 256:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.44\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-KW\":\n\t\t\t\t\tswitch (algorithm.length) {\n\t\t\t\t\t\tcase 128:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.5\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 192:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.25\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 256:\n\t\t\t\t\t\t\tresult = \"2.16.840.1.101.3.4.1.45\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HMAC\":\n\t\t\t\t\tswitch (algorithm.hash.name.toUpperCase()) {\n\t\t\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.2.7\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.2.9\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.2.10\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\tresult = \"1.2.840.113549.2.11\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"DH\":\n\t\t\t\t\tresult = \"1.2.840.113549.1.9.16.3.5\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SHA-1\":\n\t\t\t\t\tresult = \"1.3.14.3.2.26\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\tresult = \"2.16.840.1.101.3.4.2.1\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\tresult = \"2.16.840.1.101.3.4.2.2\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\tresult = \"2.16.840.1.101.3.4.2.3\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"CONCAT\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HKDF\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"PBKDF2\":\n\t\t\t\t\tresult = \"1.2.840.113549.1.5.12\";\n\t\t\t\t\tbreak;\n\t\t\t\t//region Special case - OIDs for ECC curves\n\t\t\t\tcase \"P-256\":\n\t\t\t\t\tresult = \"1.2.840.10045.3.1.7\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"P-384\":\n\t\t\t\t\tresult = \"1.3.132.0.34\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"P-521\":\n\t\t\t\t\tresult = \"1.3.132.0.35\";\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Get default algorithm parameters for each kind of operation\n   * @param {string} algorithmName Algorithm name to get common parameters for\n   * @param {string} operation Kind of operation: \"sign\", \"encrypt\", \"generatekey\", \"importkey\", \"exportkey\", \"verify\"\n   * @returns {*}\n   */\n\t\tgetAlgorithmParameters(algorithmName, operation) {\n\t\t\tvar result = {\n\t\t\t\talgorithm: {},\n\t\t\t\tusages: []\n\t\t\t};\n\n\t\t\tswitch (algorithmName.toUpperCase()) {\n\t\t\t\tcase \"RSASSA-PKCS1-V1_5\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\t\t\t\tmodulusLength: 2048,\n\t\t\t\t\t\t\t\t\tpublicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"verify\":\n\t\t\t\t\t\tcase \"sign\":\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\",\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"verify\"] // For importKey(\"pkcs8\") usage must be \"sign\" only\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSASSA-PKCS1-v1_5\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA-PSS\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"sign\":\n\t\t\t\t\t\tcase \"verify\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-PSS\",\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsaltLength: 20\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-PSS\",\n\t\t\t\t\t\t\t\t\tmodulusLength: 2048,\n\t\t\t\t\t\t\t\t\tpublicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-PSS\",\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-1\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"verify\"] // For importKey(\"pkcs8\") usage must be \"sign\" only\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-PSS\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA-OAEP\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"encrypt\":\n\t\t\t\t\t\tcase \"decrypt\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-OAEP\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-OAEP\",\n\t\t\t\t\t\t\t\t\tmodulusLength: 2048,\n\t\t\t\t\t\t\t\t\tpublicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-OAEP\",\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\"] // encrypt for \"spki\" and decrypt for \"pkcs8\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"RSA-OAEP\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ECDSA\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"verify\"] // \"sign\" for \"pkcs8\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"verify\":\n\t\t\t\t\t\tcase \"sign\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ECDH\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"deriveKey\", \"deriveBits\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"derivekey\":\n\t\t\t\t\t\tcase \"derivebits\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\",\n\t\t\t\t\t\t\t\t\tpublic: [] // Must be a \"publicKey\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"ECDH\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CTR\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CTR\",\n\t\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"decrypt\":\n\t\t\t\t\t\tcase \"encrypt\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CTR\",\n\t\t\t\t\t\t\t\t\tcounter: new Uint8Array(16),\n\t\t\t\t\t\t\t\t\tlength: 10\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CTR\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-CBC\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CBC\",\n\t\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"decrypt\":\n\t\t\t\t\t\tcase \"encrypt\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CBC\",\n\t\t\t\t\t\t\t\t\tiv: this.getRandomValues(new Uint8Array(16)) // For \"decrypt\" the value should be replaced with value got on \"encrypt\" step\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-CBC\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-GCM\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"decrypt\":\n\t\t\t\t\t\tcase \"encrypt\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: this.getRandomValues(new Uint8Array(16)) // For \"decrypt\" the value should be replaced with value got on \"encrypt\" step\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"AES-KW\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\tcase \"wrapkey\":\n\t\t\t\t\t\tcase \"unwrapkey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-KW\",\n\t\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"wrapKey\", \"unwrapKey\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"AES-KW\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HMAC\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"sign\":\n\t\t\t\t\t\tcase \"verify\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"HMAC\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"importkey\":\n\t\t\t\t\t\tcase \"exportkey\":\n\t\t\t\t\t\tcase \"generatekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\t\t\t\tlength: 32,\n\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"sign\", \"verify\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"HMAC\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"HKDF\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"derivekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"HKDF\",\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\",\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array([]),\n\t\t\t\t\t\t\t\t\tinfo: new Uint8Array([])\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"HKDF\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"PBKDF2\":\n\t\t\t\t\tswitch (operation.toLowerCase()) {\n\t\t\t\t\t\tcase \"derivekey\":\n\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\thash: { name: \"SHA-256\" },\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array([]),\n\t\t\t\t\t\t\t\t\titerations: 10000\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: [\"encrypt\", \"decrypt\"]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tusages: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getting hash algorithm by signature algorithm\n   * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm\n   * @returns {string}\n   */\n\t\tgetHashAlgorithm(signatureAlgorithm) {\n\t\t\tvar result = \"\";\n\n\t\t\tswitch (signatureAlgorithm.algorithmId) {\n\t\t\t\tcase \"1.2.840.10045.4.1\": // ecdsa-with-SHA1\n\t\t\t\tcase \"1.2.840.113549.1.1.5\":\n\t\t\t\t\tresult = \"SHA-1\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.10045.4.3.2\": // ecdsa-with-SHA256\n\t\t\t\tcase \"1.2.840.113549.1.1.11\":\n\t\t\t\t\tresult = \"SHA-256\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.10045.4.3.3\": // ecdsa-with-SHA384\n\t\t\t\tcase \"1.2.840.113549.1.1.12\":\n\t\t\t\t\tresult = \"SHA-384\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.10045.4.3.4\": // ecdsa-with-SHA512\n\t\t\t\tcase \"1.2.840.113549.1.1.13\":\n\t\t\t\t\tresult = \"SHA-512\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.2.840.113549.1.1.10\":\n\t\t\t\t\t// RSA-PSS\n\t\t\t\t\t{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });\n\t\t\t\t\t\t\tif (\"hashAlgorithm\" in params) {\n\t\t\t\t\t\t\t\tvar algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);\n\t\t\t\t\t\t\t\tif (\"name\" in algorithm === false) return \"\";\n\n\t\t\t\t\t\t\t\tresult = algorithm.name;\n\t\t\t\t\t\t\t} else result = \"SHA-1\";\n\t\t\t\t\t\t} catch (ex) {}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Specialized function encrypting \"EncryptedContentInfo\" object using parameters\n   * @param {Object} parameters\n   * @returns {Promise}\n   */\n\t\tencryptEncryptedContentInfo(parameters) {\n\t\t\t//region Check for input parameters\n\t\t\tif (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n\n\t\t\tif (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n\n\t\t\tif (\"contentEncryptionAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentEncryptionAlgorithm\\\"\");\n\n\t\t\tif (\"hmacHashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hmacHashAlgorithm\\\"\");\n\n\t\t\tif (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n\n\t\t\tif (\"contentToEncrypt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToEncrypt\\\"\");\n\n\t\t\tif (\"contentType\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentType\\\"\");\n\n\t\t\tvar contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);\n\t\t\tif (contentEncryptionOID === \"\") return Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\");\n\n\t\t\tvar pbkdf2OID = this.getOIDByAlgorithm({\n\t\t\t\tname: \"PBKDF2\"\n\t\t\t});\n\t\t\tif (pbkdf2OID === \"\") return Promise.reject(\"Can not find OID for PBKDF2\");\n\n\t\t\tvar hmacOID = this.getOIDByAlgorithm({\n\t\t\t\tname: \"HMAC\",\n\t\t\t\thash: {\n\t\t\t\t\tname: parameters.hmacHashAlgorithm\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (hmacOID === \"\") return Promise.reject(`Incorrect value for \"hmacHashAlgorithm\": ${parameters.hmacHashAlgorithm}`);\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\n\t\t\tvar ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\n\t\t\tvar ivView = new Uint8Array(ivBuffer);\n\t\t\tthis.getRandomValues(ivView);\n\n\t\t\tvar saltBuffer = new ArrayBuffer(64);\n\t\t\tvar saltView = new Uint8Array(saltBuffer);\n\t\t\tthis.getRandomValues(saltView);\n\n\t\t\tvar contentView = new Uint8Array(parameters.contentToEncrypt);\n\n\t\t\tvar pbkdf2Params = new PBKDF2Params({\n\t\t\t\tsalt: new OctetString({ valueHex: saltBuffer }),\n\t\t\t\titerationCount: parameters.iterationCount,\n\t\t\t\tprf: new AlgorithmIdentifier({\n\t\t\t\t\talgorithmId: hmacOID,\n\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t})\n\t\t\t});\n\t\t\t//endregion\n\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\n\t\t\tsequence = sequence.then(() => {\n\t\t\t\tvar passwordView = new Uint8Array(parameters.password);\n\n\t\t\t\treturn this.importKey(\"raw\", passwordView, \"PBKDF2\", false, [\"deriveKey\"]);\n\t\t\t}, error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\t//region Derive key for \"contentEncryptionAlgorithm\"\n\t\t\tsequence = sequence.then(result => this.deriveKey({\n\t\t\t\tname: \"PBKDF2\",\n\t\t\t\thash: {\n\t\t\t\t\tname: parameters.hmacHashAlgorithm\n\t\t\t\t},\n\t\t\t\tsalt: saltView,\n\t\t\t\titerations: parameters.iterationCount\n\t\t\t}, result, parameters.contentEncryptionAlgorithm, false, [\"encrypt\"]), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\t//region Encrypt content\n\t\t\tsequence = sequence.then(result => this.encrypt({\n\t\t\t\tname: parameters.contentEncryptionAlgorithm.name,\n\t\t\t\tiv: ivView\n\t\t\t}, result, contentView), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\t//region Store all parameters in EncryptedData object\n\t\t\tsequence = sequence.then(result => {\n\t\t\t\tvar pbes2Parameters = new PBES2Params({\n\t\t\t\t\tkeyDerivationFunc: new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: pbkdf2OID,\n\t\t\t\t\t\talgorithmParams: pbkdf2Params.toSchema()\n\t\t\t\t\t}),\n\t\t\t\t\tencryptionScheme: new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: contentEncryptionOID,\n\t\t\t\t\t\talgorithmParams: new OctetString({ valueHex: ivBuffer })\n\t\t\t\t\t})\n\t\t\t\t});\n\n\t\t\t\treturn new EncryptedContentInfo({\n\t\t\t\t\tcontentType: parameters.contentType,\n\t\t\t\t\tcontentEncryptionAlgorithm: new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.5.13\", // pkcs5PBES2\n\t\t\t\t\t\talgorithmParams: pbes2Parameters.toSchema()\n\t\t\t\t\t}),\n\t\t\t\t\tencryptedContent: new OctetString({ valueHex: result })\n\t\t\t\t});\n\t\t\t}, error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Decrypt data stored in \"EncryptedContentInfo\" object using parameters\n   * @param parameters\n   * @return {Promise}\n   */\n\t\tdecryptEncryptedContentInfo(parameters) {\n\t\t\t//region Check for input parameters\n\t\t\tif (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n\n\t\t\tif (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n\n\t\t\tif (\"encryptedContentInfo\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"encryptedContentInfo\\\"\");\n\n\t\t\tif (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== \"1.2.840.113549.1.5.13\") // pkcs5PBES2\n\t\t\t\treturn Promise.reject(`Unknown \"contentEncryptionAlgorithm\": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\n\t\t\tvar pbes2Parameters = void 0;\n\n\t\t\ttry {\n\t\t\t\tpbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });\n\t\t\t} catch (ex) {\n\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"pbes2Parameters\\\"\");\n\t\t\t}\n\n\t\t\tvar pbkdf2Params = void 0;\n\n\t\t\ttry {\n\t\t\t\tpbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });\n\t\t\t} catch (ex) {\n\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"pbkdf2Params\\\"\");\n\t\t\t}\n\n\t\t\tvar contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);\n\t\t\tif (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect OID for \"contentEncryptionAlgorithm\": ${pbes2Parameters.encryptionScheme.algorithmId}`);\n\n\t\t\tvar ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;\n\t\t\tvar ivView = new Uint8Array(ivBuffer);\n\n\t\t\tvar saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;\n\t\t\tvar saltView = new Uint8Array(saltBuffer);\n\n\t\t\tvar iterationCount = pbkdf2Params.iterationCount;\n\n\t\t\tvar hmacHashAlgorithm = \"SHA-1\";\n\n\t\t\tif (\"prf\" in pbkdf2Params) {\n\t\t\t\tvar algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n\t\t\t\tif (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n\n\t\t\t\thmacHashAlgorithm = algorithm.hash.name;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\n\t\t\tsequence = sequence.then(() => this.importKey(\"raw\", parameters.password, \"PBKDF2\", false, [\"deriveKey\"]), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\t//region Derive key for \"contentEncryptionAlgorithm\"\n\t\t\tsequence = sequence.then(result => this.deriveKey({\n\t\t\t\tname: \"PBKDF2\",\n\t\t\t\thash: {\n\t\t\t\t\tname: hmacHashAlgorithm\n\t\t\t\t},\n\t\t\t\tsalt: saltView,\n\t\t\t\titerations: iterationCount\n\t\t\t}, result, contentEncryptionAlgorithm, false, [\"decrypt\"]), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\t//region Decrypt internal content using derived key\n\t\t\tsequence = sequence.then(result => {\n\t\t\t\t//region Create correct data block for decryption\n\t\t\t\tvar dataBuffer = new ArrayBuffer(0);\n\n\t\t\t\tif (parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {\n\t\t\t\t\tvar _iteratorNormalCompletion16 = true;\n\t\t\t\t\tvar _didIteratorError16 = false;\n\t\t\t\t\tvar _iteratorError16 = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator16 = parameters.encryptedContentInfo.encryptedContent.valueBlock.value[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n\t\t\t\t\t\t\tvar content = _step16.value;\n\n\t\t\t\t\t\t\tdataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError16 = true;\n\t\t\t\t\t\t_iteratorError16 = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion16 && _iterator16.return) {\n\t\t\t\t\t\t\t\t_iterator16.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError16) {\n\t\t\t\t\t\t\t\tthrow _iteratorError16;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\treturn this.decrypt({\n\t\t\t\t\tname: contentEncryptionAlgorithm.name,\n\t\t\t\t\tiv: ivView\n\t\t\t\t}, result, dataBuffer);\n\t\t\t}, error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Stamping (signing) data using algorithm simular to HMAC\n   * @param {Object} parameters\n   * @return {Promise.<T>|Promise}\n   */\n\t\tstampDataWithPassword(parameters) {\n\t\t\t//region Check for input parameters\n\t\t\tif (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n\n\t\t\tif (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n\n\t\t\tif (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hashAlgorithm\\\"\");\n\n\t\t\tif (\"salt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n\n\t\t\tif (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"salt\\\"\");\n\n\t\t\tif (\"contentToStamp\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToStamp\\\"\");\n\t\t\t//endregion\n\n\t\t\t//region Choose correct length for HMAC key\n\t\t\tvar length = void 0;\n\n\t\t\tswitch (parameters.hashAlgorithm.toLowerCase()) {\n\t\t\t\tcase \"sha-1\":\n\t\t\t\t\tlength = 160;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-256\":\n\t\t\t\t\tlength = 256;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-384\":\n\t\t\t\t\tlength = 384;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-512\":\n\t\t\t\t\tlength = 512;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Incorrect \"parameters.hashAlgorithm\" parameter: ${parameters.hashAlgorithm}`);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\n\t\t\tvar hmacAlgorithm = {\n\t\t\t\tname: \"HMAC\",\n\t\t\t\tlength,\n\t\t\t\thash: {\n\t\t\t\t\tname: parameters.hashAlgorithm\n\t\t\t\t}\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\t//region Create PKCS#12 key for integrity checking\n\t\t\tsequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));\n\t\t\t//endregion\n\n\t\t\t//region Import HMAC key\n\t\t\t// noinspection JSCheckFunctionSignatures\n\t\t\tsequence = sequence.then(result => this.importKey(\"raw\", new Uint8Array(result), hmacAlgorithm, false, [\"sign\"]));\n\t\t\t//endregion\n\n\t\t\t//region Make signed HMAC value\n\t\t\tsequence = sequence.then(result => this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\tverifyDataStampedWithPassword(parameters) {\n\t\t\t//region Check for input parameters\n\t\t\tif (parameters instanceof Object === false) return Promise.reject(\"Parameters must have type \\\"Object\\\"\");\n\n\t\t\tif (\"password\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"password\\\"\");\n\n\t\t\tif (\"hashAlgorithm\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"hashAlgorithm\\\"\");\n\n\t\t\tif (\"salt\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"iterationCount\\\"\");\n\n\t\t\tif (\"iterationCount\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"salt\\\"\");\n\n\t\t\tif (\"contentToVerify\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"contentToVerify\\\"\");\n\n\t\t\tif (\"signatureToVerify\" in parameters === false) return Promise.reject(\"Absent mandatory parameter \\\"signatureToVerify\\\"\");\n\t\t\t//endregion\n\n\t\t\t//region Choose correct length for HMAC key\n\t\t\tvar length = void 0;\n\n\t\t\tswitch (parameters.hashAlgorithm.toLowerCase()) {\n\t\t\t\tcase \"sha-1\":\n\t\t\t\t\tlength = 160;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-256\":\n\t\t\t\t\tlength = 256;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-384\":\n\t\t\t\t\tlength = 384;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha-512\":\n\t\t\t\t\tlength = 512;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Incorrect \"parameters.hashAlgorithm\" parameter: ${parameters.hashAlgorithm}`);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\n\t\t\tvar hmacAlgorithm = {\n\t\t\t\tname: \"HMAC\",\n\t\t\t\tlength,\n\t\t\t\thash: {\n\t\t\t\t\tname: parameters.hashAlgorithm\n\t\t\t\t}\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\t//region Create PKCS#12 key for integrity checking\n\t\t\tsequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));\n\t\t\t//endregion\n\n\t\t\t//region Import HMAC key\n\t\t\t// noinspection JSCheckFunctionSignatures\n\t\t\tsequence = sequence.then(result => this.importKey(\"raw\", new Uint8Array(result), hmacAlgorithm, false, [\"verify\"]));\n\t\t\t//endregion\n\n\t\t\t//region Make signed HMAC value\n\t\t\tsequence = sequence.then(result => this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)), error => Promise.reject(error));\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Get signature parameters by analyzing private key algorithm\n   * @param {Object} privateKey The private key user would like to use\n   * @param {string} [hashAlgorithm=\"SHA-1\"] Hash algorithm user would like to use\n   * @return {Promise.<T>|Promise}\n   */\n\t\tgetSignatureParameters(privateKey) {\n\t\t\tvar hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"SHA-1\";\n\n\t\t\t//region Check hashing algorithm\n\t\t\tvar oid = this.getOIDByAlgorithm({ name: hashAlgorithm });\n\t\t\tif (oid === \"\") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar signatureAlgorithm = new AlgorithmIdentifier();\n\t\t\t//endregion\n\n\t\t\t//region Get a \"default parameters\" for current algorithm\n\t\t\tvar parameters = this.getAlgorithmParameters(privateKey.algorithm.name, \"sign\");\n\t\t\tparameters.algorithm.hash.name = hashAlgorithm;\n\t\t\t//endregion\n\n\t\t\t//region Fill internal structures base on \"privateKey\" and \"hashAlgorithm\"\n\t\t\tswitch (privateKey.algorithm.name.toUpperCase()) {\n\t\t\t\tcase \"RSASSA-PKCS1-V1_5\":\n\t\t\t\tcase \"ECDSA\":\n\t\t\t\t\tsignatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA-PSS\":\n\t\t\t\t\t{\n\t\t\t\t\t\t//region Set \"saltLength\" as a length (in octets) of hash function result\n\t\t\t\t\t\tswitch (hashAlgorithm.toUpperCase()) {\n\t\t\t\t\t\t\tcase \"SHA-256\":\n\t\t\t\t\t\t\t\tparameters.algorithm.saltLength = 32;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"SHA-384\":\n\t\t\t\t\t\t\t\tparameters.algorithm.saltLength = 48;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"SHA-512\":\n\t\t\t\t\t\t\t\tparameters.algorithm.saltLength = 64;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t//region Fill \"RSASSA_PSS_params\" object\n\t\t\t\t\t\tvar paramsObject = {};\n\n\t\t\t\t\t\tif (hashAlgorithm.toUpperCase() !== \"SHA-1\") {\n\t\t\t\t\t\t\tvar hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm });\n\t\t\t\t\t\t\tif (hashAlgorithmOID === \"\") return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);\n\n\t\t\t\t\t\t\tparamsObject.hashAlgorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\t\talgorithmId: hashAlgorithmOID,\n\t\t\t\t\t\t\t\talgorithmParams: new Null()\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tparamsObject.maskGenAlgorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.8\", // MGF1\n\t\t\t\t\t\t\t\talgorithmParams: paramsObject.hashAlgorithm.toSchema()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parameters.algorithm.saltLength !== 20) paramsObject.saltLength = parameters.algorithm.saltLength;\n\n\t\t\t\t\t\tvar pssParameters = new RSASSAPSSParams(paramsObject);\n\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t//region Automatically set signature algorithm\n\t\t\t\t\t\tsignatureAlgorithm.algorithmId = \"1.2.840.113549.1.1.10\";\n\t\t\t\t\t\tsignatureAlgorithm.algorithmParams = pssParameters.toSchema();\n\t\t\t\t\t\t//endregion\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn Promise.resolve().then(() => ({\n\t\t\t\tsignatureAlgorithm,\n\t\t\t\tparameters\n\t\t\t}));\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Sign data with pre-defined private key\n   * @param {ArrayBuffer} data Data to be signed\n   * @param {Object} privateKey Private key to use\n   * @param {Object} parameters Parameters for used algorithm\n   * @return {Promise.<T>|Promise}\n   */\n\t\tsignWithPrivateKey(data, privateKey, parameters) {\n\t\t\treturn this.sign(parameters.algorithm, privateKey, new Uint8Array(data)).then(result => {\n\t\t\t\t//region Special case for ECDSA algorithm\n\t\t\t\tif (parameters.algorithm.name === \"ECDSA\") result = createCMSECDSASignature(result);\n\t\t\t\t//endregion\n\n\t\t\t\treturn result;\n\t\t\t}, error => Promise.reject(`Signing error: ${error}`));\n\t\t}\n\t\t//**********************************************************************************\n\t\tfillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {\n\t\t\tvar parameters = {};\n\n\t\t\t//region Find signer's hashing algorithm\n\t\t\tvar shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);\n\t\t\tif (shaAlgorithm === \"\") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);\n\t\t\t//endregion\n\n\t\t\t//region Get information about public key algorithm and default parameters for import\n\t\t\tvar algorithmId = void 0;\n\t\t\tif (signatureAlgorithm.algorithmId === \"1.2.840.113549.1.1.10\") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;\n\n\t\t\tvar algorithmObject = this.getAlgorithmByOID(algorithmId);\n\t\t\tif (\"name\" in algorithmObject === \"\") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);\n\n\t\t\tparameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, \"importkey\");\n\t\t\tif (\"hash\" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;\n\n\t\t\t//region Special case for ECDSA\n\t\t\tif (algorithmObject.name === \"ECDSA\") {\n\t\t\t\t//region Get information about named curve\n\t\t\t\tvar algorithmParamsChecked = false;\n\n\t\t\t\tif (\"algorithmParams\" in publicKeyInfo.algorithm === true) {\n\t\t\t\t\tif (\"idBlock\" in publicKeyInfo.algorithm.algorithmParams) {\n\t\t\t\t\t\tif (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (algorithmParamsChecked === false) return Promise.reject(\"Incorrect type for ECDSA public key parameters\");\n\n\t\t\t\tvar curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());\n\t\t\t\tif (\"name\" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);\n\t\t\t\t//endregion\n\n\t\t\t\tparameters.algorithm.algorithm.namedCurve = curveObject.name;\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//endregion\n\n\t\t\treturn parameters;\n\t\t}\n\t\t//**********************************************************************************\n\t\tgetPublicKey(publicKeyInfo, signatureAlgorithm) {\n\t\t\tvar parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\tif (parameters === null) parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);\n\n\t\t\tvar publicKeyInfoSchema = publicKeyInfo.toSchema();\n\t\t\tvar publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);\n\t\t\tvar publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);\n\n\t\t\treturn this.importKey(\"spki\", publicKeyInfoView, parameters.algorithm.algorithm, true, parameters.algorithm.usages);\n\t\t}\n\t\t//**********************************************************************************\n\t\tverifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm) {\n\t\t\tvar shaAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\t\t\t//endregion\n\n\t\t\t//region Find signer's hashing algorithm\n\t\t\tif (shaAlgorithm === null) {\n\t\t\t\tshaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);\n\t\t\t\tif (shaAlgorithm === \"\") return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);\n\n\t\t\t\t//region Import public key\n\t\t\t\tsequence = sequence.then(() => this.getPublicKey(publicKeyInfo, signatureAlgorithm));\n\t\t\t\t//endregion\n\t\t\t} else {\n\t\t\t\tvar parameters = {};\n\n\t\t\t\t//region Get information about public key algorithm and default parameters for import\n\t\t\t\tvar algorithmId = void 0;\n\t\t\t\tif (signatureAlgorithm.algorithmId === \"1.2.840.113549.1.1.10\") algorithmId = signatureAlgorithm.algorithmId;else algorithmId = publicKeyInfo.algorithm.algorithmId;\n\n\t\t\t\tvar algorithmObject = this.getAlgorithmByOID(algorithmId);\n\t\t\t\tif (\"name\" in algorithmObject === \"\") return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);\n\n\t\t\t\tparameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, \"importkey\");\n\t\t\t\tif (\"hash\" in parameters.algorithm.algorithm) parameters.algorithm.algorithm.hash.name = shaAlgorithm;\n\n\t\t\t\t//region Special case for ECDSA\n\t\t\t\tif (algorithmObject.name === \"ECDSA\") {\n\t\t\t\t\t//region Get information about named curve\n\t\t\t\t\tvar algorithmParamsChecked = false;\n\n\t\t\t\t\tif (\"algorithmParams\" in publicKeyInfo.algorithm === true) {\n\t\t\t\t\t\tif (\"idBlock\" in publicKeyInfo.algorithm.algorithmParams) {\n\t\t\t\t\t\t\tif (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6) algorithmParamsChecked = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (algorithmParamsChecked === false) return Promise.reject(\"Incorrect type for ECDSA public key parameters\");\n\n\t\t\t\t\tvar curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());\n\t\t\t\t\tif (\"name\" in curveObject === false) return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);\n\t\t\t\t\t//endregion\n\n\t\t\t\t\tparameters.algorithm.algorithm.namedCurve = curveObject.name;\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t\t//endregion\n\n\t\t\t\t//region Import public key\n\t\t\t\tsequence = sequence.then(() => this.getPublicKey(publicKeyInfo, null, parameters));\n\t\t\t\t//endregion\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Verify signature\n\t\t\tsequence = sequence.then(publicKey => {\n\t\t\t\t//region Get default algorithm parameters for verification\n\t\t\t\tvar algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, \"verify\");\n\t\t\t\tif (\"hash\" in algorithm.algorithm) algorithm.algorithm.hash.name = shaAlgorithm;\n\t\t\t\t//endregion\n\n\t\t\t\t//region Special case for ECDSA signatures\n\t\t\t\tvar signatureValue = signature.valueBlock.valueHex;\n\n\t\t\t\tif (publicKey.algorithm.name === \"ECDSA\") {\n\t\t\t\t\tvar asn1 = fromBER(signatureValue);\n\t\t\t\t\t// noinspection JSCheckFunctionSignatures\n\t\t\t\t\tsignatureValue = createECDSASignatureFromCMS(asn1.result);\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\t//region Special case for RSA-PSS\n\t\t\t\tif (publicKey.algorithm.name === \"RSA-PSS\") {\n\t\t\t\t\tvar pssParameters = void 0;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\treturn Promise.reject(ex);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\"saltLength\" in pssParameters) algorithm.algorithm.saltLength = pssParameters.saltLength;else algorithm.algorithm.saltLength = 20;\n\n\t\t\t\t\tvar hashAlgo = \"SHA-1\";\n\n\t\t\t\t\tif (\"hashAlgorithm\" in pssParameters) {\n\t\t\t\t\t\tvar hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);\n\t\t\t\t\t\tif (\"name\" in hashAlgorithm === false) return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);\n\n\t\t\t\t\t\thashAlgo = hashAlgorithm.name;\n\t\t\t\t\t}\n\n\t\t\t\t\talgorithm.algorithm.hash.name = hashAlgo;\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\treturn this.verify(algorithm.algorithm, publicKey, new Uint8Array(signatureValue), new Uint8Array(data));\n\t\t\t});\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t//region Crypto engine related function\n\t//**************************************************************************************\n\tvar engine = {\n\t\tname: \"none\",\n\t\tcrypto: null,\n\t\tsubtle: null\n\t};\n\t//**************************************************************************************\n\tfunction setEngine(name, crypto, subtle) {\n\t\t//region We are in Node\n\t\t// noinspection JSUnresolvedVariable\n\t\tif (typeof process !== \"undefined\" && \"pid\" in process && typeof global !== \"undefined\") {\n\t\t\t// noinspection ES6ModulesDependencies, JSUnresolvedVariable\n\t\t\tif (typeof global[process.pid] === \"undefined\") {\n\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\tglobal[process.pid] = {};\n\t\t\t} else {\n\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\tif (typeof global[process.pid] !== \"object\") {\n\t\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\t\tthrow new Error(`Name global.${process.pid} already exists and it is not an object`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection JSUnresolvedVariable\n\t\t\tif (typeof global[process.pid].pkijs === \"undefined\") {\n\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\tglobal[process.pid].pkijs = {};\n\t\t\t} else {\n\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\tif (typeof global[process.pid].pkijs !== \"object\") {\n\t\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\t\tthrow new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection JSUnresolvedVariable\n\t\t\tglobal[process.pid].pkijs.engine = {\n\t\t\t\tname: name,\n\t\t\t\tcrypto: crypto,\n\t\t\t\tsubtle: subtle\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t//region We are in browser\n\t\telse {\n\t\t\t\tengine = {\n\t\t\t\t\tname: name,\n\t\t\t\t\tcrypto: crypto,\n\t\t\t\t\tsubtle: subtle\n\t\t\t\t};\n\t\t\t}\n\t\t//endregion\n\t}\n\t//**************************************************************************************\n\tfunction getEngine() {\n\t\t//region We are in Node\n\t\t// noinspection JSUnresolvedVariable\n\t\tif (typeof process !== \"undefined\" && \"pid\" in process && typeof global !== \"undefined\") {\n\t\t\tvar _engine = void 0;\n\n\t\t\ttry {\n\t\t\t\t// noinspection JSUnresolvedVariable\n\t\t\t\t_engine = global[process.pid].pkijs.engine;\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new Error(\"Please call \\\"setEngine\\\" before call to \\\"getEngine\\\"\");\n\t\t\t}\n\n\t\t\treturn _engine;\n\t\t}\n\t\t//endregion\n\n\t\treturn engine;\n\t}\n\t//**************************************************************************************\n\t(function initCryptoEngine() {\n\t\tif (typeof self !== \"undefined\") {\n\t\t\tif (\"crypto\" in self) {\n\t\t\t\tvar engineName = \"webcrypto\";\n\n\t\t\t\t/**\n     * Standard crypto object\n     * @type {Object}\n     * @property {Object} [webkitSubtle] Subtle object from Apple\n     */\n\t\t\t\tvar cryptoObject = self.crypto;\n\t\t\t\tvar subtleObject = null;\n\n\t\t\t\t// Apple Safari support\n\t\t\t\tif (\"webkitSubtle\" in self.crypto) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsubtleObject = self.crypto.webkitSubtle;\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tsubtleObject = self.crypto.subtle;\n\t\t\t\t\t}\n\n\t\t\t\t\tengineName = \"safari\";\n\t\t\t\t}\n\n\t\t\t\tif (\"subtle\" in self.crypto) subtleObject = self.crypto.subtle;\n\n\t\t\t\tengine = {\n\t\t\t\t\tname: engineName,\n\t\t\t\t\tcrypto: cryptoObject,\n\t\t\t\t\tsubtle: new CryptoEngine({ name: engineName, crypto: self.crypto, subtle: subtleObject })\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tsetEngine(engine.name, engine.crypto, engine.subtle);\n\t})();\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t//region Declaration of common functions\n\t//**************************************************************************************\n\t/**\n  * Get crypto subtle from current \"crypto engine\" or \"undefined\"\n  * @returns {({decrypt, deriveKey, digest, encrypt, exportKey, generateKey, importKey, sign, unwrapKey, verify, wrapKey}|null)}\n  */\n\tfunction getCrypto() {\n\t\tvar _engine = getEngine();\n\n\t\tif (_engine.subtle !== null) return _engine.subtle;\n\n\t\treturn undefined;\n\t}\n\t//**************************************************************************************\n\t/**\n  * Get default algorithm parameters for each kind of operation\n  * @param {string} algorithmName Algorithm name to get common parameters for\n  * @param {string} operation Kind of operation: \"sign\", \"encrypt\", \"generatekey\", \"importkey\", \"exportkey\", \"verify\"\n  * @returns {*}\n  */\n\tfunction getAlgorithmParameters(algorithmName, operation) {\n\t\treturn getEngine().subtle.getAlgorithmParameters(algorithmName, operation);\n\t}\n\t//**************************************************************************************\n\t/**\n  * Create CMS ECDSA signature from WebCrypto ECDSA signature\n  * @param {ArrayBuffer} signatureBuffer WebCrypto result of \"sign\" function\n  * @returns {ArrayBuffer}\n  */\n\tfunction createCMSECDSASignature(signatureBuffer) {\n\t\t//region Initial check for correct length\n\t\tif (signatureBuffer.byteLength % 2 !== 0) return new ArrayBuffer(0);\n\t\t//endregion\n\n\t\t//region Initial variables\n\t\tvar length = signatureBuffer.byteLength / 2; // There are two equal parts inside incoming ArrayBuffer\n\n\t\tvar rBuffer = new ArrayBuffer(length);\n\t\tvar rView = new Uint8Array(rBuffer);\n\t\trView.set(new Uint8Array(signatureBuffer, 0, length));\n\n\t\tvar rInteger = new Integer({ valueHex: rBuffer });\n\n\t\tvar sBuffer = new ArrayBuffer(length);\n\t\tvar sView = new Uint8Array(sBuffer);\n\t\tsView.set(new Uint8Array(signatureBuffer, length, length));\n\n\t\tvar sInteger = new Integer({ valueHex: sBuffer });\n\t\t//endregion\n\n\t\treturn new Sequence({\n\t\t\tvalue: [rInteger.convertToDER(), sInteger.convertToDER()]\n\t\t}).toBER(false);\n\t}\n\t//**************************************************************************************\n\t/**\n  * String preparation function. In a future here will be realization of algorithm from RFC4518\n  * @param {string} inputString JavaScript string. As soon as for each ASN.1 string type we have a specific transformation function here we will work with pure JavaScript string\n  * @returns {string} Formated string\n  */\n\tfunction stringPrep(inputString) {\n\t\t//region Initial variables\n\t\tvar isSpace = false;\n\t\tvar cuttedResult = \"\";\n\t\t//endregion\n\n\t\tvar result = inputString.trim(); // Trim input string\n\n\t\t//region Change all sequence of SPACE down to SPACE char\n\t\tfor (var i = 0; i < result.length; i++) {\n\t\t\tif (result.charCodeAt(i) === 32) {\n\t\t\t\tif (isSpace === false) isSpace = true;\n\t\t\t} else {\n\t\t\t\tif (isSpace) {\n\t\t\t\t\tcuttedResult += \" \";\n\t\t\t\t\tisSpace = false;\n\t\t\t\t}\n\n\t\t\t\tcuttedResult += result[i];\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\treturn cuttedResult.toLowerCase();\n\t}\n\t//**************************************************************************************\n\t/**\n  * Create a single ArrayBuffer from CMS ECDSA signature\n  * @param {Sequence} cmsSignature ASN.1 SEQUENCE contains CMS ECDSA signature\n  * @returns {ArrayBuffer}\n  */\n\tfunction createECDSASignatureFromCMS(cmsSignature) {\n\t\t//region Check input variables\n\t\tif (cmsSignature instanceof Sequence === false) return new ArrayBuffer(0);\n\n\t\tif (cmsSignature.valueBlock.value.length !== 2) return new ArrayBuffer(0);\n\n\t\tif (cmsSignature.valueBlock.value[0] instanceof Integer === false) return new ArrayBuffer(0);\n\n\t\tif (cmsSignature.valueBlock.value[1] instanceof Integer === false) return new ArrayBuffer(0);\n\t\t//endregion\n\n\t\tvar rValue = cmsSignature.valueBlock.value[0].convertFromDER();\n\t\tvar sValue = cmsSignature.valueBlock.value[1].convertFromDER();\n\n\t\t//region Check the lengths of two parts are equal\n\t\tswitch (true) {\n\t\t\tcase rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength:\n\t\t\t\t{\n\t\t\t\t\tif (sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength !== 1) throw new Error(\"Incorrect DER integer decoding\");\n\n\t\t\t\t\tvar correctedLength = sValue.valueBlock.valueHex.byteLength;\n\n\t\t\t\t\tvar rValueView = new Uint8Array(rValue.valueBlock.valueHex);\n\n\t\t\t\t\tvar rValueBufferCorrected = new ArrayBuffer(correctedLength);\n\t\t\t\t\tvar rValueViewCorrected = new Uint8Array(rValueBufferCorrected);\n\n\t\t\t\t\trValueViewCorrected.set(rValueView, 1);\n\t\t\t\t\trValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n\t\t\t\t\treturn utilConcatBuf(rValueBufferCorrected, sValue.valueBlock.valueHex);\n\t\t\t\t}\n\t\t\tcase rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength:\n\t\t\t\t{\n\t\t\t\t\tif (rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength !== 1) throw new Error(\"Incorrect DER integer decoding\");\n\n\t\t\t\t\tvar _correctedLength = rValue.valueBlock.valueHex.byteLength;\n\n\t\t\t\t\tvar sValueView = new Uint8Array(sValue.valueBlock.valueHex);\n\n\t\t\t\t\tvar sValueBufferCorrected = new ArrayBuffer(_correctedLength);\n\t\t\t\t\tvar sValueViewCorrected = new Uint8Array(sValueBufferCorrected);\n\n\t\t\t\t\tsValueViewCorrected.set(sValueView, 1);\n\t\t\t\t\tsValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n\t\t\t\t\treturn utilConcatBuf(rValue.valueBlock.valueHex, sValueBufferCorrected);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\t//region In case we have equal length and the length is not even with 2\n\t\t\t\t\tif (rValue.valueBlock.valueHex.byteLength % 2) {\n\t\t\t\t\t\tvar _correctedLength2 = rValue.valueBlock.valueHex.byteLength + 1;\n\n\t\t\t\t\t\tvar _rValueView = new Uint8Array(rValue.valueBlock.valueHex);\n\n\t\t\t\t\t\tvar _rValueBufferCorrected = new ArrayBuffer(_correctedLength2);\n\t\t\t\t\t\tvar _rValueViewCorrected = new Uint8Array(_rValueBufferCorrected);\n\n\t\t\t\t\t\t_rValueViewCorrected.set(_rValueView, 1);\n\t\t\t\t\t\t_rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n\t\t\t\t\t\tvar _sValueView = new Uint8Array(sValue.valueBlock.valueHex);\n\n\t\t\t\t\t\tvar _sValueBufferCorrected = new ArrayBuffer(_correctedLength2);\n\t\t\t\t\t\tvar _sValueViewCorrected = new Uint8Array(_sValueBufferCorrected);\n\n\t\t\t\t\t\t_sValueViewCorrected.set(_sValueView, 1);\n\t\t\t\t\t\t_sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here\n\n\t\t\t\t\t\treturn utilConcatBuf(_rValueBufferCorrected, _sValueBufferCorrected);\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\t\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\treturn utilConcatBuf(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass AttributeTypeAndValue {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for AttributeTypeAndValue class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description type\n    */\n\t\t\tthis.type = getParametersValue(parameters, \"type\", AttributeTypeAndValue.defaultValues(\"type\"));\n\t\t\t/**\n    * @type {Object}\n    * @description Value of the AttributeTypeAndValue class\n    */\n\t\t\tthis.value = getParametersValue(parameters, \"value\", AttributeTypeAndValue.defaultValues(\"value\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"type\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"value\":\n\t\t\t\t\treturn {};\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AttributeTypeAndValue class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//AttributeTypeAndValue ::= Sequence {\n\t\t\t//    type     AttributeType,\n\t\t\t//    value    AttributeValue }\n\t\t\t//\n\t\t\t//AttributeType ::= OBJECT IDENTIFIER\n\t\t\t//\n\t\t\t//AttributeValue ::= ANY -- DEFINED BY AttributeType\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName] Name for entire block\n    * @property {string} [type] Name for \"type\" element\n    * @property {string} [value] Name for \"value\" element\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.type || \"\" }), new Any({ name: names.value || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"type\", \"typeValue\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, AttributeTypeAndValue.schema({\n\t\t\t\tnames: {\n\t\t\t\t\ttype: \"type\",\n\t\t\t\t\tvalue: \"typeValue\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AttributeTypeAndValue\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.type = asn1.result.type.valueBlock.toString();\n\t\t\t// noinspection JSUnresolvedVariable\n\t\t\tthis.value = asn1.result.typeValue;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [new ObjectIdentifier({ value: this.type }), this.value]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar _object = {\n\t\t\t\ttype: this.type\n\t\t\t};\n\n\t\t\tif (Object.keys(this.value).length !== 0) _object.value = this.value.toJSON();else _object.value = this.value;\n\n\t\t\treturn _object;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare two AttributeTypeAndValue values, or AttributeTypeAndValue with ArrayBuffer value\n   * @param {(AttributeTypeAndValue|ArrayBuffer)} compareTo The value compare to current\n   * @returns {boolean}\n   */\n\t\tisEqual(compareTo) {\n\t\t\tif (compareTo instanceof AttributeTypeAndValue) {\n\t\t\t\tif (this.type !== compareTo.type) return false;\n\n\t\t\t\t// noinspection OverlyComplexBooleanExpressionJS\n\t\t\t\tif (this.value instanceof Utf8String && compareTo.value instanceof Utf8String || this.value instanceof BmpString && compareTo.value instanceof BmpString || this.value instanceof UniversalString && compareTo.value instanceof UniversalString || this.value instanceof NumericString && compareTo.value instanceof NumericString || this.value instanceof PrintableString && compareTo.value instanceof PrintableString || this.value instanceof TeletexString && compareTo.value instanceof TeletexString || this.value instanceof VideotexString && compareTo.value instanceof VideotexString || this.value instanceof IA5String && compareTo.value instanceof IA5String || this.value instanceof GraphicString && compareTo.value instanceof GraphicString || this.value instanceof VisibleString && compareTo.value instanceof VisibleString || this.value instanceof GeneralString && compareTo.value instanceof GeneralString || this.value instanceof CharacterString && compareTo.value instanceof CharacterString) {\n\t\t\t\t\tvar value1 = stringPrep(this.value.valueBlock.value);\n\t\t\t\t\tvar value2 = stringPrep(compareTo.value.valueBlock.value);\n\n\t\t\t\t\tif (value1.localeCompare(value2) !== 0) return false;\n\t\t\t\t} else // Comparing as two ArrayBuffers\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isEqualBuffer(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false) return false;\n\t\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.value.valueBeforeDecode, compareTo);\n\n\t\t\treturn false;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass RelativeDistinguishedNames {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for RelativeDistinguishedNames class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {Array.<AttributeTypeAndValue>} [typesAndValues] Array of \"type and value\" objects\n   * @property {ArrayBuffer} [valueBeforeDecode] Value of the RDN before decoding from schema\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<AttributeTypeAndValue>}\n    * @description Array of \"type and value\" objects\n    */\n\t\t\tthis.typesAndValues = getParametersValue(parameters, \"typesAndValues\", RelativeDistinguishedNames.defaultValues(\"typesAndValues\"));\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description Value of the RDN before decoding from schema\n    */\n\t\t\tthis.valueBeforeDecode = getParametersValue(parameters, \"valueBeforeDecode\", RelativeDistinguishedNames.defaultValues(\"valueBeforeDecode\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"typesAndValues\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"valueBeforeDecode\":\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"typesAndValues\":\n\t\t\t\t\treturn memberValue.length === 0;\n\t\t\t\tcase \"valueBeforeDecode\":\n\t\t\t\t\treturn memberValue.byteLength === 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//RDNSequence ::= Sequence OF RelativeDistinguishedName\n\t\t\t//\n\t\t\t//RelativeDistinguishedName ::=\n\t\t\t//SET SIZE (1..MAX) OF AttributeTypeAndValue\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName] Name for entire block\n    * @property {string} [repeatedSequence] Name for \"repeatedSequence\" block\n    * @property {string} [repeatedSet] Name for \"repeatedSet\" block\n    * @property {string} [typeAndValue] Name for \"typeAndValue\" block\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.repeatedSequence || \"\",\n\t\t\t\t\tvalue: new Set({\n\t\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\t\tname: names.repeatedSet || \"\",\n\t\t\t\t\t\t\tvalue: AttributeTypeAndValue.schema(names.typeAndValue || {})\n\t\t\t\t\t\t})]\n\t\t\t\t\t})\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"RDN\", \"typesAndValues\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, RelativeDistinguishedNames.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tblockName: \"RDN\",\n\t\t\t\t\trepeatedSet: \"typesAndValues\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for RelativeDistinguishedNames\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"typesAndValues\" in asn1.result) // Could be a case when there is no \"types and values\"\n\t\t\t\tthis.typesAndValues = Array.from(asn1.result.typesAndValues, element => new AttributeTypeAndValue({ schema: element }));\n\n\t\t\t// noinspection JSUnresolvedVariable\n\t\t\tthis.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Decode stored TBS value\n\t\t\tif (this.valueBeforeDecode.byteLength === 0) // No stored encoded array, create \"from scratch\"\n\t\t\t\t{\n\t\t\t\t\treturn new Sequence({\n\t\t\t\t\t\tvalue: [new Set({\n\t\t\t\t\t\t\tvalue: Array.from(this.typesAndValues, element => element.toSchema())\n\t\t\t\t\t\t})]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\tvar asn1 = fromBER(this.valueBeforeDecode);\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn asn1.result;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\ttypesAndValues: Array.from(this.typesAndValues, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare two RDN values, or RDN with ArrayBuffer value\n   * @param {(RelativeDistinguishedNames|ArrayBuffer)} compareTo The value compare to current\n   * @returns {boolean}\n   */\n\t\tisEqual(compareTo) {\n\t\t\tif (compareTo instanceof RelativeDistinguishedNames) {\n\t\t\t\tif (this.typesAndValues.length !== compareTo.typesAndValues.length) return false;\n\n\t\t\t\tvar _iteratorNormalCompletion17 = true;\n\t\t\t\tvar _didIteratorError17 = false;\n\t\t\t\tvar _iteratorError17 = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator17 = this.typesAndValues.entries()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n\t\t\t\t\t\tvar _ref = _step17.value;\n\n\t\t\t\t\t\tvar _ref2 = _slicedToArray(_ref, 2);\n\n\t\t\t\t\t\tvar index = _ref2[0];\n\t\t\t\t\t\tvar typeAndValue = _ref2[1];\n\n\t\t\t\t\t\tif (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false) return false;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError17 = true;\n\t\t\t\t\t_iteratorError17 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion17 && _iterator17.return) {\n\t\t\t\t\t\t\t_iterator17.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError17) {\n\t\t\t\t\t\t\tthrow _iteratorError17;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (compareTo instanceof ArrayBuffer) return isEqualBuffer(this.valueBeforeDecode, compareTo);\n\n\t\t\treturn false;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\tfunction CertificationRequestInfo() {\n\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t//CertificationRequestInfo ::= SEQUENCE {\n\t\t//    version       INTEGER { v1(0) } (v1,...),\n\t\t//    subject       Name,\n\t\t//    subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\n\t\t//    attributes    [0] Attributes{{ CRIAttributes }}\n\t\t//}\n\n\t\t/**\n   * @type {Object}\n   * @property {string} [blockName]\n   * @property {string} [CertificationRequestInfo]\n   * @property {string} [CertificationRequestInfoVersion]\n   * @property {string} [subject]\n   * @property {string} [CertificationRequestInfoAttributes]\n   * @property {string} [attributes]\n   */\n\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\treturn new Sequence({\n\t\t\tname: names.CertificationRequestInfo || \"CertificationRequestInfo\",\n\t\t\tvalue: [new Integer({ name: names.CertificationRequestInfoVersion || \"CertificationRequestInfo.version\" }), RelativeDistinguishedNames.schema(names.subject || {\n\t\t\t\tnames: {\n\t\t\t\t\tblockName: \"CertificationRequestInfo.subject\"\n\t\t\t\t}\n\t\t\t}), PublicKeyInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tblockName: \"CertificationRequestInfo.subjectPublicKeyInfo\"\n\t\t\t\t}\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t},\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\toptional: true, // Because OpenSSL makes wrong \"attributes\" field\n\t\t\t\t\tname: names.CertificationRequestInfoAttributes || \"CertificationRequestInfo.attributes\",\n\t\t\t\t\tvalue: Attribute.schema(names.attributes || {})\n\t\t\t\t})]\n\t\t\t})]\n\t\t});\n\t}\n\t//**************************************************************************************\n\t/**\n  * Class from RFC2986\n  */\n\tclass CertificationRequest {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for Attribute class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description tbs\n    */\n\t\t\tthis.tbs = getParametersValue(parameters, \"tbs\", CertificationRequest.defaultValues(\"tbs\"));\n\t\t\t/**\n    * @type {number}\n    * @description version\n    */\n\t\t\tthis.version = getParametersValue(parameters, \"version\", CertificationRequest.defaultValues(\"version\"));\n\t\t\t/**\n    * @type {RelativeDistinguishedNames}\n    * @description subject\n    */\n\t\t\tthis.subject = getParametersValue(parameters, \"subject\", CertificationRequest.defaultValues(\"subject\"));\n\t\t\t/**\n    * @type {PublicKeyInfo}\n    * @description subjectPublicKeyInfo\n    */\n\t\t\tthis.subjectPublicKeyInfo = getParametersValue(parameters, \"subjectPublicKeyInfo\", CertificationRequest.defaultValues(\"subjectPublicKeyInfo\"));\n\n\t\t\tif (\"attributes\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<Attribute>}\n     * @description attributes\n     */\n\t\t\t\tthis.attributes = getParametersValue(parameters, \"attributes\", CertificationRequest.defaultValues(\"attributes\"));\n\n\t\t\t/**\n    * @type {AlgorithmIdentifier}\n    * @description signatureAlgorithm\n    */\n\t\t\tthis.signatureAlgorithm = getParametersValue(parameters, \"signatureAlgorithm\", CertificationRequest.defaultValues(\"signatureAlgorithm\"));\n\t\t\t/**\n    * @type {BitString}\n    * @description signatureAlgorithm\n    */\n\t\t\tthis.signatureValue = getParametersValue(parameters, \"signatureValue\", CertificationRequest.defaultValues(\"signatureValue\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"tbs\":\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"subject\":\n\t\t\t\t\treturn new RelativeDistinguishedNames();\n\t\t\t\tcase \"subjectPublicKeyInfo\":\n\t\t\t\t\treturn new PublicKeyInfo();\n\t\t\t\tcase \"attributes\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"signatureAlgorithm\":\n\t\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\t\tcase \"signatureValue\":\n\t\t\t\t\treturn new BitString();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for CertificationRequest class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//CertificationRequest ::= SEQUENCE {\n\t\t\t//    certificationRequestInfo CertificationRequestInfo,\n\t\t\t//    signatureAlgorithm       AlgorithmIdentifier{{ SignatureAlgorithms }},\n\t\t\t//    signature                BIT STRING\n\t\t\t//}\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [certificationRequestInfo]\n    * @property {string} [signatureAlgorithm]\n    * @property {string} [signatureValue]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [CertificationRequestInfo(names.certificationRequestInfo || {}), new Sequence({\n\t\t\t\t\tname: names.signatureAlgorithm || \"signatureAlgorithm\",\n\t\t\t\t\tvalue: [new ObjectIdentifier(), new Any({ optional: true })]\n\t\t\t\t}), new BitString({ name: names.signatureValue || \"signatureValue\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"CertificationRequestInfo\", \"CertificationRequestInfo.version\", \"CertificationRequestInfo.subject\", \"CertificationRequestInfo.subjectPublicKeyInfo\", \"CertificationRequestInfo.attributes\", \"signatureAlgorithm\", \"signatureValue\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, CertificationRequest.schema());\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificationRequest\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.tbs = asn1.result.CertificationRequestInfo.valueBeforeDecode;\n\n\t\t\tthis.version = asn1.result[\"CertificationRequestInfo.version\"].valueBlock.valueDec;\n\t\t\tthis.subject = new RelativeDistinguishedNames({ schema: asn1.result[\"CertificationRequestInfo.subject\"] });\n\t\t\tthis.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[\"CertificationRequestInfo.subjectPublicKeyInfo\"] });\n\t\t\tif (\"CertificationRequestInfo.attributes\" in asn1.result) this.attributes = Array.from(asn1.result[\"CertificationRequestInfo.attributes\"], element => new Attribute({ schema: element }));\n\n\t\t\tthis.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });\n\t\t\tthis.signatureValue = asn1.result.signatureValue;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Aux function making ASN1js Sequence from current TBS\n   * @returns {Sequence}\n   */\n\t\tencodeTBS() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [new Integer({ value: this.version }), this.subject.toSchema(), this.subjectPublicKeyInfo.toSchema()];\n\n\t\t\tif (\"attributes\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: Array.from(this.attributes, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\tvar encodeFlag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\t\t//region Decode stored TBS value\n\t\t\tvar tbsSchema = void 0;\n\n\t\t\tif (encodeFlag === false) {\n\t\t\t\tif (this.tbs.byteLength === 0) // No stored TBS part\n\t\t\t\t\treturn CertificationRequest.schema();\n\n\t\t\t\ttbsSchema = fromBER(this.tbs).result;\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//region Create TBS schema via assembling from TBS parts\n\t\t\telse tbsSchema = this.encodeTBS();\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [tbsSchema, this.signatureAlgorithm.toSchema(), this.signatureValue]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {\n\t\t\t\ttbs: bufferToHexCodes(this.tbs, 0, this.tbs.byteLength),\n\t\t\t\tversion: this.version,\n\t\t\t\tsubject: this.subject.toJSON(),\n\t\t\t\tsubjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),\n\t\t\t\tsignatureAlgorithm: this.signatureAlgorithm.toJSON(),\n\t\t\t\tsignatureValue: this.signatureValue.toJSON()\n\t\t\t};\n\n\t\t\tif (\"attributes\" in this) object.attributes = Array.from(this.attributes, element => element.toJSON());\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Makes signature for currect certification request\n   * @param {Object} privateKey WebCrypto private key\n   * @param {string} [hashAlgorithm=SHA-1] String representing current hashing algorithm\n   */\n\t\tsign(privateKey) {\n\t\t\tvar hashAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"SHA-1\";\n\n\t\t\t//region Initial checking\n\t\t\t//region Get a private key from function parameter\n\t\t\tif (typeof privateKey === \"undefined\") return Promise.reject(\"Need to provide a private key for signing\");\n\t\t\t//endregion\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar sequence = Promise.resolve();\n\t\t\tvar parameters = void 0;\n\n\t\t\tvar engine = getEngine();\n\t\t\t//endregion\n\n\t\t\t//region Get a \"default parameters\" for current algorithm and set correct signature algorithm\n\t\t\tsequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));\n\n\t\t\tsequence = sequence.then(result => {\n\t\t\t\tparameters = result.parameters;\n\t\t\t\tthis.signatureAlgorithm = result.signatureAlgorithm;\n\t\t\t});\n\t\t\t//endregion\n\n\t\t\t//region Create TBS data for signing\n\t\t\tsequence = sequence.then(() => {\n\t\t\t\tthis.tbs = this.encodeTBS().toBER(false);\n\t\t\t});\n\t\t\t//endregion\n\n\t\t\t//region Signing TBS data on provided private key\n\t\t\tsequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));\n\n\t\t\tsequence = sequence.then(result => {\n\t\t\t\tthis.signatureValue = new BitString({ valueHex: result });\n\t\t\t});\n\t\t\t//endregion\n\n\t\t\treturn sequence;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Verify existing certification request signature\n   * @returns {*}\n   */\n\t\tverify() {\n\t\t\treturn getEngine().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Importing public key for current certificate request\n   */\n\t\tgetPublicKey() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n\t\t\treturn getEngine().getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass SubjectDirectoryAttributes {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for SubjectDirectoryAttributes class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<Attribute>}\n    * @description attributes\n    */\n\t\t\tthis.attributes = getParametersValue(parameters, \"attributes\", SubjectDirectoryAttributes.defaultValues(\"attributes\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"attributes\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for SubjectDirectoryAttributes class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// SubjectDirectoryAttributes OID ::= 2.5.29.9\n\t\t\t//\n\t\t\t//SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [utcTimeName] Name for \"utcTimeName\" choice\n    * @property {string} [generalTimeName] Name for \"generalTimeName\" choice\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.attributes || \"\",\n\t\t\t\t\tvalue: Attribute.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"attributes\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, SubjectDirectoryAttributes.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tattributes: \"attributes\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for SubjectDirectoryAttributes\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.attributes, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tattributes: Array.from(this.attributes, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PrivateKeyUsagePeriod {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PrivateKeyUsagePeriod class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"notBefore\" in parameters)\n\t\t\t\t/**\n     * @type {Date}\n     * @description notBefore\n     */\n\t\t\t\tthis.notBefore = getParametersValue(parameters, \"notBefore\", PrivateKeyUsagePeriod.defaultValues(\"notBefore\"));\n\n\t\t\tif (\"notAfter\" in parameters)\n\t\t\t\t/**\n     * @type {Date}\n     * @description notAfter\n     */\n\t\t\t\tthis.notAfter = getParametersValue(parameters, \"notAfter\", PrivateKeyUsagePeriod.defaultValues(\"notAfter\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"notBefore\":\n\t\t\t\t\treturn new Date();\n\t\t\t\tcase \"notAfter\":\n\t\t\t\t\treturn new Date();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// PrivateKeyUsagePeriod OID ::= 2.5.29.16\n\t\t\t//\n\t\t\t//PrivateKeyUsagePeriod ::= SEQUENCE {\n\t\t\t//    notBefore       [0]     GeneralizedTime OPTIONAL,\n\t\t\t//    notAfter        [1]     GeneralizedTime OPTIONAL }\n\t\t\t//-- either notBefore or notAfter MUST be present\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [notBefore]\n    * @property {string} [notAfter]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Primitive({\n\t\t\t\t\tname: names.notBefore || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t}\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.notAfter || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t}\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"notBefore\", \"notAfter\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tnotBefore: \"notBefore\",\n\t\t\t\t\tnotAfter: \"notAfter\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PrivateKeyUsagePeriod\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"notBefore\" in asn1.result) {\n\t\t\t\tvar localNotBefore = new GeneralizedTime();\n\t\t\t\tlocalNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);\n\t\t\t\tthis.notBefore = localNotBefore.toDate();\n\t\t\t}\n\n\t\t\tif (\"notAfter\" in asn1.result) {\n\t\t\t\tvar localNotAfter = new GeneralizedTime({ valueHex: asn1.result.notAfter.valueBlock.valueHex });\n\t\t\t\tlocalNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);\n\t\t\t\tthis.notAfter = localNotAfter.toDate();\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"notBefore\" in this) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new GeneralizedTime({ valueDate: this.notBefore }).valueBlock.valueHex\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"notAfter\" in this) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new GeneralizedTime({ valueDate: this.notAfter }).valueBlock.valueHex\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"notBefore\" in this) object.notBefore = this.notBefore;\n\n\t\t\tif (\"notAfter\" in this) object.notAfter = this.notAfter;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t//region Additional asn1js schema elements existing inside GENERAL_NAME schema\n\t//**************************************************************************************\n\t/**\n  * Schema for \"builtInStandardAttributes\" of \"ORAddress\"\n  * @param {Object} parameters\n  * @property {Object} [names]\n  * @param {boolean} optional\n  * @returns {Sequence}\n  */\n\tfunction builtInStandardAttributes() {\n\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\tvar optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t//builtInStandardAttributes ::= Sequence {\n\t\t//    country-name                  CountryName OPTIONAL,\n\t\t//    administration-domain-name    AdministrationDomainName OPTIONAL,\n\t\t//    network-address           [0] IMPLICIT NetworkAddress OPTIONAL,\n\t\t//    terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,\n\t\t//    private-domain-name       [2] PrivateDomainName OPTIONAL,\n\t\t//    organization-name         [3] IMPLICIT OrganizationName OPTIONAL,\n\t\t//    numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier OPTIONAL,\n\t\t//    personal-name             [5] IMPLICIT PersonalName OPTIONAL,\n\t\t//    organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL }\n\n\t\t/**\n   * @type {Object}\n   * @property {string} [country_name]\n   * @property {string} [administration_domain_name]\n   * @property {string} [network_address]\n   * @property {string} [terminal_identifier]\n   * @property {string} [private_domain_name]\n   * @property {string} [organization_name]\n   * @property {string} [numeric_user_identifier]\n   * @property {string} [personal_name]\n   * @property {string} [organizational_unit_names]\n   */\n\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\treturn new Sequence({\n\t\t\toptional,\n\t\t\tvalue: [new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 2, // APPLICATION-SPECIFIC\n\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t},\n\t\t\t\tname: names.country_name || \"\",\n\t\t\t\tvalue: [new Choice({\n\t\t\t\t\tvalue: [new NumericString(), new PrintableString()]\n\t\t\t\t})]\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 2, // APPLICATION-SPECIFIC\n\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t},\n\t\t\t\tname: names.administration_domain_name || \"\",\n\t\t\t\tvalue: [new Choice({\n\t\t\t\t\tvalue: [new NumericString(), new PrintableString()]\n\t\t\t\t})]\n\t\t\t}), new Primitive({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t},\n\t\t\t\tname: names.network_address || \"\",\n\t\t\t\tisHexOnly: true\n\t\t\t}), new Primitive({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t},\n\t\t\t\tname: names.terminal_identifier || \"\",\n\t\t\t\tisHexOnly: true\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t},\n\t\t\t\tname: names.private_domain_name || \"\",\n\t\t\t\tvalue: [new Choice({\n\t\t\t\t\tvalue: [new NumericString(), new PrintableString()]\n\t\t\t\t})]\n\t\t\t}), new Primitive({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t},\n\t\t\t\tname: names.organization_name || \"\",\n\t\t\t\tisHexOnly: true\n\t\t\t}), new Primitive({\n\t\t\t\toptional: true,\n\t\t\t\tname: names.numeric_user_identifier || \"\",\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 4 // [4]\n\t\t\t\t},\n\t\t\t\tisHexOnly: true\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tname: names.personal_name || \"\",\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 5 // [5]\n\t\t\t\t},\n\t\t\t\tvalue: [new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tisHexOnly: true\n\t\t\t\t}), new Primitive({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tisHexOnly: true\n\t\t\t\t}), new Primitive({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tisHexOnly: true\n\t\t\t\t}), new Primitive({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t},\n\t\t\t\t\tisHexOnly: true\n\t\t\t\t})]\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tname: names.organizational_unit_names || \"\",\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 6 // [6]\n\t\t\t\t},\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tvalue: new PrintableString()\n\t\t\t\t})]\n\t\t\t})]\n\t\t});\n\t}\n\t//**************************************************************************************\n\t/**\n  * Schema for \"builtInDomainDefinedAttributes\" of \"ORAddress\"\n  * @param {boolean} optional\n  * @returns {Sequence}\n  */\n\tfunction builtInDomainDefinedAttributes() {\n\t\tvar optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\treturn new Sequence({\n\t\t\toptional,\n\t\t\tvalue: [new PrintableString(), new PrintableString()]\n\t\t});\n\t}\n\t//**************************************************************************************\n\t/**\n  * Schema for \"builtInDomainDefinedAttributes\" of \"ORAddress\"\n  * @param {boolean} optional\n  * @returns {Set}\n  */\n\tfunction extensionAttributes() {\n\t\tvar optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\treturn new Set({\n\t\t\toptional,\n\t\t\tvalue: [new Primitive({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t},\n\t\t\t\tisHexOnly: true\n\t\t\t}), new Constructed({\n\t\t\t\toptional: true,\n\t\t\t\tidBlock: {\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t},\n\t\t\t\tvalue: [new Any()]\n\t\t\t})]\n\t\t});\n\t}\n\t//**************************************************************************************\n\t//endregion\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass GeneralName {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for GeneralName class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {number} [type] value type - from a tagged value (0 for \"otherName\", 1 for \"rfc822Name\" etc.)\n   * @property {Object} [value] asn1js object having GENERAL_NAME value (type depends on \"type\" value)\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {number}\n    * @description value type - from a tagged value (0 for \"otherName\", 1 for \"rfc822Name\" etc.)\n    */\n\t\t\tthis.type = getParametersValue(parameters, \"type\", GeneralName.defaultValues(\"type\"));\n\t\t\t/**\n    * @type {Object}\n    * @description asn1js object having GENERAL_NAME value (type depends on \"type\" value)\n    */\n\t\t\tthis.value = getParametersValue(parameters, \"value\", GeneralName.defaultValues(\"value\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"type\":\n\t\t\t\t\treturn 9;\n\t\t\t\tcase \"value\":\n\t\t\t\t\treturn {};\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for GeneralName class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"type\":\n\t\t\t\t\treturn memberValue === GeneralName.defaultValues(memberName);\n\t\t\t\tcase \"value\":\n\t\t\t\t\treturn Object.keys(memberValue).length === 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for GeneralName class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//GeneralName ::= Choice {\n\t\t\t//    otherName                       [0]     OtherName,\n\t\t\t//    rfc822Name                      [1]     IA5String,\n\t\t\t//    dNSName                         [2]     IA5String,\n\t\t\t//    x400Address                     [3]     ORAddress,\n\t\t\t//    directoryName                   [4]     value,\n\t\t\t//    ediPartyName                    [5]     EDIPartyName,\n\t\t\t//    uniformResourceIdentifier       [6]     IA5String,\n\t\t\t//    iPAddress                       [7]     OCTET STRING,\n\t\t\t//    registeredID                    [8]     OBJECT IDENTIFIER }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {Object} [directoryName]\n    * @property {Object} [builtInStandardAttributes]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Choice({\n\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tvalue: [new ObjectIdentifier(), new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [new Any()]\n\t\t\t\t\t})]\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t}\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t}\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t},\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tvalue: [builtInStandardAttributes(names.builtInStandardAttributes || {}, false), builtInDomainDefinedAttributes(true), extensionAttributes(true)]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 4 // [4]\n\t\t\t\t\t},\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tvalue: [RelativeDistinguishedNames.schema(names.directoryName || {})]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 5 // [5]\n\t\t\t\t\t},\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [new Choice({\n\t\t\t\t\t\t\tvalue: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]\n\t\t\t\t\t\t})]\n\t\t\t\t\t}), new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [new Choice({\n\t\t\t\t\t\t\tvalue: [new TeletexString(), new PrintableString(), new UniversalString(), new Utf8String(), new BmpString()]\n\t\t\t\t\t\t})]\n\t\t\t\t\t})]\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 6 // [6]\n\t\t\t\t\t}\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 7 // [7]\n\t\t\t\t\t}\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.blockName || \"\",\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 8 // [8]\n\t\t\t\t\t}\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"blockName\", \"otherName\", \"rfc822Name\", \"dNSName\", \"x400Address\", \"directoryName\", \"ediPartyName\", \"uniformResourceIdentifier\", \"iPAddress\", \"registeredID\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, GeneralName.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tblockName: \"blockName\",\n\t\t\t\t\totherName: \"otherName\",\n\t\t\t\t\trfc822Name: \"rfc822Name\",\n\t\t\t\t\tdNSName: \"dNSName\",\n\t\t\t\t\tx400Address: \"x400Address\",\n\t\t\t\t\tdirectoryName: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"directoryName\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tediPartyName: \"ediPartyName\",\n\t\t\t\t\tuniformResourceIdentifier: \"uniformResourceIdentifier\",\n\t\t\t\t\tiPAddress: \"iPAddress\",\n\t\t\t\t\tregisteredID: \"registeredID\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralName\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.type = asn1.result.blockName.idBlock.tagNumber;\n\n\t\t\tswitch (this.type) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// otherName\n\t\t\t\t\tthis.value = asn1.result.blockName;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // rfc822Name + dNSName + uniformResourceIdentifier\n\t\t\t\tcase 2:\n\t\t\t\tcase 6:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar value = asn1.result.blockName;\n\n\t\t\t\t\t\tvalue.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\t\t\t\tvalue.idBlock.tagNumber = 22; // IA5STRING\n\n\t\t\t\t\t\tvar valueBER = value.toBER(false);\n\n\t\t\t\t\t\tthis.value = fromBER(valueBER).result.valueBlock.value;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// x400Address\n\t\t\t\t\tthis.value = asn1.result.blockName;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t// directoryName\n\t\t\t\t\tthis.value = new RelativeDistinguishedNames({ schema: asn1.result.directoryName });\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\t// ediPartyName\n\t\t\t\t\tthis.value = asn1.result.ediPartyName;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// iPAddress\n\t\t\t\t\tthis.value = new OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\t// registeredID\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _value2 = asn1.result.blockName;\n\n\t\t\t\t\t\t_value2.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\t\t\t\t_value2.idBlock.tagNumber = 6; // ObjectIdentifier\n\n\t\t\t\t\t\tvar _valueBER = _value2.toBER(false);\n\n\t\t\t\t\t\tthis.value = fromBER(_valueBER).result.valueBlock.toString(); // Getting a string representation of the ObjectIdentifier\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\tswitch (this.type) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 3:\n\t\t\t\tcase 5:\n\t\t\t\t\treturn new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: this.type\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [this.value]\n\t\t\t\t\t});\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 6:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar value = new IA5String({ value: this.value });\n\n\t\t\t\t\t\tvalue.idBlock.tagClass = 3;\n\t\t\t\t\t\tvalue.idBlock.tagNumber = this.type;\n\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\tcase 4:\n\t\t\t\t\treturn new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 4\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [this.value.toSchema()]\n\t\t\t\t\t});\n\t\t\t\tcase 7:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _value3 = this.value;\n\n\t\t\t\t\t\t_value3.idBlock.tagClass = 3;\n\t\t\t\t\t\t_value3.idBlock.tagNumber = this.type;\n\n\t\t\t\t\t\treturn _value3;\n\t\t\t\t\t}\n\t\t\t\tcase 8:\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _value4 = new ObjectIdentifier({ value: this.value });\n\n\t\t\t\t\t\t_value4.idBlock.tagClass = 3;\n\t\t\t\t\t\t_value4.idBlock.tagNumber = this.type;\n\n\t\t\t\t\t\treturn _value4;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\treturn GeneralName.schema();\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar _object = {\n\t\t\t\ttype: this.type\n\t\t\t};\n\n\t\t\tif (typeof this.value === \"string\") _object.value = this.value;else _object.value = this.value.toJSON();\n\n\t\t\treturn _object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass AltName {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for AltName class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<GeneralName>}\n    * @description type\n    */\n\t\t\tthis.altNames = getParametersValue(parameters, \"altNames\", AltName.defaultValues(\"altNames\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"altNames\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AltName class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// SubjectAltName OID ::= 2.5.29.17\n\t\t\t// IssuerAltName OID ::= 2.5.29.18\n\t\t\t//\n\t\t\t// AltName ::= GeneralNames\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [altNames]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.altNames || \"\",\n\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"altNames\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, AltName.schema({\n\t\t\t\tnames: {\n\t\t\t\t\taltNames: \"altNames\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AltName\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"altNames\" in asn1.result) this.altNames = Array.from(asn1.result.altNames, element => new GeneralName({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.altNames, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\taltNames: Array.from(this.altNames, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass BasicConstraints {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for BasicConstraints class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {Object} [cA]\n   * @property {Object} [pathLenConstraint]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {boolean}\n    * @description cA\n    */\n\t\t\tthis.cA = getParametersValue(parameters, \"cA\", false);\n\n\t\t\tif (\"pathLenConstraint\" in parameters)\n\t\t\t\t/**\n     * @type {number|Integer}\n     * @description pathLenConstraint\n     */\n\t\t\t\tthis.pathLenConstraint = getParametersValue(parameters, \"pathLenConstraint\", 0);\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"cA\":\n\t\t\t\t\treturn false;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for BasicConstraints class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// BasicConstraints OID ::= 2.5.29.19\n\t\t\t//\n\t\t\t//BasicConstraints ::= SEQUENCE {\n\t\t\t//    cA                      BOOLEAN DEFAULT FALSE,\n\t\t\t//    pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [cA]\n    * @property {string} [pathLenConstraint]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Boolean({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tname: names.cA || \"\"\n\t\t\t\t}), new Integer({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tname: names.pathLenConstraint || \"\"\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"cA\", \"pathLenConstraint\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, BasicConstraints.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tcA: \"cA\",\n\t\t\t\t\tpathLenConstraint: \"pathLenConstraint\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for BasicConstraints\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"cA\" in asn1.result) this.cA = asn1.result.cA.valueBlock.value;\n\n\t\t\tif (\"pathLenConstraint\" in asn1.result) {\n\t\t\t\tif (asn1.result.pathLenConstraint.valueBlock.isHexOnly) this.pathLenConstraint = asn1.result.pathLenConstraint;else this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (this.cA !== BasicConstraints.defaultValues(\"cA\")) outputArray.push(new Boolean({ value: this.cA }));\n\n\t\t\tif (\"pathLenConstraint\" in this) {\n\t\t\t\tif (this.pathLenConstraint instanceof Integer) outputArray.push(this.pathLenConstraint);else outputArray.push(new Integer({ value: this.pathLenConstraint }));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (this.cA !== BasicConstraints.defaultValues(\"cA\")) object.cA = this.cA;\n\n\t\t\tif (\"pathLenConstraint\" in this) {\n\t\t\t\tif (this.pathLenConstraint instanceof Integer) object.pathLenConstraint = this.pathLenConstraint.toJSON();else object.pathLenConstraint = this.pathLenConstraint;\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass IssuingDistributionPoint {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for IssuingDistributionPoint class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"distributionPoint\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralName>|RelativeDistinguishedNames}\n     * @description distributionPoint\n     */\n\t\t\t\tthis.distributionPoint = getParametersValue(parameters, \"distributionPoint\", IssuingDistributionPoint.defaultValues(\"distributionPoint\"));\n\n\t\t\t/**\n    * @type {boolean}\n    * @description onlyContainsUserCerts\n    */\n\t\t\tthis.onlyContainsUserCerts = getParametersValue(parameters, \"onlyContainsUserCerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\"));\n\n\t\t\t/**\n    * @type {boolean}\n    * @description onlyContainsCACerts\n    */\n\t\t\tthis.onlyContainsCACerts = getParametersValue(parameters, \"onlyContainsCACerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\"));\n\n\t\t\tif (\"onlySomeReasons\" in parameters)\n\t\t\t\t/**\n     * @type {number}\n     * @description onlySomeReasons\n     */\n\t\t\t\tthis.onlySomeReasons = getParametersValue(parameters, \"onlySomeReasons\", IssuingDistributionPoint.defaultValues(\"onlySomeReasons\"));\n\n\t\t\t/**\n    * @type {boolean}\n    * @description indirectCRL\n    */\n\t\t\tthis.indirectCRL = getParametersValue(parameters, \"indirectCRL\", IssuingDistributionPoint.defaultValues(\"indirectCRL\"));\n\n\t\t\t/**\n    * @type {boolean}\n    * @description onlyContainsAttributeCerts\n    */\n\t\t\tthis.onlyContainsAttributeCerts = getParametersValue(parameters, \"onlyContainsAttributeCerts\", IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"distributionPoint\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"onlyContainsUserCerts\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"onlyContainsCACerts\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"onlySomeReasons\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"indirectCRL\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"onlyContainsAttributeCerts\":\n\t\t\t\t\treturn false;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for IssuingDistributionPoint class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// IssuingDistributionPoint OID ::= 2.5.29.28\n\t\t\t//\n\t\t\t//IssuingDistributionPoint ::= SEQUENCE {\n\t\t\t//    distributionPoint          [0] DistributionPointName OPTIONAL,\n\t\t\t//    onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,\n\t\t\t//    onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,\n\t\t\t//    onlySomeReasons            [3] ReasonFlags OPTIONAL,\n\t\t\t//    indirectCRL                [4] BOOLEAN DEFAULT FALSE,\n\t\t\t//    onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }\n\t\t\t//\n\t\t\t//ReasonFlags ::= BIT STRING {\n\t\t\t//    unused                  (0),\n\t\t\t//    keyCompromise           (1),\n\t\t\t//    cACompromise            (2),\n\t\t\t//    affiliationChanged      (3),\n\t\t\t//    superseded              (4),\n\t\t\t//    cessationOfOperation    (5),\n\t\t\t//    certificateHold         (6),\n\t\t\t//    privilegeWithdrawn      (7),\n\t\t\t//    aACompromise            (8) }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [distributionPoint]\n    * @property {string} [distributionPointNames]\n    * @property {string} [onlyContainsUserCerts]\n    * @property {string} [onlyContainsCACerts]\n    * @property {string} [onlySomeReasons]\n    * @property {string} [indirectCRL]\n    * @property {string} [onlyContainsAttributeCerts]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Choice({\n\t\t\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\t\t\tname: names.distributionPoint || \"\",\n\t\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\t\t\tname: names.distributionPointNames || \"\",\n\t\t\t\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t\t\t\t})]\n\t\t\t\t\t\t}), new Constructed({\n\t\t\t\t\t\t\tname: names.distributionPoint || \"\",\n\t\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: RelativeDistinguishedNames.schema().valueBlock.value\n\t\t\t\t\t\t})]\n\t\t\t\t\t})]\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.onlyContainsUserCerts || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT boolean value\n\t\t\t\tnew Primitive({\n\t\t\t\t\tname: names.onlyContainsCACerts || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT boolean value\n\t\t\t\tnew Primitive({\n\t\t\t\t\tname: names.onlySomeReasons || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT bitstring value\n\t\t\t\tnew Primitive({\n\t\t\t\t\tname: names.indirectCRL || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 4 // [4]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT boolean value\n\t\t\t\tnew Primitive({\n\t\t\t\t\tname: names.onlyContainsAttributeCerts || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 5 // [5]\n\t\t\t\t\t}\n\t\t\t\t}) // IMPLICIT boolean value\n\t\t\t\t]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"distributionPoint\", \"distributionPointNames\", \"onlyContainsUserCerts\", \"onlyContainsCACerts\", \"onlySomeReasons\", \"indirectCRL\", \"onlyContainsAttributeCerts\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, IssuingDistributionPoint.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tdistributionPoint: \"distributionPoint\",\n\t\t\t\t\tdistributionPointNames: \"distributionPointNames\",\n\t\t\t\t\tonlyContainsUserCerts: \"onlyContainsUserCerts\",\n\t\t\t\t\tonlyContainsCACerts: \"onlyContainsCACerts\",\n\t\t\t\t\tonlySomeReasons: \"onlySomeReasons\",\n\t\t\t\t\tindirectCRL: \"indirectCRL\",\n\t\t\t\t\tonlyContainsAttributeCerts: \"onlyContainsAttributeCerts\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for IssuingDistributionPoint\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"distributionPoint\" in asn1.result) {\n\t\t\t\tswitch (true) {\n\t\t\t\t\tcase asn1.result.distributionPoint.idBlock.tagNumber === 0:\n\t\t\t\t\t\t// GENERAL_NAMES variant\n\t\t\t\t\t\tthis.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase asn1.result.distributionPoint.idBlock.tagNumber === 1:\n\t\t\t\t\t\t// RDN variant\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.distributionPoint = new RelativeDistinguishedNames({\n\t\t\t\t\t\t\t\tschema: new Sequence({\n\t\t\t\t\t\t\t\t\tvalue: asn1.result.distributionPoint.valueBlock.value\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"onlyContainsUserCerts\" in asn1.result) {\n\t\t\t\tvar view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);\n\t\t\t\tthis.onlyContainsUserCerts = view[0] !== 0x00;\n\t\t\t}\n\n\t\t\tif (\"onlyContainsCACerts\" in asn1.result) {\n\t\t\t\tvar _view4 = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);\n\t\t\t\tthis.onlyContainsCACerts = _view4[0] !== 0x00;\n\t\t\t}\n\n\t\t\tif (\"onlySomeReasons\" in asn1.result) {\n\t\t\t\tvar _view5 = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);\n\t\t\t\tthis.onlySomeReasons = _view5[0];\n\t\t\t}\n\n\t\t\tif (\"indirectCRL\" in asn1.result) {\n\t\t\t\tvar _view6 = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);\n\t\t\t\tthis.indirectCRL = _view6[0] !== 0x00;\n\t\t\t}\n\n\t\t\tif (\"onlyContainsAttributeCerts\" in asn1.result) {\n\t\t\t\tvar _view7 = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);\n\t\t\t\tthis.onlyContainsAttributeCerts = _view7[0] !== 0x00;\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"distributionPoint\" in this) {\n\t\t\t\tvar value = void 0;\n\n\t\t\t\tif (this.distributionPoint instanceof Array) {\n\t\t\t\t\tvalue = new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: Array.from(this.distributionPoint, element => element.toSchema())\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvalue = this.distributionPoint.toSchema();\n\n\t\t\t\t\tvalue.idBlock.tagClass = 3; // CONTEXT - SPECIFIC\n\t\t\t\t\tvalue.idBlock.tagNumber = 1; // [1]\n\t\t\t\t}\n\n\t\t\t\toutputArray.push(value);\n\t\t\t}\n\n\t\t\tif (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\")) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new Uint8Array([0xFF]).buffer\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\")) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new Uint8Array([0xFF]).buffer\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"onlySomeReasons\" in this) {\n\t\t\t\tvar buffer = new ArrayBuffer(1);\n\t\t\t\tvar view = new Uint8Array(buffer);\n\n\t\t\t\tview[0] = this.onlySomeReasons;\n\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 3 // [3]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: buffer\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (this.indirectCRL !== IssuingDistributionPoint.defaultValues(\"indirectCRL\")) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 4 // [4]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new Uint8Array([0xFF]).buffer\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\")) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 5 // [5]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: new Uint8Array([0xFF]).buffer\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"distributionPoint\" in this) {\n\t\t\t\tif (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();\n\t\t\t}\n\n\t\t\tif (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsUserCerts\")) object.onlyContainsUserCerts = this.onlyContainsUserCerts;\n\n\t\t\tif (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsCACerts\")) object.onlyContainsCACerts = this.onlyContainsCACerts;\n\n\t\t\tif (\"onlySomeReasons\" in this) object.onlySomeReasons = this.onlySomeReasons;\n\n\t\t\tif (this.indirectCRL !== IssuingDistributionPoint.defaultValues(\"indirectCRL\")) object.indirectCRL = this.indirectCRL;\n\n\t\t\tif (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(\"onlyContainsAttributeCerts\")) object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass GeneralNames {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for GeneralNames class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<GeneralName>}\n    * @description Array of \"general names\"\n    */\n\t\t\tthis.names = getParametersValue(parameters, \"names\", GeneralNames.defaultValues(\"names\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"names\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for GeneralNames class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @param {boolean} [optional=false] Flag would be element optional or not\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\tvar optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} utcTimeName Name for \"utcTimeName\" choice\n    * @property {string} generalTimeName Name for \"generalTimeName\" choice\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\toptional,\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.generalNames || \"\",\n\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"names\", \"generalNames\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, GeneralNames.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tblockName: \"names\",\n\t\t\t\t\tgeneralNames: \"generalNames\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralNames\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.names = Array.from(asn1.result.generalNames, element => new GeneralName({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.names, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tnames: Array.from(this.names, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass GeneralSubtree {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for GeneralSubtree class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {GeneralName}\n    * @description base\n    */\n\t\t\tthis.base = getParametersValue(parameters, \"base\", GeneralSubtree.defaultValues(\"base\"));\n\n\t\t\t/**\n    * @type {number|Integer}\n    * @description base\n    */\n\t\t\tthis.minimum = getParametersValue(parameters, \"minimum\", GeneralSubtree.defaultValues(\"minimum\"));\n\n\t\t\tif (\"maximum\" in parameters)\n\t\t\t\t/**\n     * @type {number|Integer}\n     * @description minimum\n     */\n\t\t\t\tthis.maximum = getParametersValue(parameters, \"maximum\", GeneralSubtree.defaultValues(\"maximum\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"base\":\n\t\t\t\t\treturn new GeneralName();\n\t\t\t\tcase \"minimum\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"maximum\":\n\t\t\t\t\treturn 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for GeneralSubtree class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//GeneralSubtree ::= SEQUENCE {\n\t\t\t//    base                    GeneralName,\n\t\t\t//    minimum         [0]     BaseDistance DEFAULT 0,\n\t\t\t//    maximum         [1]     BaseDistance OPTIONAL }\n\t\t\t//\n\t\t\t//BaseDistance ::= INTEGER (0..MAX)\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [base]\n    * @property {string} [minimum]\n    * @property {string} [maximum]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [GeneralName.schema(names.base || {}), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Integer({ name: names.minimum || \"\" })]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Integer({ name: names.maximum || \"\" })]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"base\", \"minimum\", \"maximum\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, GeneralSubtree.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tbase: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"base\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tminimum: \"minimum\",\n\t\t\t\t\tmaximum: \"maximum\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for GeneralSubtree\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.base = new GeneralName({ schema: asn1.result.base });\n\n\t\t\tif (\"minimum\" in asn1.result) {\n\t\t\t\tif (asn1.result.minimum.valueBlock.isHexOnly) this.minimum = asn1.result.minimum;else this.minimum = asn1.result.minimum.valueBlock.valueDec;\n\t\t\t}\n\n\t\t\tif (\"maximum\" in asn1.result) {\n\t\t\t\tif (asn1.result.maximum.valueBlock.isHexOnly) this.maximum = asn1.result.maximum;else this.maximum = asn1.result.maximum.valueBlock.valueDec;\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(this.base.toSchema());\n\n\t\t\tif (this.minimum !== 0) {\n\t\t\t\tvar valueMinimum = 0;\n\n\t\t\t\tif (this.minimum instanceof Integer) valueMinimum = this.minimum;else valueMinimum = new Integer({ value: this.minimum });\n\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [valueMinimum]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"maximum\" in this) {\n\t\t\t\tvar valueMaximum = 0;\n\n\t\t\t\tif (this.maximum instanceof Integer) valueMaximum = this.maximum;else valueMaximum = new Integer({ value: this.maximum });\n\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [valueMaximum]\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {\n\t\t\t\tbase: this.base.toJSON()\n\t\t\t};\n\n\t\t\tif (this.minimum !== 0) {\n\t\t\t\tif (typeof this.minimum === \"number\") object.minimum = this.minimum;else object.minimum = this.minimum.toJSON();\n\t\t\t}\n\n\t\t\tif (\"maximum\" in this) {\n\t\t\t\tif (typeof this.maximum === \"number\") object.maximum = this.maximum;else object.maximum = this.maximum.toJSON();\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass NameConstraints {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for NameConstraints class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"permittedSubtrees\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralSubtree>}\n     * @description permittedSubtrees\n     */\n\t\t\t\tthis.permittedSubtrees = getParametersValue(parameters, \"permittedSubtrees\", NameConstraints.defaultValues(\"permittedSubtrees\"));\n\n\t\t\tif (\"excludedSubtrees\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralSubtree>}\n     * @description excludedSubtrees\n     */\n\t\t\t\tthis.excludedSubtrees = getParametersValue(parameters, \"excludedSubtrees\", NameConstraints.defaultValues(\"excludedSubtrees\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"permittedSubtrees\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"excludedSubtrees\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for NameConstraints class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// NameConstraints OID ::= 2.5.29.30\n\t\t\t//\n\t\t\t//NameConstraints ::= SEQUENCE {\n\t\t\t//    permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n\t\t\t//    excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [permittedSubtrees]\n    * @property {string} [excludedSubtrees]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.permittedSubtrees || \"\",\n\t\t\t\t\t\tvalue: GeneralSubtree.schema()\n\t\t\t\t\t})]\n\t\t\t\t}), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.excludedSubtrees || \"\",\n\t\t\t\t\t\tvalue: GeneralSubtree.schema()\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"permittedSubtrees\", \"excludedSubtrees\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, NameConstraints.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tpermittedSubtrees: \"permittedSubtrees\",\n\t\t\t\t\texcludedSubtrees: \"excludedSubtrees\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for NameConstraints\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"permittedSubtrees\" in asn1.result) this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new GeneralSubtree({ schema: element }));\n\n\t\t\tif (\"excludedSubtrees\" in asn1.result) this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new GeneralSubtree({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"permittedSubtrees\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Sequence({\n\t\t\t\t\t\tvalue: Array.from(this.permittedSubtrees, element => element.toSchema())\n\t\t\t\t\t})]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"excludedSubtrees\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Sequence({\n\t\t\t\t\t\tvalue: Array.from(this.excludedSubtrees, element => element.toSchema())\n\t\t\t\t\t})]\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"permittedSubtrees\" in this) object.permittedSubtrees = Array.from(this.permittedSubtrees, element => element.toJSON());\n\n\t\t\tif (\"excludedSubtrees\" in this) object.excludedSubtrees = Array.from(this.excludedSubtrees, element => element.toJSON());\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass DistributionPoint {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for DistributionPoint class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   * @property {Object} [distributionPoint]\n   * @property {Object} [reasons]\n   * @property {Object} [cRLIssuer]\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"distributionPoint\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralName>}\n     * @description distributionPoint\n     */\n\t\t\t\tthis.distributionPoint = getParametersValue(parameters, \"distributionPoint\", DistributionPoint.defaultValues(\"distributionPoint\"));\n\n\t\t\tif (\"reasons\" in parameters)\n\t\t\t\t/**\n     * @type {BitString}\n     * @description values\n     */\n\t\t\t\tthis.reasons = getParametersValue(parameters, \"reasons\", DistributionPoint.defaultValues(\"reasons\"));\n\n\t\t\tif (\"cRLIssuer\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralName>}\n     * @description cRLIssuer\n     */\n\t\t\t\tthis.cRLIssuer = getParametersValue(parameters, \"cRLIssuer\", DistributionPoint.defaultValues(\"cRLIssuer\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"distributionPoint\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"reasons\":\n\t\t\t\t\treturn new BitString();\n\t\t\t\tcase \"cRLIssuer\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for DistributionPoint class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//DistributionPoint ::= SEQUENCE {\n\t\t\t//    distributionPoint       [0]     DistributionPointName OPTIONAL,\n\t\t\t//    reasons                 [1]     ReasonFlags OPTIONAL,\n\t\t\t//    cRLIssuer               [2]     GeneralNames OPTIONAL }\n\t\t\t//\n\t\t\t//DistributionPointName ::= CHOICE {\n\t\t\t//    fullName                [0]     GeneralNames,\n\t\t\t//    nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }\n\t\t\t//\n\t\t\t//ReasonFlags ::= BIT STRING {\n\t\t\t//    unused                  (0),\n\t\t\t//    keyCompromise           (1),\n\t\t\t//    cACompromise            (2),\n\t\t\t//    affiliationChanged      (3),\n\t\t\t//    superseded              (4),\n\t\t\t//    cessationOfOperation    (5),\n\t\t\t//    certificateHold         (6),\n\t\t\t//    privilegeWithdrawn      (7),\n\t\t\t//    aACompromise            (8) }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [distributionPoint]\n    * @property {string} [distributionPointNames]\n    * @property {string} [reasons]\n    * @property {string} [cRLIssuer]\n    * @property {string} [cRLIssuerNames]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Choice({\n\t\t\t\t\t\tvalue: [new Constructed({\n\t\t\t\t\t\t\tname: names.distributionPoint || \"\",\n\t\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\t\t\tname: names.distributionPointNames || \"\",\n\t\t\t\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t\t\t\t})]\n\t\t\t\t\t\t}), new Constructed({\n\t\t\t\t\t\t\tname: names.distributionPoint || \"\",\n\t\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: RelativeDistinguishedNames.schema().valueBlock.value\n\t\t\t\t\t\t})]\n\t\t\t\t\t})]\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.reasons || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT bitstring value\n\t\t\t\tnew Constructed({\n\t\t\t\t\tname: names.cRLIssuer || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.cRLIssuerNames || \"\",\n\t\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t\t})]\n\t\t\t\t}) // IMPLICIT bitstring value\n\t\t\t\t]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"distributionPoint\", \"distributionPointNames\", \"reasons\", \"cRLIssuer\", \"cRLIssuerNames\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, DistributionPoint.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tdistributionPoint: \"distributionPoint\",\n\t\t\t\t\tdistributionPointNames: \"distributionPointNames\",\n\t\t\t\t\treasons: \"reasons\",\n\t\t\t\t\tcRLIssuer: \"cRLIssuer\",\n\t\t\t\t\tcRLIssuerNames: \"cRLIssuerNames\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for DistributionPoint\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"distributionPoint\" in asn1.result) {\n\t\t\t\tif (asn1.result.distributionPoint.idBlock.tagNumber === 0) // GENERAL_NAMES variant\n\t\t\t\t\tthis.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));\n\n\t\t\t\tif (asn1.result.distributionPoint.idBlock.tagNumber === 1) // RDN variant\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.distributionPoint = new RelativeDistinguishedNames({\n\t\t\t\t\t\t\tschema: new Sequence({\n\t\t\t\t\t\t\t\tvalue: asn1.result.distributionPoint.valueBlock.value\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"reasons\" in asn1.result) this.reasons = new BitString({ valueHex: asn1.result.reasons.valueBlock.valueHex });\n\n\t\t\tif (\"cRLIssuer\" in asn1.result) this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new GeneralName({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"distributionPoint\" in this) {\n\t\t\t\tvar internalValue = void 0;\n\n\t\t\t\tif (this.distributionPoint instanceof Array) {\n\t\t\t\t\tinternalValue = new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: Array.from(this.distributionPoint, element => element.toSchema())\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tinternalValue = new Constructed({\n\t\t\t\t\t\tidBlock: {\n\t\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvalue: [this.distributionPoint.toSchema()]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [internalValue]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"reasons\" in this) {\n\t\t\t\toutputArray.push(new Primitive({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalueHex: this.reasons.valueBlock.valueHex\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"cRLIssuer\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: Array.from(this.cRLIssuer, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"distributionPoint\" in this) {\n\t\t\t\tif (this.distributionPoint instanceof Array) object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());else object.distributionPoint = this.distributionPoint.toJSON();\n\t\t\t}\n\n\t\t\tif (\"reasons\" in this) object.reasons = this.reasons.toJSON();\n\n\t\t\tif (\"cRLIssuer\" in this) object.cRLIssuer = Array.from(this.cRLIssuer, element => element.toJSON());\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass CRLDistributionPoints {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for CRLDistributionPoints class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<DistributionPoint>}\n    * @description distributionPoints\n    */\n\t\t\tthis.distributionPoints = getParametersValue(parameters, \"distributionPoints\", CRLDistributionPoints.defaultValues(\"distributionPoints\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"distributionPoints\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for CRLDistributionPoints class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// CRLDistributionPoints OID ::= 2.5.29.31\n\t\t\t//\n\t\t\t//CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [distributionPoints]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.distributionPoints || \"\",\n\t\t\t\t\tvalue: DistributionPoint.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"distributionPoints\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, CRLDistributionPoints.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tdistributionPoints: \"distributionPoints\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CRLDistributionPoints\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.distributionPoints = Array.from(asn1.result.distributionPoints, element => new DistributionPoint({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.distributionPoints, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tdistributionPoints: Array.from(this.distributionPoints, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PolicyQualifierInfo {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PolicyQualifierInfo class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description policyQualifierId\n    */\n\t\t\tthis.policyQualifierId = getParametersValue(parameters, \"policyQualifierId\", PolicyQualifierInfo.defaultValues(\"policyQualifierId\"));\n\t\t\t/**\n    * @type {Object}\n    * @description qualifier\n    */\n\t\t\tthis.qualifier = getParametersValue(parameters, \"qualifier\", PolicyQualifierInfo.defaultValues(\"qualifier\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"policyQualifierId\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"qualifier\":\n\t\t\t\t\treturn new Any();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PolicyQualifierInfo class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PolicyQualifierInfo ::= SEQUENCE {\n\t\t\t//    policyQualifierId  PolicyQualifierId,\n\t\t\t//    qualifier          ANY DEFINED BY policyQualifierId }\n\t\t\t//\n\t\t\t//id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }\n\t\t\t//id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }\n\t\t\t//id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }\n\t\t\t//\n\t\t\t//PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [policyQualifierId]\n    * @property {string} [qualifier]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.policyQualifierId || \"\" }), new Any({ name: names.qualifier || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"policyQualifierId\", \"qualifier\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PolicyQualifierInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tpolicyQualifierId: \"policyQualifierId\",\n\t\t\t\t\tqualifier: \"qualifier\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyQualifierInfo\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();\n\t\t\tthis.qualifier = asn1.result.qualifier;\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [new ObjectIdentifier({ value: this.policyQualifierId }), this.qualifier]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tpolicyQualifierId: this.policyQualifierId,\n\t\t\t\tqualifier: this.qualifier.toJSON()\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PolicyInformation {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PolicyInformation class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description policyIdentifier\n    */\n\t\t\tthis.policyIdentifier = getParametersValue(parameters, \"policyIdentifier\", PolicyInformation.defaultValues(\"policyIdentifier\"));\n\n\t\t\tif (\"policyQualifiers\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<PolicyQualifierInfo>}\n     * @description Value of the TIME class\n     */\n\t\t\t\tthis.policyQualifiers = getParametersValue(parameters, \"policyQualifiers\", PolicyInformation.defaultValues(\"policyQualifiers\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"policyIdentifier\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"policyQualifiers\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PolicyInformation class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PolicyInformation ::= SEQUENCE {\n\t\t\t//    policyIdentifier   CertPolicyId,\n\t\t\t//    policyQualifiers   SEQUENCE SIZE (1..MAX) OF\n\t\t\t//    PolicyQualifierInfo OPTIONAL }\n\t\t\t//\n\t\t\t//CertPolicyId ::= OBJECT IDENTIFIER\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [policyIdentifier]\n    * @property {string} [policyQualifiers]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.policyIdentifier || \"\" }), new Sequence({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.policyQualifiers || \"\",\n\t\t\t\t\t\tvalue: PolicyQualifierInfo.schema()\n\t\t\t\t\t})]\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"policyIdentifier\", \"policyQualifiers\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PolicyInformation.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tpolicyIdentifier: \"policyIdentifier\",\n\t\t\t\t\tpolicyQualifiers: \"policyQualifiers\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyInformation\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();\n\n\t\t\tif (\"policyQualifiers\" in asn1.result) this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new PolicyQualifierInfo({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(new ObjectIdentifier({ value: this.policyIdentifier }));\n\n\t\t\tif (\"policyQualifiers\" in this) {\n\t\t\t\toutputArray.push(new Sequence({\n\t\t\t\t\tvalue: Array.from(this.policyQualifiers, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {\n\t\t\t\tpolicyIdentifier: this.policyIdentifier\n\t\t\t};\n\n\t\t\tif (\"policyQualifiers\" in this) object.policyQualifiers = Array.from(this.policyQualifiers, element => element.toJSON());\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass CertificatePolicies {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for CertificatePolicies class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<PolicyInformation>}\n    * @description certificatePolicies\n    */\n\t\t\tthis.certificatePolicies = getParametersValue(parameters, \"certificatePolicies\", CertificatePolicies.defaultValues(\"certificatePolicies\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"certificatePolicies\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for CertificatePolicies class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// CertificatePolicies OID ::= 2.5.29.32\n\t\t\t//\n\t\t\t//certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [certificatePolicies]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.certificatePolicies || \"\",\n\t\t\t\t\tvalue: PolicyInformation.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"certificatePolicies\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, CertificatePolicies.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tcertificatePolicies: \"certificatePolicies\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for CertificatePolicies\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new PolicyInformation({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.certificatePolicies, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tcertificatePolicies: Array.from(this.certificatePolicies, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PolicyMapping {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PolicyMapping class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description issuerDomainPolicy\n    */\n\t\t\tthis.issuerDomainPolicy = getParametersValue(parameters, \"issuerDomainPolicy\", PolicyMapping.defaultValues(\"issuerDomainPolicy\"));\n\t\t\t/**\n    * @type {string}\n    * @description subjectDomainPolicy\n    */\n\t\t\tthis.subjectDomainPolicy = getParametersValue(parameters, \"subjectDomainPolicy\", PolicyMapping.defaultValues(\"subjectDomainPolicy\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"issuerDomainPolicy\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"subjectDomainPolicy\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PolicyMapping class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//PolicyMapping ::= SEQUENCE {\n\t\t\t//    issuerDomainPolicy      CertPolicyId,\n\t\t\t//    subjectDomainPolicy     CertPolicyId }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [issuerDomainPolicy]\n    * @property {string} [subjectDomainPolicy]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.issuerDomainPolicy || \"\" }), new ObjectIdentifier({ name: names.subjectDomainPolicy || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"issuerDomainPolicy\", \"subjectDomainPolicy\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PolicyMapping.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tissuerDomainPolicy: \"issuerDomainPolicy\",\n\t\t\t\t\tsubjectDomainPolicy: \"subjectDomainPolicy\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyMapping\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();\n\t\t\tthis.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [new ObjectIdentifier({ value: this.issuerDomainPolicy }), new ObjectIdentifier({ value: this.subjectDomainPolicy })]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tissuerDomainPolicy: this.issuerDomainPolicy,\n\t\t\t\tsubjectDomainPolicy: this.subjectDomainPolicy\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PolicyMappings {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PolicyMappings class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<PolicyMapping>}\n    * @description mappings\n    */\n\t\t\tthis.mappings = getParametersValue(parameters, \"mappings\", PolicyMappings.defaultValues(\"mappings\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"mappings\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PolicyMappings class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// PolicyMappings OID ::= 2.5.29.33\n\t\t\t//\n\t\t\t//PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF PolicyMapping\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [utcTimeName] Name for \"utcTimeName\" choice\n    * @property {string} [generalTimeName] Name for \"generalTimeName\" choice\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.mappings || \"\",\n\t\t\t\t\tvalue: PolicyMapping.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"mappings\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PolicyMappings.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tmappings: \"mappings\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyMappings\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.mappings = Array.from(asn1.result.mappings, element => new PolicyMapping({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.mappings, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tmappings: Array.from(this.mappings, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass AuthorityKeyIdentifier {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for AuthorityKeyIdentifier class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"keyIdentifier\" in parameters)\n\t\t\t\t/**\n     * @type {OctetString}\n     * @description keyIdentifier\n     */\n\t\t\t\tthis.keyIdentifier = getParametersValue(parameters, \"keyIdentifier\", AuthorityKeyIdentifier.defaultValues(\"keyIdentifier\"));\n\n\t\t\tif (\"authorityCertIssuer\" in parameters)\n\t\t\t\t/**\n     * @type {Array.<GeneralName>}\n     * @description authorityCertIssuer\n     */\n\t\t\t\tthis.authorityCertIssuer = getParametersValue(parameters, \"authorityCertIssuer\", AuthorityKeyIdentifier.defaultValues(\"authorityCertIssuer\"));\n\n\t\t\tif (\"authorityCertSerialNumber\" in parameters)\n\t\t\t\t/**\n     * @type {Integer}\n     * @description authorityCertIssuer\n     */\n\t\t\t\tthis.authorityCertSerialNumber = getParametersValue(parameters, \"authorityCertSerialNumber\", AuthorityKeyIdentifier.defaultValues(\"authorityCertSerialNumber\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"keyIdentifier\":\n\t\t\t\t\treturn new OctetString();\n\t\t\t\tcase \"authorityCertIssuer\":\n\t\t\t\t\treturn [];\n\t\t\t\tcase \"authorityCertSerialNumber\":\n\t\t\t\t\treturn new Integer();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AuthorityKeyIdentifier class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// AuthorityKeyIdentifier OID ::= 2.5.29.35\n\t\t\t//\n\t\t\t//AuthorityKeyIdentifier ::= SEQUENCE {\n\t\t\t//    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\n\t\t\t//    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\n\t\t\t//    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\n\t\t\t//\n\t\t\t//KeyIdentifier ::= OCTET STRING\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [keyIdentifier]\n    * @property {string} [authorityCertIssuer]\n    * @property {string} [authorityCertSerialNumber]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Primitive({\n\t\t\t\t\tname: names.keyIdentifier || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t}\n\t\t\t\t}), new Constructed({\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\t\tname: names.authorityCertIssuer || \"\",\n\t\t\t\t\t\tvalue: GeneralName.schema()\n\t\t\t\t\t})]\n\t\t\t\t}), new Primitive({\n\t\t\t\t\tname: names.authorityCertSerialNumber || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t}\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"keyIdentifier\", \"authorityCertIssuer\", \"authorityCertSerialNumber\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, AuthorityKeyIdentifier.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tkeyIdentifier: \"keyIdentifier\",\n\t\t\t\t\tauthorityCertIssuer: \"authorityCertIssuer\",\n\t\t\t\t\tauthorityCertSerialNumber: \"authorityCertSerialNumber\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AuthorityKeyIdentifier\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"keyIdentifier\" in asn1.result) this.keyIdentifier = new OctetString({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });\n\n\t\t\tif (\"authorityCertIssuer\" in asn1.result) this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, element => new GeneralName({ schema: element }));\n\n\t\t\tif (\"authorityCertSerialNumber\" in asn1.result) this.authorityCertSerialNumber = new Integer({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"keyIdentifier\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: this.keyIdentifier.valueBlock.value\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"authorityCertIssuer\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: Array.from(this.authorityCertIssuer, element => element.toSchema())\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tif (\"authorityCertSerialNumber\" in this) {\n\t\t\t\toutputArray.push(new Constructed({\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 2 // [2]\n\t\t\t\t\t},\n\t\t\t\t\tvalue: this.authorityCertSerialNumber.valueBlock.value\n\t\t\t\t}));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"keyIdentifier\" in this) object.keyIdentifier = this.keyIdentifier.toJSON();\n\n\t\t\tif (\"authorityCertIssuer\" in this) object.authorityCertIssuer = Array.from(this.authorityCertIssuer, element => element.toJSON());\n\n\t\t\tif (\"authorityCertSerialNumber\" in this) object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass PolicyConstraints {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for PolicyConstraints class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\tif (\"requireExplicitPolicy\" in parameters)\n\t\t\t\t/**\n     * @type {number}\n     * @description requireExplicitPolicy\n     */\n\t\t\t\tthis.requireExplicitPolicy = getParametersValue(parameters, \"requireExplicitPolicy\", PolicyConstraints.defaultValues(\"requireExplicitPolicy\"));\n\n\t\t\tif (\"inhibitPolicyMapping\" in parameters)\n\t\t\t\t/**\n     * @type {number}\n     * @description Value of the TIME class\n     */\n\t\t\t\tthis.inhibitPolicyMapping = getParametersValue(parameters, \"inhibitPolicyMapping\", PolicyConstraints.defaultValues(\"inhibitPolicyMapping\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"requireExplicitPolicy\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"inhibitPolicyMapping\":\n\t\t\t\t\treturn 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for PolicyConstraints class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// PolicyMappings OID ::= 2.5.29.36\n\t\t\t//\n\t\t\t//PolicyConstraints ::= SEQUENCE {\n\t\t\t//    requireExplicitPolicy           [0] SkipCerts OPTIONAL,\n\t\t\t//    inhibitPolicyMapping            [1] SkipCerts OPTIONAL }\n\t\t\t//\n\t\t\t//SkipCerts ::= INTEGER (0..MAX)\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [requireExplicitPolicy]\n    * @property {string} [inhibitPolicyMapping]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Primitive({\n\t\t\t\t\tname: names.requireExplicitPolicy || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 0 // [0]\n\t\t\t\t\t}\n\t\t\t\t}), // IMPLICIT integer value\n\t\t\t\tnew Primitive({\n\t\t\t\t\tname: names.inhibitPolicyMapping || \"\",\n\t\t\t\t\toptional: true,\n\t\t\t\t\tidBlock: {\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\n\t\t\t\t\t\ttagNumber: 1 // [1]\n\t\t\t\t\t}\n\t\t\t\t}) // IMPLICIT integer value\n\t\t\t\t]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"requireExplicitPolicy\", \"inhibitPolicyMapping\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, PolicyConstraints.schema({\n\t\t\t\tnames: {\n\t\t\t\t\trequireExplicitPolicy: \"requireExplicitPolicy\",\n\t\t\t\t\tinhibitPolicyMapping: \"inhibitPolicyMapping\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PolicyConstraints\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tif (\"requireExplicitPolicy\" in asn1.result) {\n\t\t\t\tvar field1 = asn1.result.requireExplicitPolicy;\n\n\t\t\t\tfield1.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\t\tfield1.idBlock.tagNumber = 2; // INTEGER\n\n\t\t\t\tvar ber1 = field1.toBER(false);\n\t\t\t\tvar int1 = fromBER(ber1);\n\n\t\t\t\tthis.requireExplicitPolicy = int1.result.valueBlock.valueDec;\n\t\t\t}\n\n\t\t\tif (\"inhibitPolicyMapping\" in asn1.result) {\n\t\t\t\tvar field2 = asn1.result.inhibitPolicyMapping;\n\n\t\t\t\tfield2.idBlock.tagClass = 1; // UNIVERSAL\n\t\t\t\tfield2.idBlock.tagNumber = 2; // INTEGER\n\n\t\t\t\tvar ber2 = field2.toBER(false);\n\t\t\t\tvar int2 = fromBER(ber2);\n\n\t\t\t\tthis.inhibitPolicyMapping = int2.result.valueBlock.valueDec;\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create correct values for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\tif (\"requireExplicitPolicy\" in this) {\n\t\t\t\tvar int1 = new Integer({ value: this.requireExplicitPolicy });\n\n\t\t\t\tint1.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\t\t\t\tint1.idBlock.tagNumber = 0; // [0]\n\n\t\t\t\toutputArray.push(int1);\n\t\t\t}\n\n\t\t\tif (\"inhibitPolicyMapping\" in this) {\n\t\t\t\tvar int2 = new Integer({ value: this.inhibitPolicyMapping });\n\n\t\t\t\tint2.idBlock.tagClass = 3; // CONTEXT-SPECIFIC\n\t\t\t\tint2.idBlock.tagNumber = 1; // [1]\n\n\t\t\t\toutputArray.push(int2);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {};\n\n\t\t\tif (\"requireExplicitPolicy\" in this) object.requireExplicitPolicy = this.requireExplicitPolicy;\n\n\t\t\tif (\"inhibitPolicyMapping\" in this) object.inhibitPolicyMapping = this.inhibitPolicyMapping;\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass ExtKeyUsage {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for ExtKeyUsage class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<string>}\n    * @description keyPurposes\n    */\n\t\t\tthis.keyPurposes = getParametersValue(parameters, \"keyPurposes\", ExtKeyUsage.defaultValues(\"keyPurposes\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"keyPurposes\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for ExtKeyUsage class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// ExtKeyUsage OID ::= 2.5.29.37\n\t\t\t//\n\t\t\t// ExtKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n\n\t\t\t// KeyPurposeId ::= OBJECT IDENTIFIER\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [keyPurposes]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.keyPurposes || \"\",\n\t\t\t\t\tvalue: new ObjectIdentifier()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"keyPurposes\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, ExtKeyUsage.schema({\n\t\t\t\tnames: {\n\t\t\t\t\tkeyPurposes: \"keyPurposes\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for ExtKeyUsage\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.keyPurposes = Array.from(asn1.result.keyPurposes, element => element.valueBlock.toString());\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.keyPurposes, element => new ObjectIdentifier({ value: element }))\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tkeyPurposes: Array.from(this.keyPurposes)\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass AccessDescription {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for AccessDescription class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description accessMethod\n    */\n\t\t\tthis.accessMethod = getParametersValue(parameters, \"accessMethod\", AccessDescription.defaultValues(\"accessMethod\"));\n\t\t\t/**\n    * @type {GeneralName}\n    * @description accessLocation\n    */\n\t\t\tthis.accessLocation = getParametersValue(parameters, \"accessLocation\", AccessDescription.defaultValues(\"accessLocation\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"accessMethod\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"accessLocation\":\n\t\t\t\t\treturn new GeneralName();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for AccessDescription class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//AccessDescription  ::=  SEQUENCE {\n\t\t\t//    accessMethod          OBJECT IDENTIFIER,\n\t\t\t//    accessLocation        GeneralName  }\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [accessMethod]\n    * @property {string} [accessLocation]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.accessMethod || \"\" }), GeneralName.schema(names.accessLocation || {})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"accessMethod\", \"accessLocation\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, AccessDescription.schema({\n\t\t\t\tnames: {\n\t\t\t\t\taccessMethod: \"accessMethod\",\n\t\t\t\t\taccessLocation: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"accessLocation\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for AccessDescription\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.accessMethod = asn1.result.accessMethod.valueBlock.toString();\n\t\t\tthis.accessLocation = new GeneralName({ schema: asn1.result.accessLocation });\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: [new ObjectIdentifier({ value: this.accessMethod }), this.accessLocation.toSchema()]\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\taccessMethod: this.accessMethod,\n\t\t\t\taccessLocation: this.accessLocation.toJSON()\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass InfoAccess {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for InfoAccess class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<AccessDescription>}\n    * @description accessDescriptions\n    */\n\t\t\tthis.accessDescriptions = getParametersValue(parameters, \"accessDescriptions\", InfoAccess.defaultValues(\"accessDescriptions\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"accessDescriptions\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for InfoAccess class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t// AuthorityInfoAccess OID ::= 1.3.6.1.5.5.7.1.1\n\t\t\t// SubjectInfoAccess OID ::= 1.3.6.1.5.5.7.1.11\n\t\t\t//\n\t\t\t//AuthorityInfoAccessSyntax  ::=\n\t\t\t//SEQUENCE SIZE (1..MAX) OF AccessDescription\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [accessDescriptions]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.accessDescriptions || \"\",\n\t\t\t\t\tvalue: AccessDescription.schema()\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"accessDescriptions\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, InfoAccess.schema({\n\t\t\t\tnames: {\n\t\t\t\t\taccessDescriptions: \"accessDescriptions\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for InfoAccess\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new AccessDescription({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.accessDescriptions, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\taccessDescriptions: Array.from(this.accessDescriptions, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t/*\n  * Copyright (c) 2016-2018, Peculiar Ventures\n  * All rights reserved.\n  *\n  * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\n  *\n  * THIS IS A PRIVATE SOURCE CODE AND ANY DISTRIBUTION OR COPYING IS PROHIBITED.\n  *\n  */\n\t//**************************************************************************************\n\tclass ByteStream {\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS\n\t\t/**\n   * Constructor for ByteStream class\n   * @param {{[length]: number, [stub]: number, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [hexstring]: string}} parameters\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\tthis.clear();\n\n\t\t\tvar _iteratorNormalCompletion18 = true;\n\t\t\tvar _didIteratorError18 = false;\n\t\t\tvar _iteratorError18 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator18 = Object.keys(parameters)[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n\t\t\t\t\tvar key = _step18.value;\n\n\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\tcase \"length\":\n\t\t\t\t\t\t\tthis.length = parameters.length;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"stub\":\n\t\t\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\t\t\tfor (var i = 0; i < this._view.length; i++) {\n\t\t\t\t\t\t\t\tthis._view[i] = parameters.stub;\n\t\t\t\t\t\t\t}break;\n\t\t\t\t\t\tcase \"view\":\n\t\t\t\t\t\t\tthis.fromUint8Array(parameters.view);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"buffer\":\n\t\t\t\t\t\t\tthis.fromArrayBuffer(parameters.buffer);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\t\tthis.fromString(parameters.string);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"hexstring\":\n\t\t\t\t\t\t\tthis.fromHexString(parameters.hexstring);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError18 = true;\n\t\t\t\t_iteratorError18 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion18 && _iterator18.return) {\n\t\t\t\t\t\t_iterator18.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError18) {\n\t\t\t\t\t\tthrow _iteratorError18;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"buffer\"\n   * @param {ArrayBuffer} value\n   */\n\t\tset buffer(value) {\n\t\t\tthis._buffer = value.slice(0);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"buffer\"\n   * @returns {ArrayBuffer}\n   */\n\t\tget buffer() {\n\t\t\treturn this._buffer;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"view\"\n   * @param {Uint8Array} value\n   */\n\t\tset view(value) {\n\t\t\tthis._buffer = new ArrayBuffer(value.length);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\n\t\t\tthis._view.set(value);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"view\"\n   * @returns {Uint8Array}\n   */\n\t\tget view() {\n\t\t\treturn this._view;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"length\"\n   * @returns {number}\n   */\n\t\tget length() {\n\t\t\treturn this._buffer.byteLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"length\"\n   * @param {number} value\n   */\n\t\tset length(value) {\n\t\t\tthis._buffer = new ArrayBuffer(value);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Clear existing stream\n   */\n\t\tclear() {\n\t\t\tthis._buffer = new ArrayBuffer(0);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Initialize \"Stream\" object from existing \"ArrayBuffer\"\n   * @param {!ArrayBuffer} array The ArrayBuffer to copy from\n   */\n\t\tfromArrayBuffer(array) {\n\t\t\tthis.buffer = array;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionNamingConventionJS\n\t\t/**\n   * Initialize \"Stream\" object from existing \"Uint8Array\"\n   * @param {!Uint8Array} array The Uint8Array to copy from\n   */\n\t\tfromUint8Array(array) {\n\t\t\tthis._buffer = new ArrayBuffer(array.length);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\n\t\t\tthis._view.set(array);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Initialize \"Stream\" object from existing string\n   * @param {string} string The string to initialize from\n   */\n\t\tfromString(string) {\n\t\t\tvar stringLength = string.length;\n\n\t\t\tthis.length = stringLength;\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tfor (var i = 0; i < stringLength; i++) {\n\t\t\t\tthis.view[i] = string.charCodeAt(i);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Represent \"Stream\" object content as a string\n   * @param {number} [start] Start position to convert to string\n   * @param {number} [length] Length of array to convert to string\n   * @returns {string}\n   */\n\t\ttoString() {\n\t\t\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = \"\";\n\t\t\t//endregion\n\n\t\t\t//region Check input parameters\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start >= this.view.length || start < 0) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length >= this.view.length || length < 0) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.view.length - start;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Convert array of bytes to string\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tfor (var i = start; i < start + length; i++) {\n\t\t\t\tresult += String.fromCharCode(this.view[i]);\n\t\t\t} //endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionTooLongJS\n\t\t/**\n   * Initialize \"Stream\" object from existing hexdecimal string\n   * @param {string} hexString String to initialize from\n   */\n\t\tfromHexString(hexString) {\n\t\t\t//region Initial variables\n\t\t\tvar stringLength = hexString.length;\n\n\t\t\tthis.buffer = new ArrayBuffer(stringLength >> 1);\n\t\t\tthis.view = new Uint8Array(this.buffer);\n\n\t\t\tvar hexMap = new Map();\n\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"0\", 0x00);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"1\", 0x01);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"2\", 0x02);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"3\", 0x03);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"4\", 0x04);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"5\", 0x05);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"6\", 0x06);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"7\", 0x07);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"8\", 0x08);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"9\", 0x09);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"A\", 0x0A);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"a\", 0x0A);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"B\", 0x0B);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"b\", 0x0B);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"C\", 0x0C);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"c\", 0x0C);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"D\", 0x0D);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"d\", 0x0D);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"E\", 0x0E);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"e\", 0x0E);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"F\", 0x0F);\n\t\t\t// noinspection MagicNumberJS\n\t\t\thexMap.set(\"f\", 0x0F);\n\n\t\t\tvar j = 0;\n\t\t\t// noinspection MagicNumberJS\n\t\t\tvar temp = 0x00;\n\t\t\t//endregion\n\n\t\t\t//region Convert char-by-char\n\t\t\tfor (var i = 0; i < stringLength; i++) {\n\t\t\t\t// noinspection NegatedIfStatementJS\n\t\t\t\tif (!(i % 2)) {\n\t\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\t\ttemp = hexMap.get(hexString.charAt(i)) << 4;\n\t\t\t\t} else {\n\t\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\t\ttemp |= hexMap.get(hexString.charAt(i));\n\n\t\t\t\t\tthis.view[j] = temp;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Represent \"Stream\" object content as a hexdecimal string\n   * @param {number} [start=0] Start position to convert to string\n   * @param {number} [length=(this.view.length - start)] Length of array to convert to string\n   * @returns {string}\n   */\n\t\ttoHexString() {\n\t\t\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.view.length - start;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = \"\";\n\t\t\t//endregion\n\n\t\t\t//region Check input parameters\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start >= this.view.length || start < 0) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length >= this.view.length || length < 0) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.view.length - start;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tfor (var i = start; i < start + length; i++) {\n\t\t\t\t// noinspection ChainedFunctionCallJS\n\t\t\t\tvar str = this.view[i].toString(16).toUpperCase();\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\n\t\t\t\tresult = result + (str.length == 1 ? \"0\" : \"\") + str;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Return copy of existing \"Stream\"\n   * @param {number} [start=0] Start position of the copy\n   * @param {number} [length=this.view.length] Length of the copy\n   * @returns {ByteStream}\n   */\n\t\tcopy() {\n\t\t\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._buffer.byteLength - start;\n\n\t\t\t//region Check input parameters\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (start === 0 && this._buffer.byteLength === 0) return new ByteStream();\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (start < 0 || start > this._buffer.byteLength - 1) throw new Error(`Wrong start position: ${start}`);\n\t\t\t//endregion\n\n\t\t\tvar stream = new ByteStream();\n\n\t\t\tstream._buffer = this._buffer.slice(start, start + length);\n\t\t\tstream._view = new Uint8Array(stream._buffer);\n\n\t\t\treturn stream;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Return slice of existing \"Stream\"\n   * @param {number} [start=0] Start position of the slice\n   * @param {number} [end=this._buffer.byteLength] End position of the slice\n   * @returns {ByteStream}\n   */\n\t\tslice() {\n\t\t\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._buffer.byteLength;\n\n\t\t\t//region Check input parameters\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (start === 0 && this._buffer.byteLength === 0) return new ByteStream();\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (start < 0 || start > this._buffer.byteLength - 1) throw new Error(`Wrong start position: ${start}`);\n\t\t\t//endregion\n\n\t\t\tvar stream = new ByteStream();\n\n\t\t\tstream._buffer = this._buffer.slice(start, end);\n\t\t\tstream._view = new Uint8Array(stream._buffer);\n\n\t\t\treturn stream;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Change size of existing \"Stream\"\n   * @param {!number} size Size for new \"Stream\"\n   */\n\t\trealloc(size) {\n\t\t\t//region Initial variables\n\t\t\tvar buffer = new ArrayBuffer(size);\n\t\t\tvar view = new Uint8Array(buffer);\n\t\t\t//endregion\n\n\t\t\t//region Create a new ArrayBuffer content\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (size > this._view.length) view.set(this._view);else {\n\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\tview.set(new Uint8Array(this._buffer, 0, size));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initialize \"Stream\" with new \"ArrayBuffer\"\n\t\t\tthis._buffer = buffer.slice(0);\n\t\t\tthis._view = new Uint8Array(this._buffer);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Append a new \"Stream\" content to the current \"Stream\"\n   * @param {ByteStream} stream A new \"stream\" to append to current \"stream\"\n   */\n\t\tappend(stream) {\n\t\t\t//region Initial variables\n\t\t\tvar initialSize = this._buffer.byteLength;\n\t\t\tvar streamViewLength = stream._buffer.byteLength;\n\n\t\t\tvar copyView = stream._view.slice();\n\t\t\t//endregion\n\n\t\t\t//region Re-allocate current internal buffer\n\t\t\tthis.realloc(initialSize + streamViewLength);\n\t\t\t//endregion\n\n\t\t\t//region Copy input stream content to a new place\n\t\t\tthis._view.set(copyView, initialSize);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Insert \"Stream\" content to the current \"Stream\" at specific position\n   * @param {ByteStream} stream A new \"stream\" to insert to current \"stream\"\n   * @param {number} [start=0] Start position to insert to\n   * @param {number} [length]\n   * @returns {boolean}\n   */\n\t\tinsert(stream) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._buffer.byteLength - start;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this._buffer.byteLength - 1) return false;\n\n\t\t\tif (length > this._buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this._buffer.byteLength - start;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Check input variables\n\t\t\tif (length > stream._buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = stream._buffer.byteLength;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Update content of the current stream\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (length == stream._buffer.byteLength) this._view.set(stream._view, start);else {\n\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\tthis._view.set(stream._view.slice(0, length), start);\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Check that two \"Stream\" objects has equal content\n   * @param {ByteStream} stream Stream to compare with\n   * @returns {boolean}\n   */\n\t\tisEqual(stream) {\n\t\t\t//region Check length of both buffers\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (this._buffer.byteLength != stream._buffer.byteLength) return false;\n\t\t\t//endregion\n\n\t\t\t//region Compare each byte of both buffers\n\t\t\tfor (var i = 0; i < stream._buffer.byteLength; i++) {\n\t\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (this.view[i] != stream.view[i]) return false;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Check that current \"Stream\" objects has equal content with input \"Uint8Array\"\n   * @param {Uint8Array} view View to compare with\n   * @returns {boolean}\n   */\n\t\tisEqualView(view) {\n\t\t\t//region Check length of both buffers\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (view.length != this.view.length) return false;\n\t\t\t//endregion\n\n\t\t\t//region Compare each byte of both buffers\n\t\t\tfor (var i = 0; i < view.length; i++) {\n\t\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (this.view[i] != view[i]) return false;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn true;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Find any byte pattern in \"Stream\"\n   * @param {ByteStream} pattern Stream having pattern value\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @param {boolean} [backward] Flag to search in backward order\n   * @returns {number}\n   */\n\t\tfindPattern(pattern) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Check input variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar patternLength = pattern.buffer.byteLength;\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (patternLength > length) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Make a \"pre-read\" array for pattern\n\t\t\tvar patternArray = [];\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tfor (var i = 0; i < patternLength; i++) {\n\t\t\t\tpatternArray.push(pattern.view[i]);\n\t\t\t} //endregion\n\n\t\t\t//region Search for pattern\n\t\t\tfor (var _i17 = 0; _i17 <= length - patternLength; _i17++) {\n\t\t\t\tvar equal = true;\n\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\tvar equalStart = backward ? start - patternLength - _i17 : start + _i17;\n\n\t\t\t\tfor (var j = 0; j < patternLength; j++) {\n\t\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\t\tif (this.view[j + equalStart] != patternArray[j]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (equal) {\n\t\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\t\treturn backward ? start - patternLength - _i17 : start + patternLength + _i17; // Position after the pattern found\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn -1;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection OverlyComplexFunctionJS\n\t\t/**\n   * Find first position of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be found\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @param {boolean} [backward=false] Flag to search in backward order\n   * @returns {{id: number, position: number}}\n   */\n\t\tfindFirstIn(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar result = {\n\t\t\t\tid: -1,\n\t\t\t\tposition: backward ? 0 : start + length\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\tfor (var i = 0; i < patterns.length; i++) {\n\t\t\t\tvar position = this.findPattern(patterns[i], start, length, backward);\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (position != -1) {\n\t\t\t\t\tvar valid = false;\n\n\t\t\t\t\tif (backward) {\n\t\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\t\tif (position >= result.position) valid = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\t\tif (position <= result.position) valid = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tresult.position = position;\n\t\t\t\t\t\tresult.id = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all positions of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be found\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @returns {Array}\n   */\n\t\tfindAllIn(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.buffer.byteLength - start;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tvar patternFound = {\n\t\t\t\tid: -1,\n\t\t\t\tposition: start\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\t//region Find all accurences of patterns\n\t\t\tdo {\n\t\t\t\tvar position = patternFound.position;\n\n\t\t\t\tpatternFound = this.findFirstIn(patterns, patternFound.position, length);\n\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (patternFound.id == -1) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength -= patternFound.position - position;\n\n\t\t\t\tresult.push({\n\t\t\t\t\tid: patternFound.id,\n\t\t\t\t\tposition: patternFound.position\n\t\t\t\t});\n\t\t\t} while (true); // eslint-disable-line\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all positions of a pattern\n   * @param {ByteStream} pattern Stream having pattern value\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @returns {Array|number} Array with all pattern positions or (-1) if failed\n   */\n\t\tfindAllPatternIn(pattern) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.buffer.byteLength - start;\n\n\t\t\t//region Check input variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\tvar patternLength = pattern.buffer.byteLength;\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (patternLength > length) return -1;\n\t\t\t//endregion\n\n\t\t\t//region Make a \"pre-read\" array for pattern\n\t\t\tvar patternArray = Array.from(pattern.view);\n\t\t\t//endregion\n\n\t\t\t//region Search for pattern\n\t\t\tfor (var i = 0; i <= length - patternLength; i++) {\n\t\t\t\tvar equal = true;\n\t\t\t\tvar equalStart = start + i;\n\n\t\t\t\tfor (var j = 0; j < patternLength; j++) {\n\t\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\t\tif (this.view[j + equalStart] != patternArray[j]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (equal) {\n\t\t\t\t\tresult.push(start + patternLength + i); // Position after the pattern found\n\t\t\t\t\ti += patternLength - 1; // On next step of \"for\" we will have \"i++\"\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Find first position of data, not included in patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @param {boolean} [backward=false] Flag to search in backward order\n   * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}\n   */\n\t\tfindFirstNotIn(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar result = {\n\t\t\t\tleft: {\n\t\t\t\t\tid: -1,\n\t\t\t\t\tposition: start\n\t\t\t\t},\n\t\t\t\tright: {\n\t\t\t\t\tid: -1,\n\t\t\t\t\tposition: 0\n\t\t\t\t},\n\t\t\t\tvalue: new ByteStream()\n\t\t\t};\n\n\t\t\tvar currentLength = length;\n\t\t\t//endregion\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\twhile (currentLength > 0) {\n\t\t\t\t//region Search for nearest \"pattern\"\n\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\tresult.right = this.findFirstIn(patterns, backward ? start - length + currentLength : start + length - currentLength, currentLength, backward);\n\t\t\t\t//endregion\n\n\t\t\t\t//region No pattern at all\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.right.id == -1) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = currentLength;\n\n\t\t\t\t\tif (backward) {\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tstart -= length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tstart = result.left.position;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.value = new ByteStream();\n\n\t\t\t\t\tresult.value._buffer = this._buffer.slice(start, start + length);\n\t\t\t\t\tresult.value._view = new Uint8Array(result.value._buffer);\n\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\t//region Check distance between two patterns\n\t\t\t\t// noinspection ConditionalExpressionJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.right.position != (backward ? result.left.position - patterns[result.right.id].buffer.byteLength : result.left.position + patterns[result.right.id].buffer.byteLength)) {\n\t\t\t\t\tif (backward) {\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tstart = result.right.position + patterns[result.right.id].buffer.byteLength;\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tlength = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tstart = result.left.position;\n\t\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\t\tlength = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.value = new ByteStream();\n\n\t\t\t\t\tresult.value._buffer = this._buffer.slice(start, start + length);\n\t\t\t\t\tresult.value._view = new Uint8Array(result.value._buffer);\n\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\t//region Store information about previous pattern\n\t\t\t\tresult.left = result.right;\n\t\t\t\t//endregion\n\n\t\t\t\t//region Change current length\n\t\t\t\tcurrentLength -= patterns[result.right.id]._buffer.byteLength;\n\t\t\t\t//endregion\n\t\t\t}\n\n\t\t\t//region Swap \"patterns\" in case of backward order\n\t\t\tif (backward) {\n\t\t\t\tvar temp = result.right;\n\t\t\t\tresult.right = result.left;\n\t\t\t\tresult.left = temp;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all positions of data, not included in patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @returns {Array}\n   */\n\t\tfindAllNotIn(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tvar patternFound = {\n\t\t\t\tleft: {\n\t\t\t\t\tid: -1,\n\t\t\t\t\tposition: start\n\t\t\t\t},\n\t\t\t\tright: {\n\t\t\t\t\tid: -1,\n\t\t\t\t\tposition: start\n\t\t\t\t},\n\t\t\t\tvalue: new ByteStream()\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\t//region Find all accurences of patterns\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\tdo {\n\t\t\t\tvar position = patternFound.right.position;\n\n\t\t\t\tpatternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);\n\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength -= patternFound.right.position - position;\n\n\t\t\t\tresult.push({\n\t\t\t\t\tleft: {\n\t\t\t\t\t\tid: patternFound.left.id,\n\t\t\t\t\t\tposition: patternFound.left.position\n\t\t\t\t\t},\n\t\t\t\t\tright: {\n\t\t\t\t\t\tid: patternFound.right.id,\n\t\t\t\t\t\tposition: patternFound.right.position\n\t\t\t\t\t},\n\t\t\t\t\tvalue: patternFound.value\n\t\t\t\t});\n\t\t\t} while (patternFound.right.id != -1);\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS\n\t\t/**\n   * Find position of a sequence of any patterns from input array\n   * @param {Array.<ByteStream>} patterns Array of pattern to look for\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @param {boolean} [backward=false] Flag to search in backward order\n   * @returns {*}\n   */\n\t\tfindFirstSequence(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find first byte from sequence\n\t\t\tvar firstIn = this.skipNotPatterns(patterns, start, length, backward);\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\tif (firstIn == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tposition: -1,\n\t\t\t\t\tvalue: new ByteStream()\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find first byte not in sequence\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar firstNotIn = this.skipPatterns(patterns, firstIn, length - (backward ? start - firstIn : firstIn - start), backward);\n\t\t\t//endregion\n\n\t\t\t//region Make output value\n\t\t\tif (backward) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = firstNotIn;\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = firstIn - firstNotIn;\n\t\t\t} else {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = firstIn;\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = firstNotIn - firstIn;\n\t\t\t}\n\n\t\t\tvar value = new ByteStream();\n\n\t\t\tvalue._buffer = this._buffer.slice(start, start + length);\n\t\t\tvalue._view = new Uint8Array(value._buffer);\n\t\t\t//endregion\n\n\t\t\treturn {\n\t\t\t\tposition: firstNotIn,\n\t\t\t\tvalue\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all positions of a sequence of any patterns from input array\n   * @param {Array.<ByteStream>} patterns Array of patterns to search for\n   * @param {?number} [start] Start position to search from\n   * @param {?number} [length] Length of byte block to search at\n   * @returns {Array}\n   */\n\t\tfindAllSequences(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tvar patternFound = {\n\t\t\t\tposition: start,\n\t\t\t\tvalue: new ByteStream()\n\t\t\t};\n\t\t\t//endregion\n\n\t\t\t//region Find all accurences of patterns\n\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\tdo {\n\t\t\t\tvar position = patternFound.position;\n\n\t\t\t\tpatternFound = this.findFirstSequence(patterns, patternFound.position, length);\n\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (patternFound.position != -1) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength -= patternFound.position - position;\n\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tposition: patternFound.position,\n\t\t\t\t\t\tvalue: patternFound.value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} while (patternFound.position != -1);\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Find all paired patterns in the stream\n   * @param {ByteStream} leftPattern Left pattern to search for\n   * @param {ByteStream} rightPattern Right pattern to search for\n   * @param {?number} [start=null] Start position to search from\n   * @param {?number} [length=null] Length of byte block to search at\n   * @returns {Array}\n   */\n\t\tfindPairedPatterns(leftPattern, rightPattern) {\n\t\t\tvar start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (leftPattern.isEqual(rightPattern)) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tvar currentPositionLeft = 0;\n\t\t\t//endregion\n\n\t\t\t//region Find all \"left patterns\" as sorted array\n\t\t\tvar leftPatterns = this.findAllPatternIn(leftPattern, start, length);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (leftPatterns.length == 0) return result;\n\t\t\t//endregion\n\n\t\t\t//region Find all \"right patterns\" as sorted array\n\t\t\tvar rightPatterns = this.findAllPatternIn(rightPattern, start, length);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (rightPatterns.length == 0) return result;\n\t\t\t//endregion\n\n\t\t\t//region Combine patterns\n\t\t\twhile (currentPositionLeft < leftPatterns.length) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (rightPatterns.length == 0) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (leftPatterns[0] == rightPatterns[0]) {\n\t\t\t\t\t// Possible situation when one pattern is a part of another\n\t\t\t\t\t// For example \"stream\" and \"endstream\"\n\t\t\t\t\t// In case when we have only \"endstream\" in fact \"stream\" will be also found at the same position\n\t\t\t\t\t// (position of the pattern is an index AFTER the pattern)\n\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tleft: leftPatterns[0],\n\t\t\t\t\t\tright: rightPatterns[0]\n\t\t\t\t\t});\n\n\t\t\t\t\tleftPatterns.splice(0, 1);\n\t\t\t\t\trightPatterns.splice(0, 1);\n\n\t\t\t\t\t// noinspection ContinueStatementJS\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (leftPatterns[currentPositionLeft] > rightPatterns[0]) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\twhile (leftPatterns[currentPositionLeft] < rightPatterns[0]) {\n\t\t\t\t\tcurrentPositionLeft++;\n\n\t\t\t\t\tif (currentPositionLeft >= leftPatterns.length) {\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push({\n\t\t\t\t\tleft: leftPatterns[currentPositionLeft - 1],\n\t\t\t\t\tright: rightPatterns[0]\n\t\t\t\t});\n\n\t\t\t\tleftPatterns.splice(currentPositionLeft - 1, 1);\n\t\t\t\trightPatterns.splice(0, 1);\n\n\t\t\t\tcurrentPositionLeft = 0;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Sort result\n\t\t\tresult.sort((a, b) => a.left - b.left);\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Find all paired patterns in the stream\n   * @param {Array.<ByteStream>} inputLeftPatterns Array of left patterns to search for\n   * @param {Array.<ByteStream>} inputRightPatterns Array of right patterns to search for\n   * @param {?number} [start=null] Start position to search from\n   * @param {?number} [length=null] Length of byte block to search at\n   * @returns {Array}\n   */\n\t\tfindPairedArrays(inputLeftPatterns, inputRightPatterns) {\n\t\t\tvar start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = [];\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return result;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tvar currentPositionLeft = 0;\n\t\t\t//endregion\n\n\t\t\t//region Find all \"left patterns\" as sorted array\n\t\t\tvar leftPatterns = this.findAllIn(inputLeftPatterns, start, length);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (leftPatterns.length == 0) return result;\n\t\t\t//endregion\n\n\t\t\t//region Find all \"right patterns\" as sorted array\n\t\t\tvar rightPatterns = this.findAllIn(inputRightPatterns, start, length);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (rightPatterns.length == 0) return result;\n\t\t\t//endregion\n\n\t\t\t//region Combine patterns\n\t\t\twhile (currentPositionLeft < leftPatterns.length) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (rightPatterns.length == 0) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (leftPatterns[0].position == rightPatterns[0].position) {\n\t\t\t\t\t// Possible situation when one pattern is a part of another\n\t\t\t\t\t// For example \"stream\" and \"endstream\"\n\t\t\t\t\t// In case when we have only \"endstream\" in fact \"stream\" will be also found at the same position\n\t\t\t\t\t// (position of the pattern is an index AFTER the pattern)\n\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tleft: leftPatterns[0],\n\t\t\t\t\t\tright: rightPatterns[0]\n\t\t\t\t\t});\n\n\t\t\t\t\tleftPatterns.splice(0, 1);\n\t\t\t\t\trightPatterns.splice(0, 1);\n\n\t\t\t\t\t// noinspection ContinueStatementJS\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\twhile (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {\n\t\t\t\t\tcurrentPositionLeft++;\n\n\t\t\t\t\tif (currentPositionLeft >= leftPatterns.length) {\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push({\n\t\t\t\t\tleft: leftPatterns[currentPositionLeft - 1],\n\t\t\t\t\tright: rightPatterns[0]\n\t\t\t\t});\n\n\t\t\t\tleftPatterns.splice(currentPositionLeft - 1, 1);\n\t\t\t\trightPatterns.splice(0, 1);\n\n\t\t\t\tcurrentPositionLeft = 0;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Sort result\n\t\t\tresult.sort((a, b) => a.left.position - b.left.position);\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS\n\t\t/**\n   * Replace one patter with other\n   * @param {ByteStream} searchPattern The pattern to search for\n   * @param {ByteStream} replacePattern The pattern to replace initial pattern\n   * @param {?number} [start=null] Start position to search from\n   * @param {?number} [length=null] Length of byte block to search at\n   * @param {Array|null} [findAllResult=null] Pre-calculated results of \"findAllIn\"\n   * @returns {*}\n   */\n\t\treplacePattern(searchPattern, replacePattern) {\n\t\t\tvar start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t\t\tvar findAllResult = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n\t\t\t//region Initial variables\n\t\t\tvar result = void 0;\n\n\t\t\tvar i = void 0;\n\t\t\tvar output = {\n\t\t\t\tstatus: -1,\n\t\t\t\tsearchPatternPositions: [],\n\t\t\t\treplacePatternPositions: []\n\t\t\t};\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = 0;\n\t\t\t}\n\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (start > this.buffer.byteLength - 1) return false;\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\n\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find a pattern to search for\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (findAllResult == null) {\n\t\t\t\tresult = this.findAllIn([searchPattern], start, length);\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.length == 0) return output;\n\t\t\t} else result = findAllResult;\n\n\t\t\t// noinspection NestedFunctionCallJS\n\t\t\toutput.searchPatternPositions.push(...Array.from(result, element => element.position));\n\t\t\t//endregion\n\n\t\t\t//region Variables for new buffer initialization\n\t\t\tvar patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;\n\n\t\t\tvar changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);\n\t\t\tvar changedView = new Uint8Array(changedBuffer);\n\t\t\t//endregion\n\n\t\t\t//region Copy data from 0 to start\n\t\t\t// noinspection NestedFunctionCallJS\n\t\t\tchangedView.set(new Uint8Array(this.buffer, 0, start));\n\t\t\t//endregion\n\n\t\t\t//region Replace pattern\n\t\t\tfor (i = 0; i < result.length; i++) {\n\t\t\t\t//region Initial variables\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS\n\t\t\t\tvar currentPosition = i == 0 ? start : result[i - 1].position;\n\t\t\t\t//endregion\n\n\t\t\t\t//region Copy bytes other then search pattern\n\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\tchangedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i * patternDifference);\n\t\t\t\t//endregion\n\n\t\t\t\t//region Put replace pattern in a new buffer\n\t\t\t\tchangedView.set(replacePattern.view, result[i].position - searchPattern.buffer.byteLength - i * patternDifference);\n\n\t\t\t\toutput.replacePatternPositions.push(result[i].position - searchPattern.buffer.byteLength - i * patternDifference);\n\t\t\t\t//endregion\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Copy data from the end of old buffer\n\t\t\ti--;\n\t\t\t// noinspection NestedFunctionCallJS\n\t\t\tchangedView.set(new Uint8Array(this.buffer, result[i].position, this.buffer.byteLength - result[i].position), result[i].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i * patternDifference);\n\t\t\t//endregion\n\n\t\t\t//region Re-initialize existing buffer\n\t\t\tthis.buffer = changedBuffer;\n\t\t\tthis.view = new Uint8Array(this.buffer);\n\t\t\t//endregion\n\n\t\t\toutput.status = 1;\n\n\t\t\treturn output;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Skip any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @param {?number} [start=null] Start position to search from\n   * @param {?number} [length=null] Length of byte block to search at\n   * @param {boolean} [backward=false] Flag to search in backward order\n   * @returns {*}\n   */\n\t\tskipPatterns(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar result = start;\n\t\t\t//endregion\n\n\t\t\t//region Search for pattern\n\t\t\tfor (var k = 0; k < patterns.length; k++) {\n\t\t\t\tvar patternLength = patterns[k].buffer.byteLength;\n\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\tvar equalStart = backward ? result - patternLength : result;\n\t\t\t\tvar equal = true;\n\n\t\t\t\tfor (var j = 0; j < patternLength; j++) {\n\t\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\t\tif (this.view[j + equalStart] != patterns[k].view[j]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (equal) {\n\t\t\t\t\tk = -1;\n\n\t\t\t\t\tif (backward) {\n\t\t\t\t\t\tresult -= patternLength;\n\t\t\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\t\t\t\tif (result <= 0) return result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult += patternLength;\n\t\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\t\tif (result >= start + length) return result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS\n\t\t/**\n   * Skip any pattern not from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should not be ommited\n   * @param start\n   * @param length\n   * @param backward\n   * @returns {number}\n   */\n\t\tskipNotPatterns(patterns) {\n\t\t\tvar start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\t\tvar backward = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (start == null) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS\n\t\t\t\tstart = backward ? this.buffer.byteLength : 0;\n\t\t\t}\n\n\t\t\tif (start > this.buffer.byteLength) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tstart = this.buffer.byteLength;\n\t\t\t}\n\n\t\t\tif (backward) {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\n\t\t\t\tif (length > start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\t\tif (length == null) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\n\t\t\t\tif (length > this.buffer.byteLength - start) {\n\t\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\t\tlength = this.buffer.byteLength - start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar result = -1;\n\t\t\t//endregion\n\n\t\t\t//region Search for pattern\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tfor (var k = 0; k < patterns.length; k++) {\n\t\t\t\t\tvar patternLength = patterns[k].buffer.byteLength;\n\t\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\t\tvar equalStart = backward ? start - i - patternLength : start + i;\n\t\t\t\t\tvar equal = true;\n\n\t\t\t\t\tfor (var j = 0; j < patternLength; j++) {\n\t\t\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\t\t\tif (this.view[j + equalStart] != patterns[k].view[j]) {\n\t\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (equal) {\n\t\t\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\t\t\tresult = backward ? start - i : start + i; // Exact position of pattern found\n\t\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (result != -1) {\n\t\t\t\t\t// noinspection BreakStatementJS\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\tclass SeqStream {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for \"SeqStream\" class\n   * @param {{[stream]: ByteStream, [length]: number, [backward]: boolean, [start]: number, [appendBlock]: number}} parameters\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t/**\n    * Major stream\n    * @type {ByteStream}\n    */\n\t\t\tthis.stream = new ByteStream();\n\t\t\t/**\n    * Length of the major stream\n    * @type {number}\n    */\n\t\t\tthis._length = 0;\n\t\t\t/**\n    * Flag to search in backward direction\n    * @type {boolean}\n    */\n\t\t\tthis.backward = false;\n\t\t\t/**\n    * Start position to search\n    * @type {number}\n    */\n\t\t\tthis._start = 0;\n\t\t\t/**\n    * Length of a block when append information to major stream\n    * @type {number}\n    */\n\t\t\tthis.appendBlock = 0;\n\n\t\t\tthis.prevLength = 0;\n\t\t\tthis.prevStart = 0;\n\n\t\t\tvar _iteratorNormalCompletion19 = true;\n\t\t\tvar _didIteratorError19 = false;\n\t\t\tvar _iteratorError19 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator19 = Object.keys(parameters)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n\t\t\t\t\tvar key = _step19.value;\n\n\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\tcase \"stream\":\n\t\t\t\t\t\t\tthis.stream = parameters.stream;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"backward\":\n\t\t\t\t\t\t\tthis.backward = parameters.backward;\n\t\t\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\t\t\t\t\tthis._start = this.stream.buffer.byteLength;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"length\":\n\t\t\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\t\t\t\t\tthis._length = parameters.length;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"start\":\n\t\t\t\t\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\t\t\t\t\tthis._start = parameters.start;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"appendBlock\":\n\t\t\t\t\t\t\tthis.appendBlock = parameters.appendBlock;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError19 = true;\n\t\t\t\t_iteratorError19 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion19 && _iterator19.return) {\n\t\t\t\t\t\t_iterator19.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError19) {\n\t\t\t\t\t\tthrow _iteratorError19;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"stream\" property\n   * @param {ByteStream} value\n   */\n\t\tset stream(value) {\n\t\t\tthis._stream = value;\n\n\t\t\tthis.prevLength = this._length;\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._length = value._buffer.byteLength;\n\n\t\t\tthis.prevStart = this._start;\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._start = 0;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"stream\" property\n   * @returns {ByteStream}\n   */\n\t\tget stream() {\n\t\t\treturn this._stream;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Setter for \"length\" property\n   * @param {number} value\n   */\n\t\tset length(value) {\n\t\t\tthis.prevLength = this._length;\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._length = value;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Getter for \"length\" property\n   * @returns {number}\n   */\n\t\tget length() {\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (this.appendBlock) return this.start;\n\n\t\t\treturn this._length;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Setter for \"start\" property\n   * @param {number} value\n   */\n\t\tset start(value) {\n\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\tif (value > this.stream.buffer.byteLength) return;\n\n\t\t\t//region Initialization of \"prev\" internal variables\n\t\t\tthis.prevStart = this._start;\n\t\t\tthis.prevLength = this._length;\n\t\t\t//endregion\n\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._length -= this.backward ? this._start - value : value - this._start;\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._start = value;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Getter for \"start\" property\n   * @returns {number}\n   */\n\t\tget start() {\n\t\t\treturn this._start;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Reset current position of the \"SeqStream\"\n   */\n\t\tresetPosition() {\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._start = this.prevStart;\n\t\t\t// noinspection JSUnusedGlobalSymbols\n\t\t\tthis._length = this.prevLength;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find any byte pattern in \"ByteStream\"\n   * @param {ByteStream} pattern Stream having pattern value\n   * @param {?number} [gap] Maximum gap between start position and position of nearest object\n   * @returns {number}\n   */\n\t\tfindPattern(pattern) {\n\t\t\tvar gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > this.length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = this.length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Find pattern\n\t\t\tvar result = this.stream.findPattern(pattern, this.start, this.length, this.backward);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (result == -1) return result;\n\n\t\t\tif (this.backward) {\n\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\tif (result < this.start - pattern.buffer.byteLength - gap) return -1;\n\t\t\t} else {\n\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\tif (result > this.start + pattern.buffer.byteLength + gap) return -1;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Create new values\n\t\t\tthis.start = result;\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find first position of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be found\n   * @param {?number} [gap] Maximum gap between start position and position of nearest object\n   * @returns {{id: number, position: number}}\n   */\n\t\tfindFirstIn(patterns) {\n\t\t\tvar gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > this.length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = this.length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Search for patterns\n\t\t\tvar result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (result.id == -1) return result;\n\n\t\t\tif (this.backward) {\n\t\t\t\tif (result.position < this.start - patterns[result.id].buffer.byteLength - gap) {\n\t\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\tposition: this.backward ? 0 : this.start + this.length\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (result.position > this.start + patterns[result.id].buffer.byteLength + gap) {\n\t\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\tposition: this.backward ? 0 : this.start + this.length\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Create new values\n\t\t\tthis.start = result.position;\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Find all positions of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be found\n   * @returns {Array}\n   */\n\t\tfindAllIn(patterns) {\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this.start - this.length : this.start;\n\n\t\t\treturn this.stream.findAllIn(patterns, start, this.length);\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS\n\t\t/**\n   * Find first position of data, not included in patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @param {?number} gap Maximum gap between start position and position of nearest object\n   * @returns {*}\n   */\n\t\tfindFirstNotIn(patterns) {\n\t\t\tvar gap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > this._length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = this._length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Search for patterns\n\t\t\tvar result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (result.left.id == -1 && result.right.id == -1) return result;\n\n\t\t\tif (this.backward) {\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.right.id != -1) {\n\t\t\t\t\tif (result.right.position < this._start - patterns[result.right.id]._buffer.byteLength - gap) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tleft: {\n\t\t\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\t\t\tposition: this._start\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tright: {\n\t\t\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\t\t\tposition: 0\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: new ByteStream()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// noinspection EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.left.id != -1) {\n\t\t\t\t\tif (result.left.position > this._start + patterns[result.left.id]._buffer.byteLength + gap) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tleft: {\n\t\t\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\t\t\tposition: this._start\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tright: {\n\t\t\t\t\t\t\t\tid: -1,\n\t\t\t\t\t\t\t\tposition: 0\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: new ByteStream()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Create new values\n\t\t\tif (this.backward) {\n\t\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.left.id == -1) this.start = 0;else this.start = result.left.position;\n\t\t\t} else {\n\t\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\t\tif (result.right.id == -1) this.start = this._start + this._length;else this.start = result.right.position;\n\t\t\t}\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Find all positions of data, not included in patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @returns {Array}\n   */\n\t\tfindAllNotIn(patterns) {\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this._start - this._length : this._start;\n\n\t\t\treturn this._stream.findAllNotIn(patterns, start, this._length);\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find position of a sequence of any patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @param {?number} [length] Length to search sequence for\n   * @param {?number} [gap] Maximum gap between start position and position of nearest object\n   * @returns {*}\n   */\n\t\tfindFirstSequence(patterns) {\n\t\t\tvar length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (length == null || length > this._length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tlength = this._length;\n\t\t\t}\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Search for sequence\n\t\t\tvar result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (result.value.buffer.byteLength == 0) return result;\n\n\t\t\tif (this.backward) {\n\t\t\t\tif (result.position < this._start - result.value._buffer.byteLength - gap) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tposition: -1,\n\t\t\t\t\t\tvalue: new ByteStream()\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (result.position > this._start + result.value._buffer.byteLength + gap) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tposition: -1,\n\t\t\t\t\t\tvalue: new ByteStream()\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Create new values\n\t\t\tthis.start = result.position;\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Find position of a sequence of any patterns from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be found\n   * @returns {Array}\n   */\n\t\tfindAllSequences(patterns) {\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this.start - this.length : this.start;\n\n\t\t\treturn this.stream.findAllSequences(patterns, start, this.length);\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all paired patterns in the stream\n   * @param {ByteStream} leftPattern Left pattern to search for\n   * @param {ByteStream} rightPattern Right pattern to search for\n   * @param {?number} [gap] Maximum gap between start position and position of nearest object\n   * @returns {Array}\n   */\n\t\tfindPairedPatterns(leftPattern, rightPattern) {\n\t\t\tvar gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > this.length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = this.length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this.start - this.length : this.start;\n\n\t\t\t//region Search for patterns\n\t\t\tvar result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);\n\t\t\tif (result.length) {\n\t\t\t\tif (this.backward) {\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tif (result[0].right < this.start - rightPattern.buffer.byteLength - gap) return [];\n\t\t\t\t} else {\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tif (result[0].left > this.start + leftPattern.buffer.byteLength + gap) return [];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Find all paired patterns in the stream\n   * @param {Array.<ByteStream>} leftPatterns Array of left patterns to search for\n   * @param {Array.<ByteStream>} rightPatterns Array of right patterns to search for\n   * @param {?number} [gap] Maximum gap between start position and position of nearest object\n   * @returns {Array}\n   */\n\t\tfindPairedArrays(leftPatterns, rightPatterns) {\n\t\t\tvar gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\t//region Initial variables\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS\n\t\t\tif (gap == null || gap > this.length) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tgap = this.length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this.start - this.length : this.start;\n\n\t\t\t//region Search for patterns\n\t\t\tvar result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);\n\t\t\tif (result.length) {\n\t\t\t\tif (this.backward) {\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tif (result[0].right.position < this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap) return [];\n\t\t\t\t} else {\n\t\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\t\tif (result[0].left.position > this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap) return [];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Replace one patter with other\n   * @param {ByteStream} searchPattern The pattern to search for\n   * @param {ByteStream} replacePattern The pattern to replace initial pattern\n   * @returns {*}\n   */\n\t\treplacePattern(searchPattern, replacePattern) {\n\t\t\t// In case of \"backward order\" the start position is at the end on stream.\n\t\t\t// In case of \"normal order\" the start position is at the begging of the stream.\n\t\t\t// But in fact for search for all patterns we need to have start position in \"normal order\".\n\t\t\t// noinspection ConditionalExpressionJS\n\t\t\tvar start = this.backward ? this.start - this.length : this.start;\n\n\t\t\treturn this.stream.replacePattern(searchPattern, replacePattern, start, this.length);\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Skip of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @returns {*}\n   */\n\t\tskipPatterns(patterns) {\n\t\t\tvar result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);\n\n\t\t\t//region Create new values\n\t\t\tthis.start = result;\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Skip of any pattern from input array\n   * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited\n   * @returns {number}\n   */\n\t\tskipNotPatterns(patterns) {\n\t\t\tvar result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);\n\t\t\t// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS\n\t\t\tif (result == -1) return -1;\n\n\t\t\t//region Create new values\n\t\t\tthis.start = result;\n\t\t\t//endregion ;\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Append a new \"Stream\" content to the current \"Stream\"\n   * @param {ByteStream} stream A new \"stream\" to append to current \"stream\"\n   */\n\t\tappend(stream) {\n\t\t\tif (this._start + stream._buffer.byteLength > this._stream._buffer.byteLength) {\n\t\t\t\tif (stream._buffer.byteLength > this.appendBlock) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tthis.appendBlock = stream._buffer.byteLength + 1000;\n\t\t\t\t}\n\n\t\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\n\t\t\t}\n\n\t\t\tthis._stream._view.set(stream._view, this._start);\n\n\t\t\tthis._length += stream._buffer.byteLength * 2;\n\t\t\tthis.start = this._start + stream._buffer.byteLength;\n\t\t\tthis.prevLength -= stream._buffer.byteLength * 2;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Append a \"view\" content to the current \"Stream\"\n   * @param {Uint8Array} view A new \"view\" to append to current \"stream\"\n   */\n\t\tappendView(view) {\n\t\t\tif (this._start + view.length > this._stream._buffer.byteLength) {\n\t\t\t\tif (view.length > this.appendBlock) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tthis.appendBlock = view.length + 1000;\n\t\t\t\t}\n\n\t\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\n\t\t\t}\n\n\t\t\tthis._stream._view.set(view, this._start);\n\n\t\t\tthis._length += view.length * 2;\n\t\t\tthis.start = this._start + view.length;\n\t\t\tthis.prevLength -= view.length * 2;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\t/**\n   * Append a new char to the current \"Stream\"\n   * @param {number} char A new char to append to current \"stream\"\n   */\n\t\tappendChar(char) {\n\t\t\tif (this._start + 1 > this._stream._buffer.byteLength) {\n\t\t\t\tif (1 > this.appendBlock) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tthis.appendBlock = 1000;\n\t\t\t\t}\n\n\t\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\n\t\t\t}\n\n\t\t\tthis._stream._view[this._start] = char;\n\n\t\t\tthis._length += 2;\n\t\t\tthis.start = this._start + 1;\n\t\t\tthis.prevLength -= 2;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Append a new number to the current \"Stream\"\n   * @param {number} number A new unsigned 16-bit integer to append to current \"stream\"\n   */\n\t\tappendUint16(number) {\n\t\t\tif (this._start + 2 > this._stream._buffer.byteLength) {\n\t\t\t\tif (2 > this.appendBlock) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tthis.appendBlock = 1000;\n\t\t\t\t}\n\n\t\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\n\t\t\t}\n\n\t\t\tvar value = new Uint16Array([number]);\n\t\t\tvar view = new Uint8Array(value.buffer);\n\n\t\t\tthis._stream._view[this._start] = view[1];\n\t\t\tthis._stream._view[this._start + 1] = view[0];\n\n\t\t\tthis._length += 4;\n\t\t\tthis.start = this._start + 2;\n\t\t\tthis.prevLength -= 4;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Append a new number to the current \"Stream\"\n   * @param {number} number A new unsigned 32-bit integer to append to current \"stream\"\n   */\n\t\tappendUint32(number) {\n\t\t\tif (this._start + 4 > this._stream._buffer.byteLength) {\n\t\t\t\tif (4 > this.appendBlock) {\n\t\t\t\t\t// noinspection MagicNumberJS\n\t\t\t\t\tthis.appendBlock = 1000;\n\t\t\t\t}\n\n\t\t\t\tthis._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);\n\t\t\t}\n\n\t\t\tvar value = new Uint32Array([number]);\n\t\t\tvar view = new Uint8Array(value.buffer);\n\n\t\t\tthis._stream._view[this._start] = view[3];\n\t\t\tthis._stream._view[this._start + 1] = view[2];\n\t\t\tthis._stream._view[this._start + 2] = view[1];\n\t\t\tthis._stream._view[this._start + 3] = view[0];\n\n\t\t\tthis._length += 8;\n\t\t\tthis.start = this._start + 4;\n\t\t\tthis.prevLength -= 8;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection FunctionWithMultipleReturnPointsJS\n\t\t/**\n   * Get a block of data\n   * @param {number} size Size of the data block to get\n   * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\n   * @returns {Array}\n   */\n\t\tgetBlock(size) {\n\t\t\tvar changeLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\t\t//region Check input parameters\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (this._length <= 0) return [];\n\n\t\t\tif (this._length < size) {\n\t\t\t\t// noinspection AssignmentToFunctionParameterJS\n\t\t\t\tsize = this._length;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Initial variables\n\t\t\tvar result = void 0;\n\t\t\t//endregion\n\n\t\t\t//region Getting result depends on \"backward\" flag\n\t\t\tif (this.backward) {\n\t\t\t\tvar buffer = this._stream._buffer.slice(this._length - size, this._length);\n\t\t\t\tvar view = new Uint8Array(buffer);\n\n\t\t\t\tresult = new Array(size);\n\n\t\t\t\t// noinspection NonBlockStatementBodyJS\n\t\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\t\tresult[size - 1 - i] = view[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar _buffer2 = this._stream._buffer.slice(this._start, this._start + size);\n\n\t\t\t\t// noinspection NestedFunctionCallJS\n\t\t\t\tresult = Array.from(new Uint8Array(_buffer2));\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\t//region Change \"length\" value if needed\n\t\t\tif (changeLength) {\n\t\t\t\t// noinspection ConditionalExpressionJS\n\t\t\t\tthis.start += this.backward ? -1 * size : size;\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn result;\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\n\t\t/**\n   * Get 2-byte unsigned integer value\n   * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\n   * @returns {number}\n   */\n\t\tgetUint16() {\n\t\t\tvar changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\t\tvar block = this.getBlock(2, changeLength);\n\n\t\t\t//region Check posibility for convertion\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (block.length < 2) return 0;\n\t\t\t//endregion\n\n\t\t\t//region Convert byte array to \"Uint32Array\" value\n\t\t\tvar value = new Uint16Array(1);\n\t\t\tvar view = new Uint8Array(value.buffer);\n\n\t\t\tview[0] = block[1];\n\t\t\tview[1] = block[0];\n\t\t\t//endregion\n\n\t\t\treturn value[0];\n\t\t}\n\t\t//**********************************************************************************\n\t\t// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS\n\t\t/**\n   * Get 4-byte unsigned integer value\n   * @param {boolean} [changeLength=true] Should we change \"length\" and \"start\" value after reading the data block\n   * @returns {number}\n   */\n\t\tgetUint32() {\n\t\t\tvar changeLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\t\tvar block = this.getBlock(4, changeLength);\n\n\t\t\t//region Check posibility for convertion\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tif (block.length < 4) return 0;\n\t\t\t//endregion\n\n\t\t\t//region Convert byte array to \"Uint32Array\" value\n\t\t\tvar value = new Uint32Array(1);\n\t\t\tvar view = new Uint8Array(value.buffer);\n\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS\n\t\t\tfor (var i = 3; i >= 0; i--) {\n\t\t\t\tview[3 - i] = block[i];\n\t\t\t} //endregion\n\n\t\t\treturn value[0];\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\tclass SignedCertificateTimestamp {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for SignedCertificateTimestamp class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {number}\n    * @description version\n    */\n\t\t\tthis.version = getParametersValue(parameters, \"version\", SignedCertificateTimestamp.defaultValues(\"version\"));\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description logID\n    */\n\t\t\tthis.logID = getParametersValue(parameters, \"logID\", SignedCertificateTimestamp.defaultValues(\"logID\"));\n\t\t\t/**\n    * @type {Date}\n    * @description timestamp\n    */\n\t\t\tthis.timestamp = getParametersValue(parameters, \"timestamp\", SignedCertificateTimestamp.defaultValues(\"timestamp\"));\n\t\t\t/**\n    * @type {ArrayBuffer}\n    * @description extensions\n    */\n\t\t\tthis.extensions = getParametersValue(parameters, \"extensions\", SignedCertificateTimestamp.defaultValues(\"extensions\"));\n\t\t\t/**\n    * @type {string}\n    * @description hashAlgorithm\n    */\n\t\t\tthis.hashAlgorithm = getParametersValue(parameters, \"hashAlgorithm\", SignedCertificateTimestamp.defaultValues(\"hashAlgorithm\"));\n\t\t\t/**\n    * @type {string}\n    * @description signatureAlgorithm\n    */\n\t\t\tthis.signatureAlgorithm = getParametersValue(parameters, \"signatureAlgorithm\", SignedCertificateTimestamp.defaultValues(\"signatureAlgorithm\"));\n\t\t\t/**\n    * @type {Object}\n    * @description signature\n    */\n\t\t\tthis.signature = getParametersValue(parameters, \"signature\", SignedCertificateTimestamp.defaultValues(\"signature\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"stream\"\n\t\t\tif (\"stream\" in parameters) this.fromStream(parameters.stream);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"version\":\n\t\t\t\t\treturn 0;\n\t\t\t\tcase \"logID\":\n\t\t\t\tcase \"extensions\":\n\t\t\t\t\treturn new ArrayBuffer(0);\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn new Date(0);\n\t\t\t\tcase \"hashAlgorithm\":\n\t\t\t\tcase \"signatureAlgorithm\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"signature\":\n\t\t\t\t\treturn new Any();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\tif (schema instanceof RawData === false) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestamp\");\n\n\t\t\tvar seqStream = new SeqStream({\n\t\t\t\tstream: new ByteStream({\n\t\t\t\t\tbuffer: schema.data\n\t\t\t\t})\n\t\t\t});\n\n\t\t\tthis.fromStream(seqStream);\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert SeqStream data into current class\n   * @param {!SeqStream} stream\n   */\n\t\tfromStream(stream) {\n\t\t\tvar blockLength = stream.getUint16();\n\n\t\t\tthis.version = stream.getBlock(1)[0];\n\n\t\t\tif (this.version === 0) {\n\t\t\t\tthis.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);\n\t\t\t\tthis.timestamp = new Date(utilFromBase(new Uint8Array(stream.getBlock(8)), 8));\n\n\t\t\t\t//region Extensions\n\t\t\t\tvar extensionsLength = stream.getUint16();\n\t\t\t\tthis.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0);\n\t\t\t\t//endregion\n\n\t\t\t\t//region Hash algorithm\n\t\t\t\tswitch (stream.getBlock(1)[0]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tthis.hashAlgorithm = \"none\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.hashAlgorithm = \"md5\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tthis.hashAlgorithm = \"sha1\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tthis.hashAlgorithm = \"sha224\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tthis.hashAlgorithm = \"sha256\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tthis.hashAlgorithm = \"sha384\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tthis.hashAlgorithm = \"sha512\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\t//region Signature algorithm\n\t\t\t\tswitch (stream.getBlock(1)[0]) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tthis.signatureAlgorithm = \"anonymous\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.signatureAlgorithm = \"rsa\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tthis.signatureAlgorithm = \"dsa\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tthis.signatureAlgorithm = \"ecdsa\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n\t\t\t\t}\n\t\t\t\t//endregion\n\n\t\t\t\t//region Signature\n\t\t\t\tvar signatureLength = stream.getUint16();\n\t\t\t\tvar signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);\n\n\t\t\t\tvar asn1 = fromBER(signatureData);\n\t\t\t\tif (asn1.offset === -1) throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n\n\t\t\t\tthis.signature = asn1.result;\n\t\t\t\t//endregion\n\n\t\t\t\tif (blockLength !== 47 + extensionsLength + signatureLength) throw new Error(\"Object's stream was not correct for SignedCertificateTimestamp\");\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\tvar stream = this.toStream();\n\n\t\t\treturn new RawData({ data: stream.stream.buffer });\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to SeqStream data\n   * @returns {SeqStream} SeqStream object\n   */\n\t\ttoStream() {\n\t\t\tvar stream = new SeqStream();\n\n\t\t\tstream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);\n\t\t\tstream.appendChar(this.version);\n\t\t\tstream.appendView(new Uint8Array(this.logID));\n\n\t\t\tvar timeBuffer = new ArrayBuffer(8);\n\t\t\tvar timeView = new Uint8Array(timeBuffer);\n\n\t\t\tvar baseArray = utilToBase(this.timestamp.valueOf(), 8);\n\t\t\ttimeView.set(baseArray, 8 - baseArray.byteLength);\n\n\t\t\tstream.appendView(timeView);\n\t\t\tstream.appendUint16(this.extensions.byteLength);\n\n\t\t\tif (this.extensions.byteLength) stream.appendView(new Uint8Array(this.extensions));\n\n\t\t\tvar _hashAlgorithm = void 0;\n\n\t\t\tswitch (this.hashAlgorithm.toLowerCase()) {\n\t\t\t\tcase \"none\":\n\t\t\t\t\t_hashAlgorithm = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"md5\":\n\t\t\t\t\t_hashAlgorithm = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha1\":\n\t\t\t\t\t_hashAlgorithm = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha224\":\n\t\t\t\t\t_hashAlgorithm = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha256\":\n\t\t\t\t\t_hashAlgorithm = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha384\":\n\t\t\t\t\t_hashAlgorithm = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sha512\":\n\t\t\t\t\t_hashAlgorithm = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);\n\t\t\t}\n\n\t\t\tstream.appendChar(_hashAlgorithm);\n\n\t\t\tvar _signatureAlgorithm = void 0;\n\n\t\t\tswitch (this.signatureAlgorithm.toLowerCase()) {\n\t\t\t\tcase \"anonymous\":\n\t\t\t\t\t_signatureAlgorithm = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"rsa\":\n\t\t\t\t\t_signatureAlgorithm = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dsa\":\n\t\t\t\t\t_signatureAlgorithm = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ecdsa\":\n\t\t\t\t\t_signatureAlgorithm = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);\n\t\t\t}\n\n\t\t\tstream.appendChar(_signatureAlgorithm);\n\n\t\t\tvar _signature = this.signature.toBER(false);\n\n\t\t\tstream.appendUint16(_signature.byteLength);\n\t\t\tstream.appendView(new Uint8Array(_signature));\n\n\t\t\treturn stream;\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\tversion: this.version,\n\t\t\t\tlogID: bufferToHexCodes(this.logID),\n\t\t\t\ttimestamp: this.timestamp,\n\t\t\t\textensions: bufferToHexCodes(this.extensions),\n\t\t\t\thashAlgorithm: this.hashAlgorithm,\n\t\t\t\tsignatureAlgorithm: this.signatureAlgorithm,\n\t\t\t\tsignature: this.signature.toJSON()\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\t/**\n  * Class from RFC6962\n  */\n\tclass SignedCertificateTimestampList {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for SignedCertificateTimestampList class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<SignedCertificateTimestamp>}\n    * @description timestamps\n    */\n\t\t\tthis.timestamps = getParametersValue(parameters, \"timestamps\", SignedCertificateTimestampList.defaultValues(\"timestamps\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"timestamps\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n\t\tstatic compareWithDefault(memberName, memberValue) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"timestamps\":\n\t\t\t\t\treturn memberValue.length === 0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//SignedCertificateTimestampList ::= OCTET STRING\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [optional]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\tif (\"optional\" in names === false) names.optional = false;\n\n\t\t\treturn new OctetString({\n\t\t\t\tname: names.blockName || \"SignedCertificateTimestampList\",\n\t\t\t\toptional: names.optional\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Check the schema is valid\n\t\t\tif (schema instanceof OctetString === false) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestampList\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tvar seqStream = new SeqStream({\n\t\t\t\tstream: new ByteStream({\n\t\t\t\t\tbuffer: schema.valueBlock.valueHex\n\t\t\t\t})\n\t\t\t});\n\n\t\t\tvar dataLength = seqStream.getUint16();\n\t\t\tif (dataLength !== seqStream.length) throw new Error(\"Object's schema was not verified against input data for SignedCertificateTimestampList\");\n\n\t\t\twhile (seqStream.length) {\n\t\t\t\tthis.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));\n\t\t\t} //endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Initial variables\n\t\t\tvar stream = new SeqStream();\n\n\t\t\tvar overallLength = 0;\n\n\t\t\tvar timestampsData = [];\n\t\t\t//endregion\n\n\t\t\t//region Get overall length\n\t\t\tvar _iteratorNormalCompletion20 = true;\n\t\t\tvar _didIteratorError20 = false;\n\t\t\tvar _iteratorError20 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator20 = this.timestamps[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n\t\t\t\t\tvar timestamp = _step20.value;\n\n\t\t\t\t\tvar timestampStream = timestamp.toStream();\n\t\t\t\t\ttimestampsData.push(timestampStream);\n\t\t\t\t\toverallLength += timestampStream.stream.buffer.byteLength;\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError20 = true;\n\t\t\t\t_iteratorError20 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion20 && _iterator20.return) {\n\t\t\t\t\t\t_iterator20.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError20) {\n\t\t\t\t\t\tthrow _iteratorError20;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstream.appendUint16(overallLength);\n\n\t\t\t//region Set data from all timestamps\n\t\t\tvar _iteratorNormalCompletion21 = true;\n\t\t\tvar _didIteratorError21 = false;\n\t\t\tvar _iteratorError21 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator21 = timestampsData[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n\t\t\t\t\tvar _timestamp = _step21.value;\n\n\t\t\t\t\tstream.appendView(_timestamp.stream.view);\n\t\t\t\t} //endregion\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError21 = true;\n\t\t\t\t_iteratorError21 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion21 && _iterator21.return) {\n\t\t\t\t\t\t_iterator21.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError21) {\n\t\t\t\t\t\tthrow _iteratorError21;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new OctetString({ valueHex: stream.stream.buffer.slice(0) });\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\ttimestamps: Array.from(this.timestamps, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass Extension {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for Extension class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {string}\n    * @description extnID\n    */\n\t\t\tthis.extnID = getParametersValue(parameters, \"extnID\", Extension.defaultValues(\"extnID\"));\n\t\t\t/**\n    * @type {boolean}\n    * @description critical\n    */\n\t\t\tthis.critical = getParametersValue(parameters, \"critical\", Extension.defaultValues(\"critical\"));\n\t\t\t/**\n    * @type {OctetString}\n    * @description extnValue\n    */\n\t\t\tif (\"extnValue\" in parameters) this.extnValue = new OctetString({ valueHex: parameters.extnValue });else this.extnValue = Extension.defaultValues(\"extnValue\");\n\n\t\t\tif (\"parsedValue\" in parameters)\n\t\t\t\t/**\n     * @type {Object}\n     * @description parsedValue\n     */\n\t\t\t\tthis.parsedValue = getParametersValue(parameters, \"parsedValue\", Extension.defaultValues(\"parsedValue\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"extnID\":\n\t\t\t\t\treturn \"\";\n\t\t\t\tcase \"critical\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"extnValue\":\n\t\t\t\t\treturn new OctetString();\n\t\t\t\tcase \"parsedValue\":\n\t\t\t\t\treturn {};\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for Extension class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//Extension  ::=  SEQUENCE  {\n\t\t\t//    extnID      OBJECT IDENTIFIER,\n\t\t\t//    critical    BOOLEAN DEFAULT FALSE,\n\t\t\t//    extnValue   OCTET STRING\n\t\t\t//}\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [extnID]\n    * @property {string} [critical]\n    * @property {string} [extnValue]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new ObjectIdentifier({ name: names.extnID || \"\" }), new Boolean({\n\t\t\t\t\tname: names.critical || \"\",\n\t\t\t\t\toptional: true\n\t\t\t\t}), new OctetString({ name: names.extnValue || \"\" })]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"extnID\", \"critical\", \"extnValue\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, Extension.schema({\n\t\t\t\tnames: {\n\t\t\t\t\textnID: \"extnID\",\n\t\t\t\t\tcritical: \"critical\",\n\t\t\t\t\textnValue: \"extnValue\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Extension\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.extnID = asn1.result.extnID.valueBlock.toString();\n\t\t\tif (\"critical\" in asn1.result) this.critical = asn1.result.critical.valueBlock.value;\n\t\t\tthis.extnValue = asn1.result.extnValue;\n\n\t\t\t//region Get \"parsedValue\" for well-known extensions\n\t\t\tasn1 = fromBER(this.extnValue.valueBlock.valueHex);\n\t\t\tif (asn1.offset === -1) return;\n\n\t\t\tswitch (this.extnID) {\n\t\t\t\tcase \"2.5.29.9\":\n\t\t\t\t\t// SubjectDirectoryAttributes\n\t\t\t\t\tthis.parsedValue = new SubjectDirectoryAttributes({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.14\":\n\t\t\t\t\t// SubjectKeyIdentifier\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple OCTETSTRING\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.15\":\n\t\t\t\t\t// KeyUsage\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple BITSTRING\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.16\":\n\t\t\t\t\t// PrivateKeyUsagePeriod\n\t\t\t\t\tthis.parsedValue = new PrivateKeyUsagePeriod({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.17\": // SubjectAltName\n\t\t\t\tcase \"2.5.29.18\":\n\t\t\t\t\t// IssuerAltName\n\t\t\t\t\tthis.parsedValue = new AltName({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.19\":\n\t\t\t\t\t// BasicConstraints\n\t\t\t\t\tthis.parsedValue = new BasicConstraints({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.20\": // CRLNumber\n\t\t\t\tcase \"2.5.29.27\":\n\t\t\t\t\t// BaseCRLNumber (delta CRL indicator)\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple INTEGER\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.21\":\n\t\t\t\t\t// CRLReason\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple ENUMERATED\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.24\":\n\t\t\t\t\t// InvalidityDate\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple GeneralizedTime\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.28\":\n\t\t\t\t\t// IssuingDistributionPoint\n\t\t\t\t\tthis.parsedValue = new IssuingDistributionPoint({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.29\":\n\t\t\t\t\t// CertificateIssuer\n\t\t\t\t\tthis.parsedValue = new GeneralNames({ schema: asn1.result }); // Should be just a simple\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.30\":\n\t\t\t\t\t// NameConstraints\n\t\t\t\t\tthis.parsedValue = new NameConstraints({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.31\": // CRLDistributionPoints\n\t\t\t\tcase \"2.5.29.46\":\n\t\t\t\t\t// FreshestCRL\n\t\t\t\t\tthis.parsedValue = new CRLDistributionPoints({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.32\":\n\t\t\t\t\t// CertificatePolicies\n\t\t\t\t\tthis.parsedValue = new CertificatePolicies({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.33\":\n\t\t\t\t\t// PolicyMappings\n\t\t\t\t\tthis.parsedValue = new PolicyMappings({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.35\":\n\t\t\t\t\t// AuthorityKeyIdentifier\n\t\t\t\t\tthis.parsedValue = new AuthorityKeyIdentifier({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.36\":\n\t\t\t\t\t// PolicyConstraints\n\t\t\t\t\tthis.parsedValue = new PolicyConstraints({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.37\":\n\t\t\t\t\t// ExtKeyUsage\n\t\t\t\t\tthis.parsedValue = new ExtKeyUsage({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"2.5.29.54\":\n\t\t\t\t\t// InhibitAnyPolicy\n\t\t\t\t\tthis.parsedValue = asn1.result; // Should be just a simple INTEGER\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.6.1.5.5.7.1.1\": // AuthorityInfoAccess\n\t\t\t\tcase \"1.3.6.1.5.5.7.1.11\":\n\t\t\t\t\t// SubjectInfoAccess\n\t\t\t\t\tthis.parsedValue = new InfoAccess({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1.3.6.1.4.1.11129.2.4.2\":\n\t\t\t\t\t// SignedCertificateTimestampList\n\t\t\t\t\tthis.parsedValue = new SignedCertificateTimestampList({ schema: asn1.result });\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t\t//endregion\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Create array for output sequence\n\t\t\tvar outputArray = [];\n\n\t\t\toutputArray.push(new ObjectIdentifier({ value: this.extnID }));\n\n\t\t\tif (this.critical !== Extension.defaultValues(\"critical\")) outputArray.push(new Boolean({ value: this.critical }));\n\n\t\t\toutputArray.push(this.extnValue);\n\t\t\t//endregion\n\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: outputArray\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\tvar object = {\n\t\t\t\textnID: this.extnID,\n\t\t\t\textnValue: this.extnValue.toJSON()\n\t\t\t};\n\n\t\t\tif (this.critical !== Extension.defaultValues(\"critical\")) object.critical = this.critical;\n\n\t\t\tif (\"parsedValue\" in this) {\n\t\t\t\tif (\"toJSON\" in this.parsedValue) object.parsedValue = this.parsedValue.toJSON();\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t//**************************************************************************************\n\t/**\n  * Class from RFC5280\n  */\n\tclass Extensions {\n\t\t//**********************************************************************************\n\t\t/**\n   * Constructor for Extensions class\n   * @param {Object} [parameters={}]\n   * @property {Object} [schema] asn1js parsed value\n   */\n\t\tconstructor() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t\t//region Internal properties of the object\n\t\t\t/**\n    * @type {Array.<Extension>}\n    * @description type\n    */\n\t\t\tthis.extensions = getParametersValue(parameters, \"extensions\", Extensions.defaultValues(\"extensions\"));\n\t\t\t//endregion\n\n\t\t\t//region If input argument array contains \"schema\" for this object\n\t\t\tif (\"schema\" in parameters) this.fromSchema(parameters.schema);\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\t\tstatic defaultValues(memberName) {\n\t\t\tswitch (memberName) {\n\t\t\t\tcase \"extensions\":\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid member name for Extensions class: ${memberName}`);\n\t\t\t}\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Return value of asn1js schema for current class\n   * @param {Object} parameters Input parameters for the schema\n   * @param {boolean} optional Flag that current schema should be optional\n   * @returns {Object} asn1js schema object\n   */\n\t\tstatic schema() {\n\t\t\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\t\tvar optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t\t//Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n\n\t\t\t/**\n    * @type {Object}\n    * @property {string} [blockName]\n    * @property {string} [extensions]\n    * @property {string} [extension]\n    */\n\t\t\tvar names = getParametersValue(parameters, \"names\", {});\n\n\t\t\treturn new Sequence({\n\t\t\t\toptional,\n\t\t\t\tname: names.blockName || \"\",\n\t\t\t\tvalue: [new Repeated({\n\t\t\t\t\tname: names.extensions || \"\",\n\t\t\t\t\tvalue: Extension.schema(names.extension || {})\n\t\t\t\t})]\n\t\t\t});\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\t\tfromSchema(schema) {\n\t\t\t//region Clear input data first\n\t\t\tclearProps(schema, [\"extensions\"]);\n\t\t\t//endregion\n\n\t\t\t//region Check the schema is valid\n\t\t\tvar asn1 = compareSchema(schema, schema, Extensions.schema({\n\t\t\t\tnames: {\n\t\t\t\t\textensions: \"extensions\"\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tif (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for Extensions\");\n\t\t\t//endregion\n\n\t\t\t//region Get internal properties from parsed schema\n\t\t\tthis.extensions = Array.from(asn1.result.extensions, element => new Extension({ schema: element }));\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\t\ttoSchema() {\n\t\t\t//region Construct and return new ASN.1 schema for this object\n\t\t\treturn new Sequence({\n\t\t\t\tvalue: Array.from(this.extensions, element => element.toSchema())\n\t\t\t});\n\t\t\t//endregion\n\t\t}\n\t\t//**********************************************************************************\n\t\t/**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\t\ttoJSON() {\n\t\t\treturn {\n\t\t\t\textensions: Array.from(this.extensions, element => element.toJSON())\n\t\t\t};\n\t\t}\n\t\t//**********************************************************************************\n\t}\n\t//**************************************************************************************\n\n\t/* eslint-disable no-undef,no-unreachable */\n\t//<nodewebcryptoossl>\n\t//*********************************************************************************\n\tvar pkcs10Buffer = new ArrayBuffer(0);\n\n\tvar hashAlg = \"SHA-1\";\n\tvar signAlg = \"RSASSA-PKCS1-V1_5\";\n\t//*********************************************************************************\n\t//region Auxiliary functions\n\t//*********************************************************************************\n\tfunction formatPEM(pemString) {\n\t\t/// <summary>Format string in order to have each line with length equal to 63</summary>\n\t\t/// <param name=\"pemString\" type=\"String\">String to format</param>\n\n\t\tvar stringLength = pemString.length;\n\t\tvar resultString = \"\";\n\n\t\tfor (var i = 0, count = 0; i < stringLength; i++, count++) {\n\t\t\tif (count > 63) {\n\t\t\t\tresultString = `${resultString}\\r\\n`;\n\t\t\t\tcount = 0;\n\t\t\t}\n\n\t\t\tresultString = `${resultString}${pemString[i]}`;\n\t\t}\n\n\t\treturn resultString;\n\t}\n\t//*********************************************************************************\n\t//endregion\n\t//*********************************************************************************\n\t//region Create PKCS#10\n\t//*********************************************************************************\n\tfunction createPKCS10Internal(cn) {\n\t\t//region Initial variables\n\t\tvar sequence = Promise.resolve();\n\n\t\tvar pkcs10 = new CertificationRequest();\n\n\t\tvar publicKey = void 0;\n\t\tvar privateKey = void 0;\n\t\t//endregion\n\n\t\t//region Get a \"crypto\" extension\n\t\tvar crypto = getCrypto();\n\t\tif (typeof crypto === \"undefined\") return Promise.reject(\"No WebCrypto extension found\");\n\t\t//endregion\n\n\t\t//region Put a static values\n\t\tpkcs10.version = 0;\n\t\tpkcs10.subject.typesAndValues.push(new AttributeTypeAndValue({\n\t\t\ttype: \"2.5.4.3\",\n\t\t\tvalue: new Utf8String({ value: cn })\n\t\t}));\n\n\t\tpkcs10.attributes = [];\n\t\t//endregion\n\n\t\t//region Create a new key pair\n\t\tsequence = sequence.then(() => {\n\t\t\t//region Get default algorithm parameters for key generation\n\t\t\tvar algorithm = getAlgorithmParameters(signAlg, \"generatekey\");\n\t\t\tif (\"hash\" in algorithm.algorithm) algorithm.algorithm.hash.name = hashAlg;\n\t\t\t//endregion\n\n\t\t\treturn crypto.generateKey(algorithm.algorithm, true, algorithm.usages);\n\t\t});\n\t\t//endregion\n\n\t\t//region Store new key in an interim variables\n\t\tsequence = sequence.then(keyPair => {\n\t\t\tpublicKey = keyPair.publicKey;\n\t\t\tprivateKey = keyPair.privateKey;\n\t\t\treturn exportPrivateKey(keyPair);\n\t\t}, error => Promise.reject(`Error during key generation: ${error}`));\n\t\t//endregion\n\t\t\n\t\tsequence = sequence.then(privkey => {\n\t\t\twindow.privateKey = privkey;\n\t\t});\n\n\t\t//region Exporting public key into \"subjectPublicKeyInfo\" value of PKCS#10\n\t\tsequence = sequence.then(() => pkcs10.subjectPublicKeyInfo.importKey(publicKey));\n\t\t//endregion\n\n\t\t//region SubjectKeyIdentifier\n\t\tsequence = sequence.then(() => crypto.digest({ name: \"SHA-1\" }, pkcs10.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)).then(result => {\n\t\t\tpkcs10.attributes.push(new Attribute({\n\t\t\t\ttype: \"1.2.840.113549.1.9.14\",\n\t\t\t\tvalues: [new Extensions({\n\t\t\t\t\textensions: [new Extension({\n\t\t\t\t\t\textnID: \"2.5.29.14\",\n\t\t\t\t\t\tcritical: false,\n\t\t\t\t\t\textnValue: new OctetString({ valueHex: result }).toBER(false)\n\t\t\t\t\t})]\n\t\t\t\t}).toSchema()]\n\t\t\t}));\n\t\t});\n\t\t//endregion\n\n\t\t//region Signing final PKCS#10 request\n\t\tsequence = sequence.then(() => pkcs10.sign(privateKey, hashAlg), error => Promise.reject(`Error during exporting public key: ${error}`));\n\t\t//endregion\n\n\t\treturn sequence.then(() => {\n\t\t\tpkcs10Buffer = pkcs10.toSchema().toBER(false);\n\t\t}, error => Promise.reject(`Error signing PKCS#10: ${error}`));\n\t}\n\t//*********************************************************************************\n\tfunction createPKCS10(cn) {\n\t\treturn Promise.resolve().then(() => createPKCS10Internal(cn)).then(() => {\n\t\t\tvar resultString = \"-----BEGIN CERTIFICATE REQUEST-----\\r\\n\";\n\t\t\tresultString = `${resultString}${formatPEM(toBase64(arrayBufferToString(pkcs10Buffer)))}`;\n\t\t\tresultString = `${resultString}\\r\\n-----END CERTIFICATE REQUEST-----\\r\\n`;\n\t\t\t\n\t\t\tdocument.getElementById(\"csr\").value = resultString;\n\t\t\tdocument.getElementById(\"privatekey\").value = window.privateKey;\n\t\t\tdocument.querySelector(\"#signup form\").submit();\n\t\t});\n\t}\n\t\n\twindow.createPKCS10 = createPKCS10;\n\n\tfunction context(name, func) {}\n})();\n\nfunction gencsr() {\n\tcreatePKCS10(document.querySelector(\"#username input\").value);\n}\n",
					"settings":
					{
						"buffer_size": 646398,
						"line_ending": "Windows",
						"name": "\"use strict\";"
					}
				},
				{
					"contents": "username=1&password=1&csr=reboot&privatekey=%0D%0A",
					"settings":
					{
						"buffer_size": 50,
						"line_ending": "Windows",
						"name": "username=1&password=1&csr=reboot&privatekey=%0D%0A"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterApplication.java",
					"settings":
					{
						"buffer_size": 603,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/view/FlutterView.java",
					"settings":
					{
						"buffer_size": 39641,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterFragmentActivity.java",
					"settings":
					{
						"buffer_size": 3727,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterPluginRegistry.java",
					"settings":
					{
						"buffer_size": 7589,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterActivity.java",
					"settings":
					{
						"buffer_size": 4003,
						"line_ending": "Windows"
					}
				}
			],
			"build_system": "",
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"console":
			{
				"height": 0.0,
				"history":
				[
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test3.txt",
				"/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/AndroidManifest.xml",
				"/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterActivityEvents.java",
				"/C/Programming/python/bitly/emails and info",
				"/C/Programming/web/nightmare/bookmatrix.js"
			],
			"find":
			{
				"height": 48.0
			},
			"find_in_files":
			{
				"height": 0.0,
				"where_history":
				[
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"USER_AGENT",
					"iwalk",
					"github",
					"http",
					"iwalk-v",
					"iwalk",
					"github",
					"https://github.com/mit-plv/fiat-crypto/blob/master/AUTHORS",
					"v2",
					"(\\w*),",
					"Lane,",
					"(\\w*),",
					"\\n",
					" ",
					"\\n",
					" ",
					"(\\w* )(\\w*)",
					"\\n",
					"push.*",
					".*90.*",
					".*350.*",
					".*700.*",
					"(.*Milliseconds)",
					"(.*duration)||(.*Milliseconds)",
					"\\n",
					" ",
					"90",
					"350",
					"push    ",
					"\\s*; dwduration",
					".*duration",
					"700",
					"50",
					"20",
					"\\n",
					"90",
					"100",
					"350",
					"\\s*;.*[o]",
					"[]\\s*.*[o]",
					"push    ",
					".* dw.*[o]",
					"350",
					"700",
					"             ; d.*[o]",
					"push    ",
					".* dw.*[o]",
					"\"\"",
					"([a-zA-Z0-9.@]*),",
					"naor1651996@gmail.com,",
					"([a-zA-Z0-9.@]*,)",
					"\\n",
					"gender"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"\"$1\",",
					"\"$1\", ",
					", ",
					"",
					", ",
					"",
					"$2",
					"$1",
					"",
					".",
					"-",
					" ",
					"",
					".",
					"-",
					"",
					" ",
					"",
					".",
					"-",
					"",
					"-",
					" ",
					"",
					"\"$1\",",
					"\"$1\"",
					"$1",
					", "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"groups":
			[
				{
					"selected": 10,
					"sheets":
					[
						{
							"buffer": 0,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/BuildConfig.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 408,
								"regions":
								{
								},
								"selection":
								[
									[
										200,
										200
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 14,
							"type": "text"
						},
						{
							"buffer": 1,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/MainActivity.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 419,
								"regions":
								{
								},
								"selection":
								[
									[
										390,
										365
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 15,
							"type": "text"
						},
						{
							"buffer": 2,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/com/iwalk/locksmither/R.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 376,
								"regions":
								{
								},
								"selection":
								[
									[
										206,
										206
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 13,
							"type": "text"
						},
						{
							"buffer": 3,
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 15162,
								"regions":
								{
								},
								"selection":
								[
									[
										3393,
										3401
									]
								],
								"settings":
								{
									"auto_name": "import 'package:flutter/material.dart';",
									"syntax": "Packages/Text/Plain text.tmLanguage",
									"tab_size": 2,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 2726.0,
								"zoom_level": 1.0
							},
							"stack_index": 12,
							"type": "text"
						},
						{
							"buffer": 4,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/resources/AndroidManifest.xml",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1285,
								"regions":
								{
								},
								"selection":
								[
									[
										426,
										437
									]
								],
								"settings":
								{
									"syntax": "Packages/XML/XML.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 6,
							"type": "text"
						},
						{
							"buffer": 5,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/resources/assets/flutter_assets/LICENSE",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 633755,
								"regions":
								{
								},
								"selection":
								[
									[
										129595,
										129604
									]
								],
								"settings":
								{
									"syntax": "Packages/Text/Plain text.tmLanguage",
									"tab_size": 2,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 72062.0,
								"zoom_level": 1.0
							},
							"stack_index": 5,
							"type": "text"
						},
						{
							"buffer": 6,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test.txt",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 4822091,
								"regions":
								{
								},
								"selection":
								[
									[
										18344,
										18344
									]
								],
								"settings":
								{
									"syntax": "Packages/Text/Plain text.tmLanguage"
								},
								"translation.x": 0.0,
								"translation.y": 63261.0,
								"zoom_level": 1.0
							},
							"stack_index": 4,
							"type": "text"
						},
						{
							"buffer": 7,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test2.txt",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 355564,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"syntax": "Packages/Text/Plain text.tmLanguage"
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 3,
							"type": "text"
						},
						{
							"buffer": 8,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/test1.txt",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 10257563,
								"regions":
								{
								},
								"selection":
								[
									[
										9927823,
										9927823
									]
								],
								"settings":
								{
									"syntax": "Packages/Text/Plain text.tmLanguage"
								},
								"translation.x": 0.0,
								"translation.y": 8302148.0,
								"zoom_level": 1.0
							},
							"stack_index": 2,
							"type": "text"
						},
						{
							"buffer": 9,
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 646398,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										646398
									]
								],
								"settings":
								{
									"auto_name": "\"use strict\";",
									"syntax": "Packages/Text/Plain text.tmLanguage",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 1,
							"type": "text"
						},
						{
							"buffer": 10,
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 50,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										50
									]
								],
								"settings":
								{
									"auto_name": "username=1&password=1&csr=reboot&privatekey=%0D%0A",
									"syntax": "Packages/Text/Plain text.tmLanguage"
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 0,
							"type": "text"
						},
						{
							"buffer": 11,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterApplication.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 603,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 7,
							"type": "text"
						},
						{
							"buffer": 12,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/view/FlutterView.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 39641,
								"regions":
								{
								},
								"selection":
								[
									[
										36391,
										36391
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 23302.0,
								"zoom_level": 1.0
							},
							"stack_index": 8,
							"type": "text"
						},
						{
							"buffer": 13,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterFragmentActivity.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 3727,
								"regions":
								{
								},
								"selection":
								[
									[
										3274,
										3274
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 2835.0,
								"zoom_level": 1.0
							},
							"stack_index": 9,
							"type": "text"
						},
						{
							"buffer": 14,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterPluginRegistry.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 7589,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 5455.0,
								"zoom_level": 1.0
							},
							"stack_index": 10,
							"type": "text"
						},
						{
							"buffer": 15,
							"file": "/C/Users/Talgams/Downloads/Telegram Desktop/app.apk/sources/io/flutter/app/FlutterActivity.java",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 4003,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"syntax": "Packages/Java/Java.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 11,
							"type": "text"
						}
					]
				}
			],
			"incremental_find":
			{
				"height": 35.0
			},
			"input":
			{
				"height": 0.0
			},
			"layout":
			{
				"cells":
				[
					[
						0,
						0,
						1,
						1
					]
				],
				"cols":
				[
					0.0,
					1.0
				],
				"rows":
				[
					0.0,
					1.0
				]
			},
			"menu_visible": true,
			"output.find_results":
			{
				"height": 0.0
			},
			"pinned_build_system": "",
			"position": "0,2,3,-32000,-32000,-1,-1,588,50,50,706",
			"project": "",
			"replace":
			{
				"height": 66.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_symbol":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"selected_group": 0,
			"settings":
			{
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 150.0,
			"status_bar_visible": true,
			"template_settings":
			{
			},
			"window_id": 1,
			"workspace_name": ""
		}
	],
	"workspaces":
	{
		"recent_workspaces":
		[
		]
	}
}
